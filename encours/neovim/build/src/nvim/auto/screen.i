# 1 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
# 1 "/home/toto/.env/encours/neovim/build/src/nvim//"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "<command-line>" 2
# 1 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
# 63 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
# 1 "/usr/include/assert.h" 1 3 4
# 35 "/usr/include/assert.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 424 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 1 3 4
# 427 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 428 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 429 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 425 "/usr/include/features.h" 2 3 4
# 448 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 2 3 4
# 449 "/usr/include/features.h" 2 3 4
# 36 "/usr/include/assert.h" 2 3 4
# 66 "/usr/include/assert.h" 3 4




# 69 "/usr/include/assert.h" 3 4
extern void __assert_fail (const char *__assertion, const char *__file,
      unsigned int __line, const char *__function)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, const char *__file,
      unsigned int __line, const char *__function)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));



# 64 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 2
# 1 "/usr/include/inttypes.h" 1 3 4
# 27 "/usr/include/inttypes.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stdint.h" 1 3 4
# 9 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stdint.h" 3 4
# 1 "/usr/include/stdint.h" 1 3 4
# 26 "/usr/include/stdint.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;







typedef long int __quad_t;
typedef unsigned long int __u_quad_t;







typedef long int __intmax_t;
typedef unsigned long int __uintmax_t;
# 130 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/typesizes.h" 1 3 4
# 131 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;




typedef int __sig_atomic_t;
# 28 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wchar.h" 1 3 4
# 29 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 30 "/usr/include/stdint.h" 2 3 4




# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 3 4
typedef __int8_t int8_t;
typedef __int16_t int16_t;
typedef __int32_t int32_t;
typedef __int64_t int64_t;
# 35 "/usr/include/stdint.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h" 3 4
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
# 38 "/usr/include/stdint.h" 2 3 4





typedef signed char int_least8_t;
typedef short int int_least16_t;
typedef int int_least32_t;

typedef long int int_least64_t;






typedef unsigned char uint_least8_t;
typedef unsigned short int uint_least16_t;
typedef unsigned int uint_least32_t;

typedef unsigned long int uint_least64_t;
# 68 "/usr/include/stdint.h" 3 4
typedef signed char int_fast8_t;

typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
# 81 "/usr/include/stdint.h" 3 4
typedef unsigned char uint_fast8_t;

typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
# 97 "/usr/include/stdint.h" 3 4
typedef long int intptr_t;


typedef unsigned long int uintptr_t;
# 111 "/usr/include/stdint.h" 3 4
typedef __intmax_t intmax_t;
typedef __uintmax_t uintmax_t;
# 10 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stdint.h" 2 3 4
# 28 "/usr/include/inttypes.h" 2 3 4






typedef int __gwchar_t;
# 266 "/usr/include/inttypes.h" 3 4





typedef struct
  {
    long int quot;
    long int rem;
  } imaxdiv_t;
# 290 "/usr/include/inttypes.h" 3 4
extern intmax_t imaxabs (intmax_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern imaxdiv_t imaxdiv (intmax_t __numer, intmax_t __denom)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern intmax_t strtoimax (const char *__restrict __nptr,
      char **__restrict __endptr, int __base) __attribute__ ((__nothrow__ , __leaf__));


extern uintmax_t strtoumax (const char *__restrict __nptr,
       char ** __restrict __endptr, int __base) __attribute__ ((__nothrow__ , __leaf__));


extern intmax_t wcstoimax (const __gwchar_t *__restrict __nptr,
      __gwchar_t **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__));


extern uintmax_t wcstoumax (const __gwchar_t *__restrict __nptr,
       __gwchar_t ** __restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__));
# 432 "/usr/include/inttypes.h" 3 4

# 65 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 2
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stdbool.h" 1 3 4
# 66 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 2
# 1 "/usr/include/string.h" 1 3 4
# 26 "/usr/include/string.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/string.h" 2 3 4






# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 216 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 34 "/usr/include/string.h" 2 3 4
# 42 "/usr/include/string.h" 3 4
extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern void *memset (void *__s, int __c, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 90 "/usr/include/string.h" 3 4
extern void *memchr (const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 103 "/usr/include/string.h" 3 4
extern void *rawmemchr (const void *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 114 "/usr/include/string.h" 3 4
extern void *memrchr (const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



# 1 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 3 4
struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
};

typedef struct __locale_struct *__locale_t;
# 23 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 2 3 4

typedef __locale_t locale_t;
# 153 "/usr/include/string.h" 2 3 4


extern int strcoll_l (const char *__s1, const char *__s2, locale_t __l)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));


extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    locale_t __l) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));





extern char *strdup (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 225 "/usr/include/string.h" 3 4
extern char *strchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 252 "/usr/include/string.h" 3 4
extern char *strrchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 265 "/usr/include/string.h" 3 4
extern char *strchrnul (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern size_t strcspn (const char *__s, const char *__reject)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 302 "/usr/include/string.h" 3 4
extern char *strpbrk (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 329 "/usr/include/string.h" 3 4
extern char *strstr (const char *__haystack, const char *__needle)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
# 359 "/usr/include/string.h" 3 4
extern char *strcasestr (const char *__haystack, const char *__needle)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));







extern void *memmem (const void *__haystack, size_t __haystacklen,
       const void *__needle, size_t __needlelen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)));



extern void *__mempcpy (void *__restrict __dest,
   const void *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        const void *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern size_t strlen (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern size_t strnlen (const char *__string, size_t __maxlen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern char *strerror (int __errnum) __attribute__ ((__nothrow__ , __leaf__));
# 420 "/usr/include/string.h" 3 4
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;





extern char *strerror_l (int __errnum, locale_t __l) __attribute__ ((__nothrow__ , __leaf__));



# 1 "/usr/include/strings.h" 1 3 4
# 23 "/usr/include/strings.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 24 "/usr/include/strings.h" 2 3 4










extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bcopy (const void *__src, void *__dest, size_t __n)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 68 "/usr/include/strings.h" 3 4
extern char *index (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 96 "/usr/include/strings.h" 3 4
extern char *rindex (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));






extern int ffs (int __i) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));





extern int ffsl (long int __l) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
__extension__ extern int ffsll (long long int __ll)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern int strcasecmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));






extern int strcasecmp_l (const char *__s1, const char *__s2, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));



extern int strncasecmp_l (const char *__s1, const char *__s2,
     size_t __n, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));



# 432 "/usr/include/string.h" 2 3 4



extern void explicit_bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) __attribute__ ((__nothrow__ , __leaf__));


extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int strverscmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 486 "/usr/include/string.h" 3 4
extern char *basename (const char *__filename) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 498 "/usr/include/string.h" 3 4

# 67 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 2

# 1 "/home/toto/.env/encours/neovim/src/nvim/log.h" 1



# 1 "/usr/include/stdio.h" 1 3 4
# 27 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 28 "/usr/include/stdio.h" 2 3 4





# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 34 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h" 1 3 4



struct _IO_FILE;
typedef struct _IO_FILE __FILE;
# 37 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h" 1 3 4



struct _IO_FILE;


typedef struct _IO_FILE FILE;
# 38 "/usr/include/stdio.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/libio.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/_G_config.h" 1 3 4
# 19 "/usr/include/x86_64-linux-gnu/bits/_G_config.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/_G_config.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 1 3 4
# 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 3 4
typedef struct
{
  int __count;
  union
  {
    unsigned int __wch;
    char __wchb[4];
  } __value;
} __mbstate_t;
# 22 "/usr/include/x86_64-linux-gnu/bits/_G_config.h" 2 3 4




typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
# 36 "/usr/include/x86_64-linux-gnu/bits/libio.h" 2 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stdarg.h" 1 3 4
# 40 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 54 "/usr/include/x86_64-linux-gnu/bits/libio.h" 2 3 4
# 149 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
struct _IO_jump_t; struct _IO_FILE;




typedef void _IO_lock_t;





struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;



  int _pos;
# 177 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
};


enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};
# 245 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
struct _IO_FILE {
  int _flags;




  char* _IO_read_ptr;
  char* _IO_read_end;
  char* _IO_read_base;
  char* _IO_write_base;
  char* _IO_write_ptr;
  char* _IO_write_end;
  char* _IO_buf_base;
  char* _IO_buf_end;

  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;



  int _flags2;

  __off_t _old_offset;



  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];



  _IO_lock_t *_lock;
# 293 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
  __off64_t _offset;







  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;

  size_t __pad5;
  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];

};


typedef struct _IO_FILE _IO_FILE;


struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;
# 337 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);







typedef __ssize_t __io_write_fn (void *__cookie, const char *__buf,
     size_t __n);







typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);


typedef int __io_close_fn (void *__cookie);




typedef __io_read_fn cookie_read_function_t;
typedef __io_write_fn cookie_write_function_t;
typedef __io_seek_fn cookie_seek_function_t;
typedef __io_close_fn cookie_close_function_t;


typedef struct
{
  __io_read_fn *read;
  __io_write_fn *write;
  __io_seek_fn *seek;
  __io_close_fn *close;
} _IO_cookie_io_functions_t;
typedef _IO_cookie_io_functions_t cookie_io_functions_t;

struct _IO_cookie_file;


extern void _IO_cookie_init (struct _IO_cookie_file *__cfile, int __read_write,
        void *__cookie, _IO_cookie_io_functions_t __fns);







extern int __underflow (_IO_FILE *);
extern int __uflow (_IO_FILE *);
extern int __overflow (_IO_FILE *, int);
# 433 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
extern int _IO_getc (_IO_FILE *__fp);
extern int _IO_putc (int __c, _IO_FILE *__fp);
extern int _IO_feof (_IO_FILE *__fp) __attribute__ ((__nothrow__ , __leaf__));
extern int _IO_ferror (_IO_FILE *__fp) __attribute__ ((__nothrow__ , __leaf__));

extern int _IO_peekc_locked (_IO_FILE *__fp);





extern void _IO_flockfile (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
extern void _IO_funlockfile (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
extern int _IO_ftrylockfile (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
# 462 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
   __gnuc_va_list, int *__restrict);
extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
    __gnuc_va_list);
extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t);
extern size_t _IO_sgetn (_IO_FILE *, void *, size_t);

extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int);
extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int);

extern void _IO_free_backup_area (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
# 42 "/usr/include/stdio.h" 2 3 4




typedef __gnuc_va_list va_list;
# 57 "/usr/include/stdio.h" 3 4
typedef __off_t off_t;






typedef __off64_t off64_t;






typedef __ssize_t ssize_t;






typedef _G_fpos_t fpos_t;




typedef _G_fpos64_t fpos64_t;
# 131 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdio_lim.h" 1 3 4
# 132 "/usr/include/stdio.h" 2 3 4



extern struct _IO_FILE *stdin;
extern struct _IO_FILE *stdout;
extern struct _IO_FILE *stderr;






extern int remove (const char *__filename) __attribute__ ((__nothrow__ , __leaf__));

extern int rename (const char *__old, const char *__new) __attribute__ ((__nothrow__ , __leaf__));



extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) __attribute__ ((__nothrow__ , __leaf__));







extern FILE *tmpfile (void) ;
# 169 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile64 (void) ;



extern char *tmpnam (char *__s) __attribute__ ((__nothrow__ , __leaf__)) ;




extern char *tmpnam_r (char *__s) __attribute__ ((__nothrow__ , __leaf__)) ;
# 190 "/usr/include/stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;







extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);
# 213 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 223 "/usr/include/stdio.h" 3 4
extern int fcloseall (void);
# 232 "/usr/include/stdio.h" 3 4
extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes) ;




extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) ;
# 256 "/usr/include/stdio.h" 3 4
extern FILE *fopen64 (const char *__restrict __filename,
        const char *__restrict __modes) ;
extern FILE *freopen64 (const char *__restrict __filename,
   const char *__restrict __modes,
   FILE *__restrict __stream) ;




extern FILE *fdopen (int __fd, const char *__modes) __attribute__ ((__nothrow__ , __leaf__)) ;





extern FILE *fopencookie (void *__restrict __magic_cookie,
     const char *__restrict __modes,
     _IO_cookie_io_functions_t __io_funcs) __attribute__ ((__nothrow__ , __leaf__)) ;




extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  __attribute__ ((__nothrow__ , __leaf__)) ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) __attribute__ ((__nothrow__ , __leaf__)) ;





extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) __attribute__ ((__nothrow__ , __leaf__));




extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) __attribute__ ((__nothrow__ , __leaf__));


extern void setlinebuf (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));







extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) __attribute__ ((__nothrow__));





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) __attribute__ ((__nothrow__));



extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 0)));





extern int vasprintf (char **__restrict __ptr, const char *__restrict __f,
        __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 0))) ;
extern int __asprintf (char **__restrict __ptr,
         const char *__restrict __fmt, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3))) ;
extern int asprintf (char **__restrict __ptr,
       const char *__restrict __fmt, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3))) ;




extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));







extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) ;




extern int scanf (const char *__restrict __format, ...) ;

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) __attribute__ ((__nothrow__ , __leaf__));
# 420 "/usr/include/stdio.h" 3 4
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format__ (__scanf__, 2, 0)));
# 477 "/usr/include/stdio.h" 3 4
extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);
# 495 "/usr/include/stdio.h" 3 4
extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 506 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);
# 517 "/usr/include/stdio.h" 3 4
extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);
# 537 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);







extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     ;
# 587 "/usr/include/stdio.h" 3 4
extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream) ;
# 603 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
          size_t *__restrict __n, int __delimiter,
          FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
        size_t *__restrict __n, int __delimiter,
        FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
       size_t *__restrict __n,
       FILE *__restrict __stream) ;







extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);
# 662 "/usr/include/stdio.h" 3 4
extern int fputs_unlocked (const char *__restrict __s,
      FILE *__restrict __stream);
# 673 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);







extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);
# 707 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
# 731 "/usr/include/stdio.h" 3 4
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, const fpos_t *__pos);
# 750 "/usr/include/stdio.h" 3 4
extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) ;
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, const fpos64_t *__pos);



extern void clearerr (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));

extern int feof (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;

extern int ferror (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;



extern void clearerr_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
extern int feof_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
extern int ferror_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;







extern void perror (const char *__s);





# 1 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern const char *const sys_errlist[];


extern int _sys_nerr;
extern const char *const _sys_errlist[];
# 782 "/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int fileno_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
# 800 "/usr/include/stdio.h" 3 4
extern FILE *popen (const char *__command, const char *__modes) ;





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) __attribute__ ((__nothrow__ , __leaf__));





extern char *cuserid (char *__s);




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
      const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       const char *__restrict __format,
       __gnuc_va_list __args)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));



extern int ftrylockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;


extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
# 868 "/usr/include/stdio.h" 3 4

# 5 "/home/toto/.env/encours/neovim/src/nvim/log.h" 2


# 1 "/home/toto/.env/encours/neovim/build/config/auto/config.h" 1
# 8 "/home/toto/.env/encours/neovim/src/nvim/log.h" 2
# 69 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 2
# 1 "/home/toto/.env/encours/neovim/src/nvim/vim.h" 1



# 1 "/home/toto/.env/encours/neovim/src/nvim/types.h" 1







# 7 "/home/toto/.env/encours/neovim/src/nvim/types.h"
typedef void *vim_acl_T;



typedef unsigned char char_u;


typedef uint32_t u8char_T;


typedef int handle_T;




typedef int LuaRef;

typedef struct expand expand_T;

typedef enum {
  kNone = -1,
  kFalse = 0,
  kTrue = 1,
} TriState;
# 5 "/home/toto/.env/encours/neovim/src/nvim/vim.h" 2
# 1 "/home/toto/.env/encours/neovim/src/nvim/pos.h" 1



typedef long linenr_T;




typedef int colnr_T;




enum { MAXLNUM = 0x7fffffff };

enum { MAXCOL = 0x7fffffff };

enum { MINLNUM = 1 };

enum { MINCOL = 1 };




typedef struct {
  linenr_T lnum;
  colnr_T col;
  colnr_T coladd;
} pos_T;





typedef struct {
  linenr_T lnum;
  colnr_T col;
} lpos_T;
# 6 "/home/toto/.env/encours/neovim/src/nvim/vim.h" 2
# 24 "/home/toto/.env/encours/neovim/src/nvim/vim.h"
# 1 "/home/toto/.env/encours/neovim/src/nvim/os/os_defs.h" 1



# 1 "/usr/include/ctype.h" 1 3 4
# 28 "/usr/include/ctype.h" 3 4

# 39 "/usr/include/ctype.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 36 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endian.h" 1 3 4
# 37 "/usr/include/endian.h" 2 3 4
# 60 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 2 3 4






# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap-16.h" 1 3 4
# 36 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 2 3 4
# 44 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4

# 44 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
static __inline unsigned int
__bswap_32 (unsigned int __bsx)
{
  return __builtin_bswap32 (__bsx);
}
# 108 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
static __inline __uint64_t
__bswap_64 (__uint64_t __bsx)
{
  return __builtin_bswap64 (__bsx);
}
# 61 "/usr/include/endian.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 1 3 4
# 32 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 3 4
static __inline __uint16_t
__uint16_identity (__uint16_t __x)
{
  return __x;
}

static __inline __uint32_t
__uint32_identity (__uint32_t __x)
{
  return __x;
}

static __inline __uint64_t
__uint64_identity (__uint64_t __x)
{
  return __x;
}
# 62 "/usr/include/endian.h" 2 3 4
# 40 "/usr/include/ctype.h" 2 3 4






enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
};
# 79 "/usr/include/ctype.h" 3 4
extern const unsigned short int **__ctype_b_loc (void)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern const __int32_t **__ctype_tolower_loc (void)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern const __int32_t **__ctype_toupper_loc (void)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 108 "/usr/include/ctype.h" 3 4
extern int isalnum (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isalpha (int) __attribute__ ((__nothrow__ , __leaf__));
extern int iscntrl (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isdigit (int) __attribute__ ((__nothrow__ , __leaf__));
extern int islower (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isgraph (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isprint (int) __attribute__ ((__nothrow__ , __leaf__));
extern int ispunct (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isspace (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isupper (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isxdigit (int) __attribute__ ((__nothrow__ , __leaf__));



extern int tolower (int __c) __attribute__ ((__nothrow__ , __leaf__));


extern int toupper (int __c) __attribute__ ((__nothrow__ , __leaf__));




extern int isblank (int) __attribute__ ((__nothrow__ , __leaf__));




extern int isctype (int __c, int __mask) __attribute__ ((__nothrow__ , __leaf__));






extern int isascii (int __c) __attribute__ ((__nothrow__ , __leaf__));



extern int toascii (int __c) __attribute__ ((__nothrow__ , __leaf__));



extern int _toupper (int) __attribute__ ((__nothrow__ , __leaf__));
extern int _tolower (int) __attribute__ ((__nothrow__ , __leaf__));
# 251 "/usr/include/ctype.h" 3 4
extern int isalnum_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isalpha_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int iscntrl_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isdigit_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int islower_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isgraph_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isprint_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int ispunct_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isspace_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isupper_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isxdigit_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));

extern int isblank_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));



extern int __tolower_l (int __c, locale_t __l) __attribute__ ((__nothrow__ , __leaf__));
extern int tolower_l (int __c, locale_t __l) __attribute__ ((__nothrow__ , __leaf__));


extern int __toupper_l (int __c, locale_t __l) __attribute__ ((__nothrow__ , __leaf__));
extern int toupper_l (int __c, locale_t __l) __attribute__ ((__nothrow__ , __leaf__));
# 327 "/usr/include/ctype.h" 3 4

# 5 "/home/toto/.env/encours/neovim/src/nvim/os/os_defs.h" 2

# 1 "/usr/include/stdlib.h" 1 3 4
# 25 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 26 "/usr/include/stdlib.h" 2 3 4





# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 328 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4
typedef int wchar_t;
# 32 "/usr/include/stdlib.h" 2 3 4







# 1 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 1 3 4
# 52 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 3 4
typedef enum
{
  P_ALL,
  P_PID,
  P_PGID
} idtype_t;
# 40 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 1 3 4
# 41 "/usr/include/stdlib.h" 2 3 4
# 55 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 1 3 4
# 120 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 2 3 4
# 121 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 2 3 4
# 56 "/usr/include/stdlib.h" 2 3 4


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;





__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;
# 97 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) __attribute__ ((__nothrow__ , __leaf__)) ;



extern double atof (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



__extension__ extern long long int atoll (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 140 "/usr/include/stdlib.h" 3 4
extern _Float32 strtof32 (const char *__restrict __nptr,
     char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern _Float64 strtof64 (const char *__restrict __nptr,
     char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern _Float128 strtof128 (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern _Float32x strtof32x (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern _Float64x strtof64x (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 176 "/usr/include/stdlib.h" 3 4
extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




extern int strfromd (char *__dest, size_t __size, const char *__format,
       double __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));

extern int strfromf (char *__dest, size_t __size, const char *__format,
       float __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));

extern int strfroml (char *__dest, size_t __size, const char *__format,
       long double __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));
# 232 "/usr/include/stdlib.h" 3 4
extern int strfromf32 (char *__dest, size_t __size, const char * __format,
         _Float32 __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));



extern int strfromf64 (char *__dest, size_t __size, const char * __format,
         _Float64 __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));



extern int strfromf128 (char *__dest, size_t __size, const char * __format,
   _Float128 __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));



extern int strfromf32x (char *__dest, size_t __size, const char * __format,
   _Float32x __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));



extern int strfromf64x (char *__dest, size_t __size, const char * __format,
   _Float64x __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));
# 274 "/usr/include/stdlib.h" 3 4
extern long int strtol_l (const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     locale_t __loc) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

extern unsigned long int strtoul_l (const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern long long int strtoll_l (const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern unsigned long long int strtoull_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

extern double strtod_l (const char *__restrict __nptr,
   char **__restrict __endptr, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));

extern float strtof_l (const char *__restrict __nptr,
         char **__restrict __endptr, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));

extern long double strtold_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));
# 316 "/usr/include/stdlib.h" 3 4
extern _Float32 strtof32_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));



extern _Float64 strtof64_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));



extern _Float128 strtof128_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));



extern _Float32x strtof32x_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));



extern _Float64x strtof64x_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));
# 385 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) __attribute__ ((__nothrow__ , __leaf__)) ;


extern long int a64l (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;




# 1 "/usr/include/x86_64-linux-gnu/sys/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4






typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;




typedef __loff_t loff_t;



typedef __ino_t ino_t;






typedef __ino64_t ino64_t;




typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;
# 98 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __pid_t pid_t;





typedef __id_t id_t;
# 115 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;




# 1 "/usr/include/x86_64-linux-gnu/bits/types/clock_t.h" 1 3 4






typedef __clock_t clock_t;
# 128 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/clockid_t.h" 1 3 4






typedef __clockid_t clockid_t;
# 130 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h" 1 3 4






typedef __time_t time_t;
# 131 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/timer_t.h" 1 3 4






typedef __timer_t timer_t;
# 132 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef __useconds_t useconds_t;



typedef __suseconds_t suseconds_t;





# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 146 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
# 178 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));

typedef int register_t __attribute__ ((__mode__ (__word__)));
# 197 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/select.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/select.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/select.h" 2 3 4
# 31 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h" 1 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h" 1 3 4




typedef struct
{
  unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
} __sigset_t;
# 5 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h" 2 3 4


typedef __sigset_t sigset_t;
# 34 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h" 1 3 4







struct timeval
{
  __time_t tv_sec;
  __suseconds_t tv_usec;
};
# 38 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 1 3 4







struct timespec
{
  __time_t tv_sec;
  __syscall_slong_t tv_nsec;
};
# 40 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4
# 49 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef long int __fd_mask;
# 59 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
# 91 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4

# 101 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 113 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);
# 126 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4

# 198 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4







# 1 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 1 3 4
# 41 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/sysmacros.h" 1 3 4
# 42 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 2 3 4
# 71 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 3 4


extern unsigned int gnu_dev_major (__dev_t __dev) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern unsigned int gnu_dev_minor (__dev_t __dev) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern __dev_t gnu_dev_makedev (unsigned int __major, unsigned int __minor) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 85 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 3 4

# 206 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4






typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 246 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;





# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 1 3 4
# 77 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 2 3 4
# 65 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 3 4
struct __pthread_rwlock_arch_t
{
  unsigned int __readers;
  unsigned int __writers;
  unsigned int __wrphase_futex;
  unsigned int __writers_futex;
  unsigned int __pad3;
  unsigned int __pad4;

  int __cur_writer;
  int __shared;
  signed char __rwelision;




  unsigned char __pad1[7];


  unsigned long int __pad2;


  unsigned int __flags;
# 99 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 3 4
};
# 78 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4




typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;
# 118 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
struct __pthread_mutex_s
{
  int __lock ;
  unsigned int __count;
  int __owner;

  unsigned int __nusers;



  int __kind;
 




  short __spins; short __elision;
  __pthread_list_t __list;
# 145 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
 
};




struct __pthread_cond_s
{
  __extension__ union
  {
    __extension__ unsigned long long int __wseq;
    struct
    {
      unsigned int __low;
      unsigned int __high;
    } __wseq32;
  };
  __extension__ union
  {
    __extension__ unsigned long long int __g1_start;
    struct
    {
      unsigned int __low;
      unsigned int __high;
    } __g1_start32;
  };
  unsigned int __g_refs[2] ;
  unsigned int __g_size[2];
  unsigned int __g1_orig_size;
  unsigned int __wrefs;
  unsigned int __g_signals[2];
};
# 24 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 2 3 4



typedef unsigned long int pthread_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;


union pthread_attr_t
{
  char __size[56];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;




typedef union
{
  struct __pthread_mutex_s __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;


typedef union
{
  struct __pthread_cond_s __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;





typedef union
{
  struct __pthread_rwlock_arch_t __data;
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 255 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



# 395 "/usr/include/stdlib.h" 2 3 4






extern long int random (void) __attribute__ ((__nothrow__ , __leaf__));


extern void srandom (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern int rand (void) __attribute__ ((__nothrow__ , __leaf__));

extern void srand (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));



extern int rand_r (unsigned int *__seed) __attribute__ ((__nothrow__ , __leaf__));







extern double drand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern double erand48 (unsigned short int __xsubi[3]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern long int nrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern long int jrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) __attribute__ ((__nothrow__ , __leaf__));
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    __extension__ unsigned long long int __a;

  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern void *malloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;

extern void *calloc (size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;






extern void *realloc (void *__ptr, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));







extern void *reallocarray (void *__ptr, size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));



extern void free (void *__ptr) __attribute__ ((__nothrow__ , __leaf__));


# 1 "/usr/include/alloca.h" 1 3 4
# 24 "/usr/include/alloca.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 25 "/usr/include/alloca.h" 2 3 4







extern void *alloca (size_t __size) __attribute__ ((__nothrow__ , __leaf__));






# 567 "/usr/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;




extern void *aligned_alloc (size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (2))) ;



extern void abort (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







extern int at_quick_exit (void (*__func) (void)) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern void exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));





extern void quick_exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));





extern void _Exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));




extern char *getenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;




extern char *secure_getenv (const char *__name)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;






extern int putenv (char *__string) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) __attribute__ ((__nothrow__ , __leaf__));
# 672 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 685 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 695 "/usr/include/stdlib.h" 3 4
extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 707 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
# 717 "/usr/include/stdlib.h" 3 4
extern int mkstemps64 (char *__template, int __suffixlen)
     __attribute__ ((__nonnull__ (1))) ;
# 728 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 739 "/usr/include/stdlib.h" 3 4
extern int mkostemp (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 749 "/usr/include/stdlib.h" 3 4
extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 759 "/usr/include/stdlib.h" 3 4
extern int mkostemps (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 771 "/usr/include/stdlib.h" 3 4
extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 781 "/usr/include/stdlib.h" 3 4
extern int system (const char *__command) ;





extern char *canonicalize_file_name (const char *__name)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 797 "/usr/include/stdlib.h" 3 4
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) __attribute__ ((__nothrow__ , __leaf__)) ;






typedef int (*__compar_fn_t) (const void *, const void *);


typedef __compar_fn_t comparison_fn_t;



typedef int (*__compar_d_fn_t) (const void *, const void *, void *);




extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;







extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
       __compar_d_fn_t __compar, void *__arg)
  __attribute__ ((__nonnull__ (1, 4)));




extern int abs (int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
extern long int labs (long int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;


__extension__ extern long long int llabs (long long int __x)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;






extern div_t div (int __numer, int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;


__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
# 869 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));





extern int mblen (const char *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));


extern int wctomb (char *__s, wchar_t __wchar) __attribute__ ((__nothrow__ , __leaf__));



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__));







extern int rpmatch (const char *__response) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 954 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2, 3))) ;





extern void setkey (const char *__key) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







extern int posix_openpt (int __oflag) ;







extern int grantpt (int __fd) __attribute__ ((__nothrow__ , __leaf__));



extern int unlockpt (int __fd) __attribute__ ((__nothrow__ , __leaf__));




extern char *ptsname (int __fd) __attribute__ ((__nothrow__ , __leaf__)) ;






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 1016 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 1 3 4
# 1017 "/usr/include/stdlib.h" 2 3 4
# 1026 "/usr/include/stdlib.h" 3 4

# 7 "/home/toto/.env/encours/neovim/src/nvim/os/os_defs.h" 2
# 1 "/usr/include/x86_64-linux-gnu/sys/stat.h" 1 3 4
# 99 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/stat.h" 1 3 4
# 46 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
struct stat
  {
    __dev_t st_dev;




    __ino_t st_ino;







    __nlink_t st_nlink;
    __mode_t st_mode;

    __uid_t st_uid;
    __gid_t st_gid;

    int __pad0;

    __dev_t st_rdev;




    __off_t st_size;



    __blksize_t st_blksize;

    __blkcnt_t st_blocks;
# 91 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
# 106 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
    __syscall_slong_t __glibc_reserved[3];
# 115 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
  };



struct stat64
  {
    __dev_t st_dev;

    __ino64_t st_ino;
    __nlink_t st_nlink;
    __mode_t st_mode;






    __uid_t st_uid;
    __gid_t st_gid;

    int __pad0;
    __dev_t st_rdev;
    __off_t st_size;





    __blksize_t st_blksize;
    __blkcnt64_t st_blocks;







    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
# 164 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
    __syscall_slong_t __glibc_reserved[3];



  };
# 102 "/usr/include/x86_64-linux-gnu/sys/stat.h" 2 3 4
# 205 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int stat (const char *__restrict __file,
   struct stat *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int fstat (int __fd, struct stat *__buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));
# 224 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int stat64 (const char *__restrict __file,
     struct stat64 *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int fstat64 (int __fd, struct stat64 *__buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));







extern int fstatat (int __fd, const char *__restrict __file,
      struct stat *__restrict __buf, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
# 249 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int fstatat64 (int __fd, const char *__restrict __file,
        struct stat64 *__restrict __buf, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));







extern int lstat (const char *__restrict __file,
    struct stat *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
# 272 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int lstat64 (const char *__restrict __file,
      struct stat64 *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern int chmod (const char *__file, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int lchmod (const char *__file, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




extern int fchmod (int __fd, __mode_t __mode) __attribute__ ((__nothrow__ , __leaf__));





extern int fchmodat (int __fd, const char *__file, __mode_t __mode,
       int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;






extern __mode_t umask (__mode_t __mask) __attribute__ ((__nothrow__ , __leaf__));




extern __mode_t getumask (void) __attribute__ ((__nothrow__ , __leaf__));



extern int mkdir (const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int mkdirat (int __fd, const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));






extern int mknod (const char *__path, __mode_t __mode, __dev_t __dev)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int mknodat (int __fd, const char *__path, __mode_t __mode,
      __dev_t __dev) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));





extern int mkfifo (const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int mkfifoat (int __fd, const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));





extern int utimensat (int __fd, const char *__path,
        const struct timespec __times[2],
        int __flags)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));




extern int futimens (int __fd, const struct timespec __times[2]) __attribute__ ((__nothrow__ , __leaf__));
# 395 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int __fxstat (int __ver, int __fildes, struct stat *__stat_buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));
extern int __xstat (int __ver, const char *__filename,
      struct stat *__stat_buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
extern int __lxstat (int __ver, const char *__filename,
       struct stat *__stat_buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
extern int __fxstatat (int __ver, int __fildes, const char *__filename,
         struct stat *__stat_buf, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4)));
# 428 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int __fxstat64 (int __ver, int __fildes, struct stat64 *__stat_buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));
extern int __xstat64 (int __ver, const char *__filename,
        struct stat64 *__stat_buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
extern int __lxstat64 (int __ver, const char *__filename,
         struct stat64 *__stat_buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
extern int __fxstatat64 (int __ver, int __fildes, const char *__filename,
    struct stat64 *__stat_buf, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4)));

extern int __xmknod (int __ver, const char *__path, __mode_t __mode,
       __dev_t *__dev) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));

extern int __xmknodat (int __ver, int __fd, const char *__path,
         __mode_t __mode, __dev_t *__dev)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 5)));
# 530 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4

# 8 "/home/toto/.env/encours/neovim/src/nvim/os/os_defs.h" 2





# 1 "/home/toto/.env/encours/neovim/src/nvim/os/unix_defs.h" 1



# 1 "/usr/include/unistd.h" 1 3 4
# 27 "/usr/include/unistd.h" 3 4

# 205 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/posix_opt.h" 1 3 4
# 206 "/usr/include/unistd.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/environments.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/environments.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/environments.h" 2 3 4
# 210 "/usr/include/unistd.h" 2 3 4
# 229 "/usr/include/unistd.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 230 "/usr/include/unistd.h" 2 3 4
# 277 "/usr/include/unistd.h" 3 4
typedef __socklen_t socklen_t;
# 290 "/usr/include/unistd.h" 3 4
extern int access (const char *__name, int __type) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




extern int euidaccess (const char *__name, int __type)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int eaccess (const char *__name, int __type)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int faccessat (int __fd, const char *__file, int __type, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;
# 337 "/usr/include/unistd.h" 3 4
extern __off_t lseek (int __fd, __off_t __offset, int __whence) __attribute__ ((__nothrow__ , __leaf__));
# 348 "/usr/include/unistd.h" 3 4
extern __off64_t lseek64 (int __fd, __off64_t __offset, int __whence)
     __attribute__ ((__nothrow__ , __leaf__));






extern int close (int __fd);






extern ssize_t read (int __fd, void *__buf, size_t __nbytes) ;





extern ssize_t write (int __fd, const void *__buf, size_t __n) ;
# 379 "/usr/include/unistd.h" 3 4
extern ssize_t pread (int __fd, void *__buf, size_t __nbytes,
        __off_t __offset) ;






extern ssize_t pwrite (int __fd, const void *__buf, size_t __n,
         __off_t __offset) ;
# 407 "/usr/include/unistd.h" 3 4
extern ssize_t pread64 (int __fd, void *__buf, size_t __nbytes,
   __off64_t __offset) ;


extern ssize_t pwrite64 (int __fd, const void *__buf, size_t __n,
    __off64_t __offset) ;







extern int pipe (int __pipedes[2]) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int pipe2 (int __pipedes[2], int __flags) __attribute__ ((__nothrow__ , __leaf__)) ;
# 435 "/usr/include/unistd.h" 3 4
extern unsigned int alarm (unsigned int __seconds) __attribute__ ((__nothrow__ , __leaf__));
# 447 "/usr/include/unistd.h" 3 4
extern unsigned int sleep (unsigned int __seconds);







extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
     __attribute__ ((__nothrow__ , __leaf__));






extern int usleep (__useconds_t __useconds);
# 472 "/usr/include/unistd.h" 3 4
extern int pause (void);



extern int chown (const char *__file, __uid_t __owner, __gid_t __group)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



extern int fchown (int __fd, __uid_t __owner, __gid_t __group) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int lchown (const char *__file, __uid_t __owner, __gid_t __group)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;






extern int fchownat (int __fd, const char *__file, __uid_t __owner,
       __gid_t __group, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;



extern int chdir (const char *__path) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



extern int fchdir (int __fd) __attribute__ ((__nothrow__ , __leaf__)) ;
# 514 "/usr/include/unistd.h" 3 4
extern char *getcwd (char *__buf, size_t __size) __attribute__ ((__nothrow__ , __leaf__)) ;





extern char *get_current_dir_name (void) __attribute__ ((__nothrow__ , __leaf__));







extern char *getwd (char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__)) ;




extern int dup (int __fd) __attribute__ ((__nothrow__ , __leaf__)) ;


extern int dup2 (int __fd, int __fd2) __attribute__ ((__nothrow__ , __leaf__));




extern int dup3 (int __fd, int __fd2, int __flags) __attribute__ ((__nothrow__ , __leaf__));



extern char **__environ;

extern char **environ;





extern int execve (const char *__path, char *const __argv[],
     char *const __envp[]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int fexecve (int __fd, char *const __argv[], char *const __envp[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));




extern int execv (const char *__path, char *const __argv[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int execle (const char *__path, const char *__arg, ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int execl (const char *__path, const char *__arg, ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int execvp (const char *__file, char *const __argv[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int execlp (const char *__file, const char *__arg, ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int execvpe (const char *__file, char *const __argv[],
      char *const __envp[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern int nice (int __inc) __attribute__ ((__nothrow__ , __leaf__)) ;




extern void _exit (int __status) __attribute__ ((__noreturn__));





# 1 "/usr/include/x86_64-linux-gnu/bits/confname.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/confname.h" 3 4
enum
  {
    _PC_LINK_MAX,

    _PC_MAX_CANON,

    _PC_MAX_INPUT,

    _PC_NAME_MAX,

    _PC_PATH_MAX,

    _PC_PIPE_BUF,

    _PC_CHOWN_RESTRICTED,

    _PC_NO_TRUNC,

    _PC_VDISABLE,

    _PC_SYNC_IO,

    _PC_ASYNC_IO,

    _PC_PRIO_IO,

    _PC_SOCK_MAXBUF,

    _PC_FILESIZEBITS,

    _PC_REC_INCR_XFER_SIZE,

    _PC_REC_MAX_XFER_SIZE,

    _PC_REC_MIN_XFER_SIZE,

    _PC_REC_XFER_ALIGN,

    _PC_ALLOC_SIZE_MIN,

    _PC_SYMLINK_MAX,

    _PC_2_SYMLINKS

  };


enum
  {
    _SC_ARG_MAX,

    _SC_CHILD_MAX,

    _SC_CLK_TCK,

    _SC_NGROUPS_MAX,

    _SC_OPEN_MAX,

    _SC_STREAM_MAX,

    _SC_TZNAME_MAX,

    _SC_JOB_CONTROL,

    _SC_SAVED_IDS,

    _SC_REALTIME_SIGNALS,

    _SC_PRIORITY_SCHEDULING,

    _SC_TIMERS,

    _SC_ASYNCHRONOUS_IO,

    _SC_PRIORITIZED_IO,

    _SC_SYNCHRONIZED_IO,

    _SC_FSYNC,

    _SC_MAPPED_FILES,

    _SC_MEMLOCK,

    _SC_MEMLOCK_RANGE,

    _SC_MEMORY_PROTECTION,

    _SC_MESSAGE_PASSING,

    _SC_SEMAPHORES,

    _SC_SHARED_MEMORY_OBJECTS,

    _SC_AIO_LISTIO_MAX,

    _SC_AIO_MAX,

    _SC_AIO_PRIO_DELTA_MAX,

    _SC_DELAYTIMER_MAX,

    _SC_MQ_OPEN_MAX,

    _SC_MQ_PRIO_MAX,

    _SC_VERSION,

    _SC_PAGESIZE,


    _SC_RTSIG_MAX,

    _SC_SEM_NSEMS_MAX,

    _SC_SEM_VALUE_MAX,

    _SC_SIGQUEUE_MAX,

    _SC_TIMER_MAX,




    _SC_BC_BASE_MAX,

    _SC_BC_DIM_MAX,

    _SC_BC_SCALE_MAX,

    _SC_BC_STRING_MAX,

    _SC_COLL_WEIGHTS_MAX,

    _SC_EQUIV_CLASS_MAX,

    _SC_EXPR_NEST_MAX,

    _SC_LINE_MAX,

    _SC_RE_DUP_MAX,

    _SC_CHARCLASS_NAME_MAX,


    _SC_2_VERSION,

    _SC_2_C_BIND,

    _SC_2_C_DEV,

    _SC_2_FORT_DEV,

    _SC_2_FORT_RUN,

    _SC_2_SW_DEV,

    _SC_2_LOCALEDEF,


    _SC_PII,

    _SC_PII_XTI,

    _SC_PII_SOCKET,

    _SC_PII_INTERNET,

    _SC_PII_OSI,

    _SC_POLL,

    _SC_SELECT,

    _SC_UIO_MAXIOV,

    _SC_IOV_MAX = _SC_UIO_MAXIOV,

    _SC_PII_INTERNET_STREAM,

    _SC_PII_INTERNET_DGRAM,

    _SC_PII_OSI_COTS,

    _SC_PII_OSI_CLTS,

    _SC_PII_OSI_M,

    _SC_T_IOV_MAX,



    _SC_THREADS,

    _SC_THREAD_SAFE_FUNCTIONS,

    _SC_GETGR_R_SIZE_MAX,

    _SC_GETPW_R_SIZE_MAX,

    _SC_LOGIN_NAME_MAX,

    _SC_TTY_NAME_MAX,

    _SC_THREAD_DESTRUCTOR_ITERATIONS,

    _SC_THREAD_KEYS_MAX,

    _SC_THREAD_STACK_MIN,

    _SC_THREAD_THREADS_MAX,

    _SC_THREAD_ATTR_STACKADDR,

    _SC_THREAD_ATTR_STACKSIZE,

    _SC_THREAD_PRIORITY_SCHEDULING,

    _SC_THREAD_PRIO_INHERIT,

    _SC_THREAD_PRIO_PROTECT,

    _SC_THREAD_PROCESS_SHARED,


    _SC_NPROCESSORS_CONF,

    _SC_NPROCESSORS_ONLN,

    _SC_PHYS_PAGES,

    _SC_AVPHYS_PAGES,

    _SC_ATEXIT_MAX,

    _SC_PASS_MAX,


    _SC_XOPEN_VERSION,

    _SC_XOPEN_XCU_VERSION,

    _SC_XOPEN_UNIX,

    _SC_XOPEN_CRYPT,

    _SC_XOPEN_ENH_I18N,

    _SC_XOPEN_SHM,


    _SC_2_CHAR_TERM,

    _SC_2_C_VERSION,

    _SC_2_UPE,


    _SC_XOPEN_XPG2,

    _SC_XOPEN_XPG3,

    _SC_XOPEN_XPG4,


    _SC_CHAR_BIT,

    _SC_CHAR_MAX,

    _SC_CHAR_MIN,

    _SC_INT_MAX,

    _SC_INT_MIN,

    _SC_LONG_BIT,

    _SC_WORD_BIT,

    _SC_MB_LEN_MAX,

    _SC_NZERO,

    _SC_SSIZE_MAX,

    _SC_SCHAR_MAX,

    _SC_SCHAR_MIN,

    _SC_SHRT_MAX,

    _SC_SHRT_MIN,

    _SC_UCHAR_MAX,

    _SC_UINT_MAX,

    _SC_ULONG_MAX,

    _SC_USHRT_MAX,


    _SC_NL_ARGMAX,

    _SC_NL_LANGMAX,

    _SC_NL_MSGMAX,

    _SC_NL_NMAX,

    _SC_NL_SETMAX,

    _SC_NL_TEXTMAX,


    _SC_XBS5_ILP32_OFF32,

    _SC_XBS5_ILP32_OFFBIG,

    _SC_XBS5_LP64_OFF64,

    _SC_XBS5_LPBIG_OFFBIG,


    _SC_XOPEN_LEGACY,

    _SC_XOPEN_REALTIME,

    _SC_XOPEN_REALTIME_THREADS,


    _SC_ADVISORY_INFO,

    _SC_BARRIERS,

    _SC_BASE,

    _SC_C_LANG_SUPPORT,

    _SC_C_LANG_SUPPORT_R,

    _SC_CLOCK_SELECTION,

    _SC_CPUTIME,

    _SC_THREAD_CPUTIME,

    _SC_DEVICE_IO,

    _SC_DEVICE_SPECIFIC,

    _SC_DEVICE_SPECIFIC_R,

    _SC_FD_MGMT,

    _SC_FIFO,

    _SC_PIPE,

    _SC_FILE_ATTRIBUTES,

    _SC_FILE_LOCKING,

    _SC_FILE_SYSTEM,

    _SC_MONOTONIC_CLOCK,

    _SC_MULTI_PROCESS,

    _SC_SINGLE_PROCESS,

    _SC_NETWORKING,

    _SC_READER_WRITER_LOCKS,

    _SC_SPIN_LOCKS,

    _SC_REGEXP,

    _SC_REGEX_VERSION,

    _SC_SHELL,

    _SC_SIGNALS,

    _SC_SPAWN,

    _SC_SPORADIC_SERVER,

    _SC_THREAD_SPORADIC_SERVER,

    _SC_SYSTEM_DATABASE,

    _SC_SYSTEM_DATABASE_R,

    _SC_TIMEOUTS,

    _SC_TYPED_MEMORY_OBJECTS,

    _SC_USER_GROUPS,

    _SC_USER_GROUPS_R,

    _SC_2_PBS,

    _SC_2_PBS_ACCOUNTING,

    _SC_2_PBS_LOCATE,

    _SC_2_PBS_MESSAGE,

    _SC_2_PBS_TRACK,

    _SC_SYMLOOP_MAX,

    _SC_STREAMS,

    _SC_2_PBS_CHECKPOINT,


    _SC_V6_ILP32_OFF32,

    _SC_V6_ILP32_OFFBIG,

    _SC_V6_LP64_OFF64,

    _SC_V6_LPBIG_OFFBIG,


    _SC_HOST_NAME_MAX,

    _SC_TRACE,

    _SC_TRACE_EVENT_FILTER,

    _SC_TRACE_INHERIT,

    _SC_TRACE_LOG,


    _SC_LEVEL1_ICACHE_SIZE,

    _SC_LEVEL1_ICACHE_ASSOC,

    _SC_LEVEL1_ICACHE_LINESIZE,

    _SC_LEVEL1_DCACHE_SIZE,

    _SC_LEVEL1_DCACHE_ASSOC,

    _SC_LEVEL1_DCACHE_LINESIZE,

    _SC_LEVEL2_CACHE_SIZE,

    _SC_LEVEL2_CACHE_ASSOC,

    _SC_LEVEL2_CACHE_LINESIZE,

    _SC_LEVEL3_CACHE_SIZE,

    _SC_LEVEL3_CACHE_ASSOC,

    _SC_LEVEL3_CACHE_LINESIZE,

    _SC_LEVEL4_CACHE_SIZE,

    _SC_LEVEL4_CACHE_ASSOC,

    _SC_LEVEL4_CACHE_LINESIZE,



    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,

    _SC_RAW_SOCKETS,


    _SC_V7_ILP32_OFF32,

    _SC_V7_ILP32_OFFBIG,

    _SC_V7_LP64_OFF64,

    _SC_V7_LPBIG_OFFBIG,


    _SC_SS_REPL_MAX,


    _SC_TRACE_EVENT_NAME_MAX,

    _SC_TRACE_NAME_MAX,

    _SC_TRACE_SYS_MAX,

    _SC_TRACE_USER_EVENT_MAX,


    _SC_XOPEN_STREAMS,


    _SC_THREAD_ROBUST_PRIO_INHERIT,

    _SC_THREAD_ROBUST_PRIO_PROTECT

  };


enum
  {
    _CS_PATH,


    _CS_V6_WIDTH_RESTRICTED_ENVS,



    _CS_GNU_LIBC_VERSION,

    _CS_GNU_LIBPTHREAD_VERSION,


    _CS_V5_WIDTH_RESTRICTED_ENVS,



    _CS_V7_WIDTH_RESTRICTED_ENVS,



    _CS_LFS_CFLAGS = 1000,

    _CS_LFS_LDFLAGS,

    _CS_LFS_LIBS,

    _CS_LFS_LINTFLAGS,

    _CS_LFS64_CFLAGS,

    _CS_LFS64_LDFLAGS,

    _CS_LFS64_LIBS,

    _CS_LFS64_LINTFLAGS,


    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,

    _CS_XBS5_ILP32_OFF32_LDFLAGS,

    _CS_XBS5_ILP32_OFF32_LIBS,

    _CS_XBS5_ILP32_OFF32_LINTFLAGS,

    _CS_XBS5_ILP32_OFFBIG_CFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LIBS,

    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,

    _CS_XBS5_LP64_OFF64_CFLAGS,

    _CS_XBS5_LP64_OFF64_LDFLAGS,

    _CS_XBS5_LP64_OFF64_LIBS,

    _CS_XBS5_LP64_OFF64_LINTFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LIBS,

    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LIBS,

    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V6_LP64_OFF64_CFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LIBS,

    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V7_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LIBS,

    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V7_LP64_OFF64_CFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LIBS,

    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS,


    _CS_V6_ENV,

    _CS_V7_ENV

  };
# 613 "/usr/include/unistd.h" 2 3 4


extern long int pathconf (const char *__path, int __name)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int fpathconf (int __fd, int __name) __attribute__ ((__nothrow__ , __leaf__));


extern long int sysconf (int __name) __attribute__ ((__nothrow__ , __leaf__));



extern size_t confstr (int __name, char *__buf, size_t __len) __attribute__ ((__nothrow__ , __leaf__));




extern __pid_t getpid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __pid_t getppid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __pid_t getpgrp (void) __attribute__ ((__nothrow__ , __leaf__));


extern __pid_t __getpgid (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));

extern __pid_t getpgid (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));






extern int setpgid (__pid_t __pid, __pid_t __pgid) __attribute__ ((__nothrow__ , __leaf__));
# 663 "/usr/include/unistd.h" 3 4
extern int setpgrp (void) __attribute__ ((__nothrow__ , __leaf__));






extern __pid_t setsid (void) __attribute__ ((__nothrow__ , __leaf__));



extern __pid_t getsid (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));



extern __uid_t getuid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __uid_t geteuid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __gid_t getgid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __gid_t getegid (void) __attribute__ ((__nothrow__ , __leaf__));




extern int getgroups (int __size, __gid_t __list[]) __attribute__ ((__nothrow__ , __leaf__)) ;



extern int group_member (__gid_t __gid) __attribute__ ((__nothrow__ , __leaf__));






extern int setuid (__uid_t __uid) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int setreuid (__uid_t __ruid, __uid_t __euid) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int seteuid (__uid_t __uid) __attribute__ ((__nothrow__ , __leaf__)) ;






extern int setgid (__gid_t __gid) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int setregid (__gid_t __rgid, __gid_t __egid) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int setegid (__gid_t __gid) __attribute__ ((__nothrow__ , __leaf__)) ;





extern int getresuid (__uid_t *__ruid, __uid_t *__euid, __uid_t *__suid)
     __attribute__ ((__nothrow__ , __leaf__));



extern int getresgid (__gid_t *__rgid, __gid_t *__egid, __gid_t *__sgid)
     __attribute__ ((__nothrow__ , __leaf__));



extern int setresuid (__uid_t __ruid, __uid_t __euid, __uid_t __suid)
     __attribute__ ((__nothrow__ , __leaf__)) ;



extern int setresgid (__gid_t __rgid, __gid_t __egid, __gid_t __sgid)
     __attribute__ ((__nothrow__ , __leaf__)) ;






extern __pid_t fork (void) __attribute__ ((__nothrow__));







extern __pid_t vfork (void) __attribute__ ((__nothrow__ , __leaf__));





extern char *ttyname (int __fd) __attribute__ ((__nothrow__ , __leaf__));



extern int ttyname_r (int __fd, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;



extern int isatty (int __fd) __attribute__ ((__nothrow__ , __leaf__));




extern int ttyslot (void) __attribute__ ((__nothrow__ , __leaf__));




extern int link (const char *__from, const char *__to)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) ;




extern int linkat (int __fromfd, const char *__from, int __tofd,
     const char *__to, int __flags)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4))) ;




extern int symlink (const char *__from, const char *__to)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) ;




extern ssize_t readlink (const char *__restrict __path,
    char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) ;




extern int symlinkat (const char *__from, int __tofd,
        const char *__to) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3))) ;


extern ssize_t readlinkat (int __fd, const char *__restrict __path,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3))) ;



extern int unlink (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int unlinkat (int __fd, const char *__name, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern int rmdir (const char *__path) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern __pid_t tcgetpgrp (int __fd) __attribute__ ((__nothrow__ , __leaf__));


extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) __attribute__ ((__nothrow__ , __leaf__));






extern char *getlogin (void);







extern int getlogin_r (char *__name, size_t __name_len) __attribute__ ((__nonnull__ (1)));




extern int setlogin (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







# 1 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 3 4








extern char *optarg;
# 50 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 3 4
extern int optind;




extern int opterr;



extern int optopt;
# 91 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 3 4
extern int getopt (int ___argc, char *const *___argv, const char *__shortopts)
       __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));


# 28 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 2 3 4


# 49 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 3 4

# 873 "/usr/include/unistd.h" 2 3 4







extern int gethostname (char *__name, size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int sethostname (const char *__name, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



extern int sethostid (long int __id) __attribute__ ((__nothrow__ , __leaf__)) ;





extern int getdomainname (char *__name, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
extern int setdomainname (const char *__name, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;





extern int vhangup (void) __attribute__ ((__nothrow__ , __leaf__));


extern int revoke (const char *__file) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;







extern int profil (unsigned short int *__sample_buffer, size_t __size,
     size_t __offset, unsigned int __scale)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int acct (const char *__name) __attribute__ ((__nothrow__ , __leaf__));



extern char *getusershell (void) __attribute__ ((__nothrow__ , __leaf__));
extern void endusershell (void) __attribute__ ((__nothrow__ , __leaf__));
extern void setusershell (void) __attribute__ ((__nothrow__ , __leaf__));





extern int daemon (int __nochdir, int __noclose) __attribute__ ((__nothrow__ , __leaf__)) ;






extern int chroot (const char *__path) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



extern char *getpass (const char *__prompt) __attribute__ ((__nonnull__ (1)));







extern int fsync (int __fd);





extern int syncfs (int __fd) __attribute__ ((__nothrow__ , __leaf__));






extern long int gethostid (void);


extern void sync (void) __attribute__ ((__nothrow__ , __leaf__));





extern int getpagesize (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern int getdtablesize (void) __attribute__ ((__nothrow__ , __leaf__));
# 994 "/usr/include/unistd.h" 3 4
extern int truncate (const char *__file, __off_t __length)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 1006 "/usr/include/unistd.h" 3 4
extern int truncate64 (const char *__file, __off64_t __length)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 1017 "/usr/include/unistd.h" 3 4
extern int ftruncate (int __fd, __off_t __length) __attribute__ ((__nothrow__ , __leaf__)) ;
# 1027 "/usr/include/unistd.h" 3 4
extern int ftruncate64 (int __fd, __off64_t __length) __attribute__ ((__nothrow__ , __leaf__)) ;
# 1038 "/usr/include/unistd.h" 3 4
extern int brk (void *__addr) __attribute__ ((__nothrow__ , __leaf__)) ;





extern void *sbrk (intptr_t __delta) __attribute__ ((__nothrow__ , __leaf__));
# 1059 "/usr/include/unistd.h" 3 4
extern long int syscall (long int __sysno, ...) __attribute__ ((__nothrow__ , __leaf__));
# 1082 "/usr/include/unistd.h" 3 4
extern int lockf (int __fd, int __cmd, __off_t __len) ;
# 1092 "/usr/include/unistd.h" 3 4
extern int lockf64 (int __fd, int __cmd, __off64_t __len) ;
# 1110 "/usr/include/unistd.h" 3 4
ssize_t copy_file_range (int __infd, __off64_t *__pinoff,
    int __outfd, __off64_t *__poutoff,
    size_t __length, unsigned int __flags);





extern int fdatasync (int __fildes);







extern char *crypt (const char *__key, const char *__salt)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern void encrypt (char *__glibc_block, int __edflag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern void swab (const void *__restrict __from, void *__restrict __to,
    ssize_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
# 1167 "/usr/include/unistd.h" 3 4
int getentropy (void *__buffer, size_t __length) ;








# 5 "/home/toto/.env/encours/neovim/src/nvim/os/unix_defs.h" 2
# 1 "/usr/include/x86_64-linux-gnu/sys/param.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/sys/param.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/sys/param.h" 2 3 4


# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include-fixed/limits.h" 1 3 4
# 34 "/usr/lib/gcc/x86_64-linux-gnu/7/include-fixed/limits.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include-fixed/syslimits.h" 1 3 4






# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include-fixed/limits.h" 1 3 4
# 194 "/usr/lib/gcc/x86_64-linux-gnu/7/include-fixed/limits.h" 3 4
# 1 "/usr/include/limits.h" 1 3 4
# 26 "/usr/include/limits.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/limits.h" 2 3 4
# 183 "/usr/include/limits.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 1 3 4
# 160 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 1 3 4
# 38 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 3 4
# 1 "/usr/include/linux/limits.h" 1 3 4
# 39 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 2 3 4
# 161 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 2 3 4
# 184 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/posix2_lim.h" 1 3 4
# 188 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 1 3 4
# 64 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/uio_lim.h" 1 3 4
# 65 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 2 3 4
# 192 "/usr/include/limits.h" 2 3 4
# 195 "/usr/lib/gcc/x86_64-linux-gnu/7/include-fixed/limits.h" 2 3 4
# 8 "/usr/lib/gcc/x86_64-linux-gnu/7/include-fixed/syslimits.h" 2 3 4
# 35 "/usr/lib/gcc/x86_64-linux-gnu/7/include-fixed/limits.h" 2 3 4
# 27 "/usr/include/x86_64-linux-gnu/sys/param.h" 2 3 4

# 1 "/usr/include/signal.h" 1 3 4
# 27 "/usr/include/signal.h" 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/signum.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/signum.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/signum-generic.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/signum.h" 2 3 4
# 31 "/usr/include/signal.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/sig_atomic_t.h" 1 3 4







typedef __sig_atomic_t sig_atomic_t;
# 33 "/usr/include/signal.h" 2 3 4
# 57 "/usr/include/signal.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h" 1 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 5 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/__sigval_t.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/types/__sigval_t.h" 3 4
union sigval
{
  int sival_int;
  void *sival_ptr;
};

typedef union sigval __sigval_t;
# 7 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h" 2 3 4
# 16 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/siginfo-arch.h" 1 3 4
# 17 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h" 2 3 4
# 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h" 3 4
typedef struct
  {
    int si_signo;

    int si_errno;

    int si_code;





    int __pad0;


    union
      {
 int _pad[((128 / sizeof (int)) - 4)];


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
   } _kill;


 struct
   {
     int si_tid;
     int si_overrun;
     __sigval_t si_sigval;
   } _timer;


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
     __sigval_t si_sigval;
   } _rt;


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
     int si_status;
     __clock_t si_utime;
     __clock_t si_stime;
   } _sigchld;


 struct
   {
     void *si_addr;
    
     short int si_addr_lsb;
     union
       {

  struct
    {
      void *_lower;
      void *_upper;
    } _addr_bnd;

  __uint32_t _pkey;
       } _bounds;
   } _sigfault;


 struct
   {
     long int si_band;
     int si_fd;
   } _sigpoll;



 struct
   {
     void *_call_addr;
     int _syscall;
     unsigned int _arch;
   } _sigsys;

      } _sifields;
  } siginfo_t ;
# 58 "/usr/include/signal.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h" 3 4
enum
{
  SI_ASYNCNL = -60,
  SI_TKILL = -6,
  SI_SIGIO,

  SI_ASYNCIO,
  SI_MESGQ,
  SI_TIMER,





  SI_QUEUE,
  SI_USER,
  SI_KERNEL = 0x80
# 63 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h" 3 4
};




enum
{
  ILL_ILLOPC = 1,

  ILL_ILLOPN,

  ILL_ILLADR,

  ILL_ILLTRP,

  ILL_PRVOPC,

  ILL_PRVREG,

  ILL_COPROC,

  ILL_BADSTK

};


enum
{
  FPE_INTDIV = 1,

  FPE_INTOVF,

  FPE_FLTDIV,

  FPE_FLTOVF,

  FPE_FLTUND,

  FPE_FLTRES,

  FPE_FLTINV,

  FPE_FLTSUB

};


enum
{
  SEGV_MAPERR = 1,

  SEGV_ACCERR,

  SEGV_BNDERR,

  SEGV_PKUERR

};


enum
{
  BUS_ADRALN = 1,

  BUS_ADRERR,

  BUS_OBJERR,

  BUS_MCEERR_AR,

  BUS_MCEERR_AO

};




enum
{
  TRAP_BRKPT = 1,

  TRAP_TRACE

};




enum
{
  CLD_EXITED = 1,

  CLD_KILLED,

  CLD_DUMPED,

  CLD_TRAPPED,

  CLD_STOPPED,

  CLD_CONTINUED

};


enum
{
  POLL_IN = 1,

  POLL_OUT,

  POLL_MSG,

  POLL_ERR,

  POLL_PRI,

  POLL_HUP

};





# 1 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts-arch.h" 1 3 4
# 189 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h" 2 3 4
# 59 "/usr/include/signal.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/sigval_t.h" 1 3 4
# 16 "/usr/include/x86_64-linux-gnu/bits/types/sigval_t.h" 3 4
typedef __sigval_t sigval_t;
# 63 "/usr/include/signal.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h" 1 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 5 "/usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h" 2 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h" 3 4
typedef struct sigevent
  {
    __sigval_t sigev_value;
    int sigev_signo;
    int sigev_notify;

    union
      {
 int _pad[((64 / sizeof (int)) - 4)];



 __pid_t _tid;

 struct
   {
     void (*_function) (__sigval_t);
     pthread_attr_t *_attribute;
   } _sigev_thread;
      } _sigev_un;
  } sigevent_t;
# 67 "/usr/include/signal.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h" 3 4
enum
{
  SIGEV_SIGNAL = 0,

  SIGEV_NONE,

  SIGEV_THREAD,


  SIGEV_THREAD_ID = 4


};
# 68 "/usr/include/signal.h" 2 3 4




typedef void (*__sighandler_t) (int);




extern __sighandler_t __sysv_signal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__ , __leaf__));

extern __sighandler_t sysv_signal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__ , __leaf__));






extern __sighandler_t signal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__ , __leaf__));
# 112 "/usr/include/signal.h" 3 4
extern int kill (__pid_t __pid, int __sig) __attribute__ ((__nothrow__ , __leaf__));






extern int killpg (__pid_t __pgrp, int __sig) __attribute__ ((__nothrow__ , __leaf__));



extern int raise (int __sig) __attribute__ ((__nothrow__ , __leaf__));



extern __sighandler_t ssignal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__ , __leaf__));
extern int gsignal (int __sig) __attribute__ ((__nothrow__ , __leaf__));




extern void psignal (int __sig, const char *__s);


extern void psiginfo (const siginfo_t *__pinfo, const char *__s);
# 151 "/usr/include/signal.h" 3 4
extern int sigpause (int __sig) __asm__ ("__xpg_sigpause");
# 170 "/usr/include/signal.h" 3 4
extern int sigblock (int __mask) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));


extern int sigsetmask (int __mask) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));


extern int siggetmask (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));
# 185 "/usr/include/signal.h" 3 4
typedef __sighandler_t sighandler_t;




typedef __sighandler_t sig_t;





extern int sigemptyset (sigset_t *__set) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int sigfillset (sigset_t *__set) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int sigaddset (sigset_t *__set, int __signo) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int sigdelset (sigset_t *__set, int __signo) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int sigismember (const sigset_t *__set, int __signo)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int sigisemptyset (const sigset_t *__set) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int sigandset (sigset_t *__set, const sigset_t *__left,
        const sigset_t *__right) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2, 3)));


extern int sigorset (sigset_t *__set, const sigset_t *__left,
       const sigset_t *__right) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2, 3)));




# 1 "/usr/include/x86_64-linux-gnu/bits/sigaction.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h" 3 4
struct sigaction
  {


    union
      {

 __sighandler_t sa_handler;

 void (*sa_sigaction) (int, siginfo_t *, void *);
      }
    __sigaction_handler;







    __sigset_t sa_mask;


    int sa_flags;


    void (*sa_restorer) (void);
  };
# 227 "/usr/include/signal.h" 2 3 4


extern int sigprocmask (int __how, const sigset_t *__restrict __set,
   sigset_t *__restrict __oset) __attribute__ ((__nothrow__ , __leaf__));






extern int sigsuspend (const sigset_t *__set) __attribute__ ((__nonnull__ (1)));


extern int sigaction (int __sig, const struct sigaction *__restrict __act,
        struct sigaction *__restrict __oact) __attribute__ ((__nothrow__ , __leaf__));


extern int sigpending (sigset_t *__set) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







extern int sigwait (const sigset_t *__restrict __set, int *__restrict __sig)
     __attribute__ ((__nonnull__ (1, 2)));







extern int sigwaitinfo (const sigset_t *__restrict __set,
   siginfo_t *__restrict __info) __attribute__ ((__nonnull__ (1)));






extern int sigtimedwait (const sigset_t *__restrict __set,
    siginfo_t *__restrict __info,
    const struct timespec *__restrict __timeout)
     __attribute__ ((__nonnull__ (1)));



extern int sigqueue (__pid_t __pid, int __sig, const union sigval __val)
     __attribute__ ((__nothrow__ , __leaf__));
# 286 "/usr/include/signal.h" 3 4
extern const char *const _sys_siglist[(64 + 1)];
extern const char *const sys_siglist[(64 + 1)];



# 1 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h" 1 3 4
# 31 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h" 3 4
struct _fpx_sw_bytes
{
  __uint32_t magic1;
  __uint32_t extended_size;
  __uint64_t xstate_bv;
  __uint32_t xstate_size;
  __uint32_t __glibc_reserved1[7];
};

struct _fpreg
{
  unsigned short significand[4];
  unsigned short exponent;
};

struct _fpxreg
{
  unsigned short significand[4];
  unsigned short exponent;
  unsigned short __glibc_reserved1[3];
};

struct _xmmreg
{
  __uint32_t element[4];
};
# 123 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h" 3 4
struct _fpstate
{

  __uint16_t cwd;
  __uint16_t swd;
  __uint16_t ftw;
  __uint16_t fop;
  __uint64_t rip;
  __uint64_t rdp;
  __uint32_t mxcsr;
  __uint32_t mxcr_mask;
  struct _fpxreg _st[8];
  struct _xmmreg _xmm[16];
  __uint32_t __glibc_reserved1[24];
};

struct sigcontext
{
  __uint64_t r8;
  __uint64_t r9;
  __uint64_t r10;
  __uint64_t r11;
  __uint64_t r12;
  __uint64_t r13;
  __uint64_t r14;
  __uint64_t r15;
  __uint64_t rdi;
  __uint64_t rsi;
  __uint64_t rbp;
  __uint64_t rbx;
  __uint64_t rdx;
  __uint64_t rax;
  __uint64_t rcx;
  __uint64_t rsp;
  __uint64_t rip;
  __uint64_t eflags;
  unsigned short cs;
  unsigned short gs;
  unsigned short fs;
  unsigned short __pad0;
  __uint64_t err;
  __uint64_t trapno;
  __uint64_t oldmask;
  __uint64_t cr2;
  __extension__ union
    {
      struct _fpstate * fpstate;
      __uint64_t __fpstate_word;
    };
  __uint64_t __reserved1 [8];
};



struct _xsave_hdr
{
  __uint64_t xstate_bv;
  __uint64_t __glibc_reserved1[2];
  __uint64_t __glibc_reserved2[5];
};

struct _ymmh_state
{
  __uint32_t ymmh_space[64];
};

struct _xstate
{
  struct _fpstate fpstate;
  struct _xsave_hdr xstate_hdr;
  struct _ymmh_state ymmh;
};
# 292 "/usr/include/signal.h" 2 3 4


extern int sigreturn (struct sigcontext *__scp) __attribute__ ((__nothrow__ , __leaf__));






# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 302 "/usr/include/signal.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/stack_t.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/types/stack_t.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/types/stack_t.h" 2 3 4


typedef struct
  {
    void *ss_sp;
    int ss_flags;
    size_t ss_size;
  } stack_t;
# 304 "/usr/include/signal.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/sys/ucontext.h" 1 3 4
# 37 "/usr/include/x86_64-linux-gnu/sys/ucontext.h" 3 4
__extension__ typedef long long int greg_t;
# 46 "/usr/include/x86_64-linux-gnu/sys/ucontext.h" 3 4
typedef greg_t gregset_t[23];



enum
{
  REG_R8 = 0,

  REG_R9,

  REG_R10,

  REG_R11,

  REG_R12,

  REG_R13,

  REG_R14,

  REG_R15,

  REG_RDI,

  REG_RSI,

  REG_RBP,

  REG_RBX,

  REG_RDX,

  REG_RAX,

  REG_RCX,

  REG_RSP,

  REG_RIP,

  REG_EFL,

  REG_CSGSFS,

  REG_ERR,

  REG_TRAPNO,

  REG_OLDMASK,

  REG_CR2

};


struct _libc_fpxreg
{
  unsigned short int significand[4];
  unsigned short int exponent;
  unsigned short int __glibc_reserved1[3];
};

struct _libc_xmmreg
{
  __uint32_t element[4];
};

struct _libc_fpstate
{

  __uint16_t cwd;
  __uint16_t swd;
  __uint16_t ftw;
  __uint16_t fop;
  __uint64_t rip;
  __uint64_t rdp;
  __uint32_t mxcsr;
  __uint32_t mxcr_mask;
  struct _libc_fpxreg _st[8];
  struct _libc_xmmreg _xmm[16];
  __uint32_t __glibc_reserved1[24];
};


typedef struct _libc_fpstate *fpregset_t;


typedef struct
  {
    gregset_t gregs;

    fpregset_t fpregs;
    __extension__ unsigned long long __reserved1 [8];
} mcontext_t;


typedef struct ucontext_t
  {
    unsigned long int uc_flags;
    struct ucontext_t *uc_link;
    stack_t uc_stack;
    mcontext_t uc_mcontext;
    sigset_t uc_sigmask;
    struct _libc_fpstate __fpregs_mem;
  } ucontext_t;
# 307 "/usr/include/signal.h" 2 3 4







extern int siginterrupt (int __sig, int __interrupt) __attribute__ ((__nothrow__ , __leaf__));

# 1 "/usr/include/x86_64-linux-gnu/bits/sigstack.h" 1 3 4
# 317 "/usr/include/signal.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h" 3 4
enum
{
  SS_ONSTACK = 1,

  SS_DISABLE

};
# 318 "/usr/include/signal.h" 2 3 4



extern int sigaltstack (const stack_t *__restrict __ss,
   stack_t *__restrict __oss) __attribute__ ((__nothrow__ , __leaf__));




# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_sigstack.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/types/struct_sigstack.h" 3 4
struct sigstack
  {
    void *ss_sp;
    int ss_onstack;
  };
# 328 "/usr/include/signal.h" 2 3 4







extern int sigstack (struct sigstack *__ss, struct sigstack *__oss)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));






extern int sighold (int __sig) __attribute__ ((__nothrow__ , __leaf__));


extern int sigrelse (int __sig) __attribute__ ((__nothrow__ , __leaf__));


extern int sigignore (int __sig) __attribute__ ((__nothrow__ , __leaf__));


extern __sighandler_t sigset (int __sig, __sighandler_t __disp) __attribute__ ((__nothrow__ , __leaf__));






# 1 "/usr/include/x86_64-linux-gnu/bits/sigthread.h" 1 3 4
# 31 "/usr/include/x86_64-linux-gnu/bits/sigthread.h" 3 4
extern int pthread_sigmask (int __how,
       const __sigset_t *__restrict __newmask,
       __sigset_t *__restrict __oldmask)__attribute__ ((__nothrow__ , __leaf__));


extern int pthread_kill (pthread_t __threadid, int __signo) __attribute__ ((__nothrow__ , __leaf__));



extern int pthread_sigqueue (pthread_t __threadid, int __signo,
        const union sigval __value) __attribute__ ((__nothrow__ , __leaf__));
# 360 "/usr/include/signal.h" 2 3 4






extern int __libc_current_sigrtmin (void) __attribute__ ((__nothrow__ , __leaf__));

extern int __libc_current_sigrtmax (void) __attribute__ ((__nothrow__ , __leaf__));





# 29 "/usr/include/x86_64-linux-gnu/sys/param.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/param.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/param.h" 3 4
# 1 "/usr/include/linux/param.h" 1 3 4




# 1 "/usr/include/x86_64-linux-gnu/asm/param.h" 1 3 4
# 1 "/usr/include/asm-generic/param.h" 1 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/param.h" 2 3 4
# 6 "/usr/include/linux/param.h" 2 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/param.h" 2 3 4
# 32 "/usr/include/x86_64-linux-gnu/sys/param.h" 2 3 4
# 6 "/home/toto/.env/encours/neovim/src/nvim/os/unix_defs.h" 2


# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include-fixed/limits.h" 1 3 4
# 9 "/home/toto/.env/encours/neovim/src/nvim/os/unix_defs.h" 2
# 14 "/home/toto/.env/encours/neovim/src/nvim/os/os_defs.h" 2
# 25 "/home/toto/.env/encours/neovim/src/nvim/vim.h" 2



# 27 "/home/toto/.env/encours/neovim/src/nvim/vim.h"
enum { NUMBUFLEN = 65 };





# 1 "/home/toto/.env/encours/neovim/src/nvim/keymap.h" 1



# 1 "/home/toto/.env/encours/neovim/src/nvim/strings.h" 1




# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stdarg.h" 1 3 4
# 6 "/home/toto/.env/encours/neovim/src/nvim/strings.h" 2



# 1 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h" 1




# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 149 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4

# 149 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 426 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4
typedef struct {
  long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
  long double __max_align_ld __attribute__((__aligned__(__alignof__(long double))));
# 437 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4
} max_align_t;
# 6 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h" 2


# 1 "/usr/include/assert.h" 1 3 4
# 9 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h" 2


# 1 "/home/toto/.env/encours/neovim/src/nvim/hashtab.h" 1



# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 5 "/home/toto/.env/encours/neovim/src/nvim/hashtab.h" 2







# 11 "/home/toto/.env/encours/neovim/src/nvim/hashtab.h"
extern char hash_removed;


typedef size_t hash_T;
# 38 "/home/toto/.env/encours/neovim/src/nvim/hashtab.h"
typedef struct hashitem_S {

  hash_T hi_hash;







  char_u *hi_key;
} hashitem_T;
# 62 "/home/toto/.env/encours/neovim/src/nvim/hashtab.h"
typedef struct hashtable_S {
  hash_T ht_mask;

  size_t ht_used;
  size_t ht_filled;
  int ht_locked;
  hashitem_T *ht_array;

  hashitem_T ht_smallarray[16];
} hashtab_T;
# 12 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h" 2
# 1 "/home/toto/.env/encours/neovim/src/nvim/garray.h" 1



# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 5 "/home/toto/.env/encours/neovim/src/nvim/garray.h" 2







typedef struct growarray {
  int ga_len;
  int ga_maxlen;
  int ga_itemsize;
  int ga_growsize;
  void *ga_data;
} garray_T;
# 38 "/home/toto/.env/encours/neovim/src/nvim/garray.h"
static inline void *ga_append_via_ptr(garray_T *gap, size_t item_size)
{
  if ((int)item_size != gap->ga_itemsize) {
    logmsg(2, 
# 41 "/home/toto/.env/encours/neovim/src/nvim/garray.h" 3 4
   ((void *)0)
# 41 "/home/toto/.env/encours/neovim/src/nvim/garray.h"
   , __func__, 41, 
# 41 "/home/toto/.env/encours/neovim/src/nvim/garray.h" 3 4
   1
# 41 "/home/toto/.env/encours/neovim/src/nvim/garray.h"
   , "wrong item size (%zu), should be %d", item_size, gap->ga_itemsize);
  }
  ga_grow(gap, 1);
  return ((char *)gap->ga_data) + (item_size * (size_t)gap->ga_len++);
}
# 13 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h" 2
# 1 "/home/toto/.env/encours/neovim/src/nvim/mbyte.h" 1







# 1 "/home/toto/.env/encours/neovim/src/nvim/iconv.h" 1






# 1 "/usr/include/errno.h" 1 3 4
# 28 "/usr/include/errno.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/errno.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/errno.h" 3 4
# 1 "/usr/include/linux/errno.h" 1 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/errno.h" 1 3 4
# 1 "/usr/include/asm-generic/errno.h" 1 3 4




# 1 "/usr/include/asm-generic/errno-base.h" 1 3 4
# 6 "/usr/include/asm-generic/errno.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/errno.h" 2 3 4
# 1 "/usr/include/linux/errno.h" 2 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/errno.h" 2 3 4
# 29 "/usr/include/errno.h" 2 3 4









# 37 "/usr/include/errno.h" 3 4
extern int *__errno_location (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));







extern char *program_invocation_name;
extern char *program_invocation_short_name;





typedef int error_t;





# 8 "/home/toto/.env/encours/neovim/src/nvim/iconv.h" 2
# 1 "/usr/include/iconv.h" 1 3 4
# 23 "/usr/include/iconv.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 24 "/usr/include/iconv.h" 2 3 4





typedef void *iconv_t;







extern iconv_t iconv_open (const char *__tocode, const char *__fromcode);




extern size_t iconv (iconv_t __cd, char **__restrict __inbuf,
       size_t *__restrict __inbytesleft,
       char **__restrict __outbuf,
       size_t *__restrict __outbytesleft);





extern int iconv_close (iconv_t __cd);


# 9 "/home/toto/.env/encours/neovim/src/nvim/iconv.h" 2
# 9 "/home/toto/.env/encours/neovim/src/nvim/mbyte.h" 2
# 1 "/home/toto/.env/encours/neovim/src/nvim/func_attr.h" 1
# 44 "/home/toto/.env/encours/neovim/src/nvim/func_attr.h"
# 1 "/home/toto/.env/encours/neovim/src/nvim/macros.h" 1
# 45 "/home/toto/.env/encours/neovim/src/nvim/func_attr.h" 2
# 10 "/home/toto/.env/encours/neovim/src/nvim/mbyte.h" 2
# 47 "/home/toto/.env/encours/neovim/src/nvim/mbyte.h"

# 47 "/home/toto/.env/encours/neovim/src/nvim/mbyte.h"
typedef enum {
  CONV_NONE = 0,
  CONV_TO_UTF8 = 1,
  CONV_9_TO_UTF8 = 2,
  CONV_TO_LATIN1 = 3,
  CONV_TO_LATIN9 = 4,
  CONV_ICONV = 5,
} ConvFlags;
# 63 "/home/toto/.env/encours/neovim/src/nvim/mbyte.h"
typedef struct {
  int vc_type;
  int vc_factor;

  iconv_t vc_fd;

  
# 69 "/home/toto/.env/encours/neovim/src/nvim/mbyte.h" 3 4
 _Bool 
# 69 "/home/toto/.env/encours/neovim/src/nvim/mbyte.h"
      vc_fail;

} vimconv_T;

extern const uint8_t utf8len_tab_zero[256];

extern const uint8_t utf8len_tab[256];





static inline int mb_strcmp_ic(
# 81 "/home/toto/.env/encours/neovim/src/nvim/mbyte.h" 3 4
                              _Bool 
# 81 "/home/toto/.env/encours/neovim/src/nvim/mbyte.h"
                                   ic, const char *s1, const char *s2)
  __attribute__((nonnull)) __attribute__ ((pure)) __attribute__((warn_unused_result));






static inline int mb_strcmp_ic(
# 89 "/home/toto/.env/encours/neovim/src/nvim/mbyte.h" 3 4
                              _Bool 
# 89 "/home/toto/.env/encours/neovim/src/nvim/mbyte.h"
                                   ic, const char *s1, const char *s2)
{
  return (ic ? mb_stricmp(s1, s2) : strcmp(s1, s2));
}
# 14 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h" 2
# 1 "/home/toto/.env/encours/neovim/src/nvim/func_attr.h" 1
# 15 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h" 2
# 1 "/home/toto/.env/encours/neovim/src/nvim/lib/queue.h" 1
# 23 "/home/toto/.env/encours/neovim/src/nvim/lib/queue.h"
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 24 "/home/toto/.env/encours/neovim/src/nvim/lib/queue.h" 2

# 1 "/home/toto/.env/encours/neovim/src/nvim/func_attr.h" 1
# 26 "/home/toto/.env/encours/neovim/src/nvim/lib/queue.h" 2

typedef struct _queue {
  struct _queue *next;
  struct _queue *prev;
} QUEUE;
# 43 "/home/toto/.env/encours/neovim/src/nvim/lib/queue.h"
static inline int QUEUE_EMPTY(const QUEUE *const q)
  FUNC_ATTR_ALWAYS_INLINE FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT
{
  return q == q->next;
}



static inline void QUEUE_INIT(QUEUE *const q) FUNC_ATTR_ALWAYS_INLINE
{
  q->next = q;
  q->prev = q;
}

static inline void QUEUE_ADD(QUEUE *const h, QUEUE *const n)
  FUNC_ATTR_ALWAYS_INLINE
{
  h->prev->next = n->next;
  n->next->prev = h->prev;
  h->prev = n->prev;
  h->prev->next = h;
}

static inline void QUEUE_INSERT_HEAD(QUEUE *const h, QUEUE *const q)
  FUNC_ATTR_ALWAYS_INLINE
{
  q->next = h->next;
  q->prev = h;
  q->next->prev = q;
  h->next = q;
}

static inline void QUEUE_INSERT_TAIL(QUEUE *const h, QUEUE *const q)
  FUNC_ATTR_ALWAYS_INLINE
{
  q->next = h;
  q->prev = h->prev;
  q->prev->next = q;
  h->prev = q;
}

static inline void QUEUE_REMOVE(QUEUE *const q) FUNC_ATTR_ALWAYS_INLINE
{
  q->prev->next = q->next;
  q->next->prev = q->prev;
}
# 16 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h" 2
# 1 "/home/toto/.env/encours/neovim/src/nvim/profile.h" 1




# 1 "/usr/include/time.h" 1 3 4
# 29 "/usr/include/time.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 30 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/time.h" 1 3 4
# 73 "/usr/include/x86_64-linux-gnu/bits/time.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timex.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/timex.h" 3 4

# 26 "/usr/include/x86_64-linux-gnu/bits/timex.h" 3 4
struct timex
{
  unsigned int modes;
  __syscall_slong_t offset;
  __syscall_slong_t freq;
  __syscall_slong_t maxerror;
  __syscall_slong_t esterror;
  int status;
  __syscall_slong_t constant;
  __syscall_slong_t precision;
  __syscall_slong_t tolerance;
  struct timeval time;
  __syscall_slong_t tick;
  __syscall_slong_t ppsfreq;
  __syscall_slong_t jitter;
  int shift;
  __syscall_slong_t stabil;
  __syscall_slong_t jitcnt;
  __syscall_slong_t calcnt;
  __syscall_slong_t errcnt;
  __syscall_slong_t stbcnt;

  int tai;


  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32;
};
# 74 "/usr/include/x86_64-linux-gnu/bits/time.h" 2 3 4




extern int clock_adjtime (__clockid_t __clock_id, struct timex *__utx) __attribute__ ((__nothrow__ , __leaf__));


# 34 "/usr/include/time.h" 2 3 4





# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_tm.h" 1 3 4






struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  const char *tm_zone;




};
# 40 "/usr/include/time.h" 2 3 4
# 48 "/usr/include/time.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h" 1 3 4







struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };
# 49 "/usr/include/time.h" 2 3 4
struct sigevent;
# 68 "/usr/include/time.h" 3 4




extern clock_t clock (void) __attribute__ ((__nothrow__ , __leaf__));


extern time_t time (time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));


extern double difftime (time_t __time1, time_t __time0)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));





extern size_t strftime (char *__restrict __s, size_t __maxsize,
   const char *__restrict __format,
   const struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));




extern char *strptime (const char *__restrict __s,
         const char *__restrict __fmt, struct tm *__tp)
     __attribute__ ((__nothrow__ , __leaf__));






extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     const char *__restrict __format,
     const struct tm *__restrict __tp,
     locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));



extern char *strptime_l (const char *__restrict __s,
    const char *__restrict __fmt, struct tm *__tp,
    locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));





extern struct tm *gmtime (const time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));



extern struct tm *localtime (const time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));




extern struct tm *gmtime_r (const time_t *__restrict __timer,
       struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));



extern struct tm *localtime_r (const time_t *__restrict __timer,
          struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));




extern char *asctime (const struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));


extern char *ctime (const time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));






extern char *asctime_r (const struct tm *__restrict __tp,
   char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));


extern char *ctime_r (const time_t *__restrict __timer,
        char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));




extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) __attribute__ ((__nothrow__ , __leaf__));



extern int daylight;
extern long int timezone;





extern int stime (const time_t *__when) __attribute__ ((__nothrow__ , __leaf__));
# 196 "/usr/include/time.h" 3 4
extern time_t timegm (struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));


extern time_t timelocal (struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));


extern int dysize (int __year) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 211 "/usr/include/time.h" 3 4
extern int nanosleep (const struct timespec *__requested_time,
        struct timespec *__remaining);



extern int clock_getres (clockid_t __clock_id, struct timespec *__res) __attribute__ ((__nothrow__ , __leaf__));


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) __attribute__ ((__nothrow__ , __leaf__));


extern int clock_settime (clockid_t __clock_id, const struct timespec *__tp)
     __attribute__ ((__nothrow__ , __leaf__));






extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       const struct timespec *__req,
       struct timespec *__rem);


extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) __attribute__ ((__nothrow__ , __leaf__));




extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) __attribute__ ((__nothrow__ , __leaf__));


extern int timer_delete (timer_t __timerid) __attribute__ ((__nothrow__ , __leaf__));


extern int timer_settime (timer_t __timerid, int __flags,
     const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) __attribute__ ((__nothrow__ , __leaf__));


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     __attribute__ ((__nothrow__ , __leaf__));


extern int timer_getoverrun (timer_t __timerid) __attribute__ ((__nothrow__ , __leaf__));





extern int timespec_get (struct timespec *__ts, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 280 "/usr/include/time.h" 3 4
extern int getdate_err;
# 289 "/usr/include/time.h" 3 4
extern struct tm *getdate (const char *__string);
# 303 "/usr/include/time.h" 3 4
extern int getdate_r (const char *__restrict __string,
        struct tm *__restrict __resbufp);



# 6 "/home/toto/.env/encours/neovim/src/nvim/profile.h" 2


# 7 "/home/toto/.env/encours/neovim/src/nvim/profile.h"
typedef uint64_t proftime_T;
# 17 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h" 2

# 1 "/home/toto/.env/encours/neovim/src/nvim/gettext.h" 1




# 1 "/usr/include/libintl.h" 1 3 4
# 34 "/usr/include/libintl.h" 3 4






# 39 "/usr/include/libintl.h" 3 4
extern char *gettext (const char *__msgid)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (1)));



extern char *dgettext (const char *__domainname, const char *__msgid)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (2)));
extern char *__dgettext (const char *__domainname, const char *__msgid)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (2)));



extern char *dcgettext (const char *__domainname,
   const char *__msgid, int __category)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (2)));
extern char *__dcgettext (const char *__domainname,
     const char *__msgid, int __category)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (2)));




extern char *ngettext (const char *__msgid1, const char *__msgid2,
         unsigned long int __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (1))) __attribute__ ((__format_arg__ (2)));



extern char *dngettext (const char *__domainname, const char *__msgid1,
   const char *__msgid2, unsigned long int __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (2))) __attribute__ ((__format_arg__ (3)));



extern char *dcngettext (const char *__domainname, const char *__msgid1,
    const char *__msgid2, unsigned long int __n,
    int __category)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (2))) __attribute__ ((__format_arg__ (3)));





extern char *textdomain (const char *__domainname) __attribute__ ((__nothrow__ , __leaf__));



extern char *bindtextdomain (const char *__domainname,
        const char *__dirname) __attribute__ ((__nothrow__ , __leaf__));



extern char *bind_textdomain_codeset (const char *__domainname,
          const char *__codeset) __attribute__ ((__nothrow__ , __leaf__));
# 121 "/usr/include/libintl.h" 3 4

# 6 "/home/toto/.env/encours/neovim/src/nvim/gettext.h" 2
# 19 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h" 2
# 1 "/home/toto/.env/encours/neovim/src/nvim/message.h" 1





# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 7 "/home/toto/.env/encours/neovim/src/nvim/message.h" 2



# 1 "/home/toto/.env/encours/neovim/src/nvim/grid_defs.h" 1




# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 6 "/home/toto/.env/encours/neovim/src/nvim/grid_defs.h" 2








# 13 "/home/toto/.env/encours/neovim/src/nvim/grid_defs.h"
typedef char_u schar_T[(6 +1) * 4 + 1];
typedef int16_t sattr_T;
# 38 "/home/toto/.env/encours/neovim/src/nvim/grid_defs.h"
typedef struct {
  handle_T handle;

  schar_T *chars;
  sattr_T *attrs;
  unsigned *line_offset;
  char_u *line_wraps;



  int *dirty_col;


  int Rows;
  int Columns;


  
# 55 "/home/toto/.env/encours/neovim/src/nvim/grid_defs.h" 3 4
 _Bool 
# 55 "/home/toto/.env/encours/neovim/src/nvim/grid_defs.h"
      valid;



  
# 59 "/home/toto/.env/encours/neovim/src/nvim/grid_defs.h" 3 4
 _Bool 
# 59 "/home/toto/.env/encours/neovim/src/nvim/grid_defs.h"
      throttled;



  int row_offset;
  int col_offset;


  
# 67 "/home/toto/.env/encours/neovim/src/nvim/grid_defs.h" 3 4
 _Bool 
# 67 "/home/toto/.env/encours/neovim/src/nvim/grid_defs.h"
      blending;


  
# 70 "/home/toto/.env/encours/neovim/src/nvim/grid_defs.h" 3 4
 _Bool 
# 70 "/home/toto/.env/encours/neovim/src/nvim/grid_defs.h"
      focusable;





  int comp_row;
  int comp_col;



  size_t comp_index;



  
# 85 "/home/toto/.env/encours/neovim/src/nvim/grid_defs.h" 3 4
 _Bool 
# 85 "/home/toto/.env/encours/neovim/src/nvim/grid_defs.h"
      comp_disabled;
} ScreenGrid;
# 11 "/home/toto/.env/encours/neovim/src/nvim/message.h" 2
# 79 "/home/toto/.env/encours/neovim/src/nvim/message.h"
typedef struct msg_hist {
  struct msg_hist *next;
  char_u *msg;
  const char *kind;
  int attr;
  
# 84 "/home/toto/.env/encours/neovim/src/nvim/message.h" 3 4
 _Bool 
# 84 "/home/toto/.env/encours/neovim/src/nvim/message.h"
      multiline;
} MessageHistoryEntry;


extern MessageHistoryEntry *first_msg_hist;

extern MessageHistoryEntry *last_msg_hist;

extern 
# 92 "/home/toto/.env/encours/neovim/src/nvim/message.h" 3 4
      _Bool 
# 92 "/home/toto/.env/encours/neovim/src/nvim/message.h"
           msg_ext_need_clear ;



extern ScreenGrid msg_grid ;
extern int msg_grid_pos ;







extern ScreenGrid msg_grid_adj ;


extern int msg_scrolled_at_flush ;
# 20 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h" 2






typedef int64_t varnumber_T;
typedef uint64_t uvarnumber_T;


typedef double float_T;


enum { DO_NOT_FREE_CNT = (0x7fffffff / 2) };


enum ListLenSpecials {




  kListLenUnknown = -1,





  kListLenShouldKnow = -2,



  kListLenMayKnow = -3,
};
# 64 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h"
typedef struct listvar_S list_T;
typedef struct dictvar_S dict_T;
typedef struct partial_S partial_T;

typedef struct ufunc ufunc_T;

typedef enum {
  kCallbackNone = 0,
  kCallbackFuncref,
  kCallbackPartial,
} CallbackType;

typedef struct {
  union {
    char_u *funcref;
    partial_T *partial;
  } data;
  CallbackType type;
} Callback;



typedef struct dict_watcher {
  Callback callback;
  char *key_pattern;
  size_t key_pattern_len;
  QUEUE node;
  
# 91 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h" 3 4
 _Bool 
# 91 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h"
      busy;
} DictWatcher;


typedef enum {
  kSpecialVarFalse,
  kSpecialVarTrue,
  kSpecialVarNull,
} SpecialVarValue;


typedef enum {
  VAR_UNLOCKED = 0,
  VAR_LOCKED = 1,
  VAR_FIXED = 2,
} VarLockStatus;


typedef enum {
  VAR_UNKNOWN = 0,
  VAR_NUMBER,
  VAR_STRING,
  VAR_FUNC,
  VAR_LIST,
  VAR_DICT,
  VAR_FLOAT,
  VAR_SPECIAL,

  VAR_PARTIAL,
} VarType;


typedef struct {
  VarType v_type;
  VarLockStatus v_lock;
  union typval_vval_union {
    varnumber_T v_number;
    SpecialVarValue v_special;
    float_T v_float;
    char_u *v_string;
    list_T *v_list;
    dict_T *v_dict;
    partial_T *v_partial;
  } vval;
} typval_T;


typedef enum {
  VAR_NO_SCOPE = 0,
  VAR_SCOPE = 1,
  VAR_DEF_SCOPE = 2,

} ScopeType;


typedef struct listitem_S listitem_T;

struct listitem_S {
  listitem_T *li_next;
  listitem_T *li_prev;
  typval_T li_tv;
};


typedef struct listwatch_S listwatch_T;

struct listwatch_S {
  listitem_T *lw_item;
  listwatch_T *lw_next;
};



struct listvar_S {
  listitem_T *lv_first;
  listitem_T *lv_last;
  listwatch_T *lv_watch;
  listitem_T *lv_idx_item;
  list_T *lv_copylist;
  list_T *lv_used_next;
  list_T *lv_used_prev;
  int lv_refcount;
  int lv_len;
  int lv_idx;
  int lv_copyID;
  VarLockStatus lv_lock;
};


typedef struct {
  list_T sl_list;
  listitem_T sl_items[10];
} staticList10_T;
# 212 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h"
typedef struct { typval_T di_tv; uint8_t di_flags; char_u di_key[1]; } ScopeDictDictItem;






typedef struct { typval_T di_tv; uint8_t di_flags; char_u di_key[]; } dictitem_T;


typedef enum {
  DI_FLAGS_RO = 1,
  DI_FLAGS_RO_SBX = 2,
  DI_FLAGS_FIX = 4,
  DI_FLAGS_LOCK = 8,
  DI_FLAGS_ALLOC = 16,
} DictItemFlags;


struct dictvar_S {
  VarLockStatus dv_lock;
  ScopeType dv_scope;

  int dv_refcount;
  int dv_copyID;
  hashtab_T dv_hashtab;
  dict_T *dv_copydict;
  dict_T *dv_used_next;
  dict_T *dv_used_prev;
  QUEUE watchers;
};


typedef int scid_T;
# 255 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h"
typedef struct {
  scid_T sc_sid;
  int sc_seq;
  linenr_T sc_lnum;
} sctx_T;
# 269 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h"
typedef struct funccall_S funccall_T;

struct funccall_S {
  ufunc_T *func;
  int linenr;
  int returned;

  struct { typval_T di_tv; uint8_t di_flags; char_u di_key[20 + 1]; } fixvar[12];
  dict_T l_vars;
  ScopeDictDictItem l_vars_var;
  dict_T l_avars;
  ScopeDictDictItem l_avars_var;
  list_T l_varlist;
  listitem_T l_listitems[20];
  typval_T *rettv;
  linenr_T breakpoint;
  int dbg_tick;
  int level;
  proftime_T prof_child;
  funccall_T *caller;
  int fc_refcount;
  int fc_copyID;
  garray_T fc_funcs;
};


struct ufunc {
  int uf_varargs;
  int uf_flags;
  int uf_calls;
  
# 299 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h" 3 4
 _Bool 
# 299 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h"
              uf_cleared;
  garray_T uf_args;
  garray_T uf_lines;
  int uf_profiling;
  int uf_prof_initialized;

  int uf_tm_count;
  proftime_T uf_tm_total;
  proftime_T uf_tm_self;
  proftime_T uf_tm_children;

  int *uf_tml_count;
  proftime_T *uf_tml_total;
  proftime_T *uf_tml_self;
  proftime_T uf_tml_start;
  proftime_T uf_tml_children;
  proftime_T uf_tml_wait;
  int uf_tml_idx;
  int uf_tml_execed;
  sctx_T uf_script_ctx;

  int uf_refcount;
  funccall_T *uf_scoped;
  char_u uf_name[];

};

struct partial_S {
  int pt_refcount;
  char_u *pt_name;
  ufunc_T *pt_func;

  
# 331 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h" 3 4
 _Bool 
# 331 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h"
      pt_auto;

  int pt_argc;
  typval_T *pt_argv;
  dict_T *pt_dict;
};


typedef struct ht_stack_S {
  hashtab_T *ht;
  struct ht_stack_S *prev;
} ht_stack_T;


typedef struct list_stack_S {
  list_T *list;
  struct list_stack_S *prev;
} list_stack_T;


typedef struct {
  listitem_T *item;
  int idx;
} ListSortItem;

typedef int (*ListSorter)(const void *, const void *);
# 455 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h"
static inline void tv_list_ref(list_T *const l)
  __attribute__((always_inline));






static inline void tv_list_ref(list_T *const l)
{
  if (l == 
# 465 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h" 3 4
          ((void *)0)
# 465 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h"
              ) {
    return;
  }
  l->lv_refcount++;
}

static inline void tv_list_set_ret(typval_T *const tv, list_T *const l)
  __attribute__((always_inline)) __attribute__((nonnull(1)));





static inline void tv_list_set_ret(typval_T *const tv, list_T *const l)
{
  tv->v_type = VAR_LIST;
  tv->vval.v_list = l;
  tv_list_ref(l);
}

static inline VarLockStatus tv_list_locked(const list_T *const l)
  __attribute__ ((pure)) __attribute__((warn_unused_result));






static inline VarLockStatus tv_list_locked(const list_T *const l)
{
  if (l == 
# 495 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h" 3 4
          ((void *)0)
# 495 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h"
              ) {
    return VAR_FIXED;
  }
  return l->lv_lock;
}







static inline void tv_list_set_lock(list_T *const l,
                                    const VarLockStatus lock)
{
  if (l == 
# 510 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h" 3 4
          ((void *)0)
# 510 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h"
              ) {
    
# 511 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h" 3 4
   ((void) sizeof ((
# 511 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h"
   lock == VAR_FIXED
# 511 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 511 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h"
   lock == VAR_FIXED
# 511 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h" 3 4
   ) ; else __assert_fail (
# 511 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h"
   "lock == VAR_FIXED"
# 511 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h" 3 4
   , "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h", 511, __extension__ __PRETTY_FUNCTION__); }))
# 511 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h"
                            ;
    return;
  }
  l->lv_lock = lock;
}







static inline void tv_list_set_copyid(list_T *const l,
                                      const int copyid)
  FUNC_ATTR_NONNULL_ALL
{
  l->lv_copyID = copyid;
}

static inline int tv_list_len(const list_T *const l)
  __attribute__ ((pure)) __attribute__((warn_unused_result));




static inline int tv_list_len(const list_T *const l)
{
  ;
  if (l == 
# 539 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h" 3 4
          ((void *)0)
# 539 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h"
              ) {
    return 0;
  }
  return l->lv_len;
}

static inline int tv_list_copyid(const list_T *const l)
  __attribute__ ((pure)) __attribute__((warn_unused_result)) __attribute__((nonnull));






static inline int tv_list_copyid(const list_T *const l)
{
  return l->lv_copyID;
}

static inline list_T *tv_list_latest_copy(const list_T *const l)
  __attribute__ ((pure)) __attribute__((warn_unused_result)) __attribute__((nonnull));
# 568 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h"
static inline list_T *tv_list_latest_copy(const list_T *const l)
{
  return l->lv_copylist;
}

static inline int tv_list_uidx(const list_T *const l, int n)
  __attribute__ ((pure)) __attribute__((warn_unused_result));







static inline int tv_list_uidx(const list_T *const l, int n)
{

  if (n < 0) {
    n += tv_list_len(l);
  }


  if (n < 0 || n >= tv_list_len(l)) {
    return -1;
  }
  return n;
}

static inline 
# 596 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h" 3 4
             _Bool 
# 596 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h"
                  tv_list_has_watchers(const list_T *const l)
  __attribute__ ((pure)) __attribute__((warn_unused_result));
# 606 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h"
static inline 
# 606 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h" 3 4
             _Bool 
# 606 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h"
                  tv_list_has_watchers(const list_T *const l)
{
  return l && l->lv_watch;
}

static inline listitem_T *tv_list_first(const list_T *const l)
  __attribute__ ((pure)) __attribute__((warn_unused_result));






static inline listitem_T *tv_list_first(const list_T *const l)
{
  if (l == 
# 621 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h" 3 4
          ((void *)0)
# 621 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h"
              ) {
    ;
    return 
# 623 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h" 3 4
          ((void *)0)
# 623 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h"
              ;
  }
  ;
  return l->lv_first;
}

static inline listitem_T *tv_list_last(const list_T *const l)
  __attribute__ ((pure)) __attribute__((warn_unused_result));






static inline listitem_T *tv_list_last(const list_T *const l)
{
  if (l == 
# 639 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h" 3 4
          ((void *)0)
# 639 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h"
              ) {
    ;
    return 
# 641 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h" 3 4
          ((void *)0)
# 641 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h"
              ;
  }
  ;
  return l->lv_last;
}

static inline void tv_dict_set_ret(typval_T *const tv, dict_T *const d)
  __attribute__((always_inline)) __attribute__((nonnull(1)));





static inline void tv_dict_set_ret(typval_T *const tv, dict_T *const d)
{
  tv->v_type = VAR_DICT;
  tv->vval.v_dict = d;
  if (d != 
# 658 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h" 3 4
          ((void *)0)
# 658 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h"
              ) {
    d->dv_refcount++;
  }
}

static inline long tv_dict_len(const dict_T *const d)
  __attribute__ ((pure)) __attribute__((warn_unused_result));




static inline long tv_dict_len(const dict_T *const d)
{
  if (d == 
# 671 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h" 3 4
          ((void *)0)
# 671 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h"
              ) {
    return 0L;
  }
  return (long)d->dv_hashtab.ht_used;
}

static inline 
# 677 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h" 3 4
             _Bool 
# 677 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h"
                  tv_dict_is_watched(const dict_T *const d)
  __attribute__ ((pure)) __attribute__((warn_unused_result));






static inline 
# 685 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h" 3 4
             _Bool 
# 685 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h"
                  tv_dict_is_watched(const dict_T *const d)
{
  return d && !QUEUE_EMPTY(&d->watchers);
}






static inline void tv_init(typval_T *const tv)
{
  if (tv != 
# 697 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h" 3 4
           ((void *)0)
# 697 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h"
               ) {
    memset(tv, 0, sizeof(*tv));
  }
}
# 712 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h"
extern const char *const tv_empty_string;


extern 
# 715 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h" 3 4
      _Bool 
# 715 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h"
           tv_in_free_unref_items;
# 802 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h"
static inline 
# 802 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h" 3 4
             _Bool 
# 802 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h"
                  tv_get_float_chk(const typval_T *const tv,
                                    float_T *const ret_f)
  __attribute__((nonnull)) __attribute__((warn_unused_result));



# 807 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h" 3 4
_Bool 
# 807 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h"
    emsgf(const char *const fmt, ...);
# 817 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h"
static inline 
# 817 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h" 3 4
             _Bool 
# 817 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h"
                  tv_get_float_chk(const typval_T *const tv,
                                    float_T *const ret_f)
{
  if (tv->v_type == VAR_FLOAT) {
    *ret_f = tv->vval.v_float;
    return 
# 822 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h" 3 4
          1
# 822 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h"
              ;
  }
  if (tv->v_type == VAR_NUMBER) {
    *ret_f = (float_T)tv->vval.v_number;
    return 
# 826 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h" 3 4
          1
# 826 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h"
              ;
  }
  emsgf("%s", gettext((char *)("E808: Number or Float required")));
  return 
# 829 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h" 3 4
        0
# 829 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h"
             ;
}

static inline DictWatcher *tv_dict_watcher_node_data(QUEUE *q)
  __attribute__((nonnull)) __attribute__((returns_nonnull)) __attribute__ ((pure))
  __attribute__((warn_unused_result)) __attribute__((always_inline));





static inline DictWatcher *tv_dict_watcher_node_data(QUEUE *q)
{
  return ((DictWatcher *)((char *)(q) - 
# 842 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h" 3 4
        __builtin_offsetof (
# 842 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h"
        DictWatcher
# 842 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h" 3 4
        , 
# 842 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h"
        node
# 842 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h" 3 4
        )
# 842 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h"
        ));
}

static inline 
# 845 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h" 3 4
             _Bool 
# 845 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h"
                  tv_is_func(const typval_T tv)
  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_ALWAYS_INLINE FUNC_ATTR_CONST;
# 855 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h"
static inline 
# 855 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h" 3 4
             _Bool 
# 855 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h"
                  tv_is_func(const typval_T tv)
{
  return tv.v_type == VAR_FUNC || tv.v_type == VAR_PARTIAL;
}
# 10 "/home/toto/.env/encours/neovim/src/nvim/strings.h" 2
# 20 "/home/toto/.env/encours/neovim/src/nvim/strings.h"
static inline char *strappend(char *const dst, const char *const src)
  FUNC_ATTR_ALWAYS_INLINE FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT
  FUNC_ATTR_NONNULL_RET
{
  const size_t src_len = strlen(src);
  return (char *)memmove(dst, src, src_len) + src_len;
}
# 5 "/home/toto/.env/encours/neovim/src/nvim/keymap.h" 2
# 124 "/home/toto/.env/encours/neovim/src/nvim/keymap.h"
enum key_extra {
  KE_NAME = 3

  , KE_S_UP = 4
  , KE_S_DOWN = 5

  , KE_S_F1 = 6
  , KE_S_F2 = 7
  , KE_S_F3 = 8
  , KE_S_F4 = 9
  , KE_S_F5 = 10
  , KE_S_F6 = 11
  , KE_S_F7 = 12
  , KE_S_F8 = 13
  , KE_S_F9 = 14
  , KE_S_F10 = 15

  , KE_S_F11 = 16
  , KE_S_F12 = 17
  , KE_S_F13 = 18
  , KE_S_F14 = 19
  , KE_S_F15 = 20
  , KE_S_F16 = 21
  , KE_S_F17 = 22
  , KE_S_F18 = 23
  , KE_S_F19 = 24
  , KE_S_F20 = 25

  , KE_S_F21 = 26
  , KE_S_F22 = 27
  , KE_S_F23 = 28
  , KE_S_F24 = 29
  , KE_S_F25 = 30
  , KE_S_F26 = 31
  , KE_S_F27 = 32
  , KE_S_F28 = 33
  , KE_S_F29 = 34
  , KE_S_F30 = 35

  , KE_S_F31 = 36
  , KE_S_F32 = 37
  , KE_S_F33 = 38
  , KE_S_F34 = 39
  , KE_S_F35 = 40
  , KE_S_F36 = 41
  , KE_S_F37 = 42

  , KE_MOUSE = 43



  , KE_LEFTMOUSE = 44
  , KE_LEFTDRAG = 45
  , KE_LEFTRELEASE = 46
  , KE_MIDDLEMOUSE = 47
  , KE_MIDDLEDRAG = 48
  , KE_MIDDLERELEASE = 49
  , KE_RIGHTMOUSE = 50
  , KE_RIGHTDRAG = 51
  , KE_RIGHTRELEASE = 52

  , KE_IGNORE = 53

  , KE_TAB = 54
  , KE_S_TAB_OLD = 55


  , KE_XF1 = 57
  , KE_XF2 = 58
  , KE_XF3 = 59
  , KE_XF4 = 60
  , KE_XEND = 61
  , KE_ZEND = 62
  , KE_XHOME = 63
  , KE_ZHOME = 64
  , KE_XUP = 65
  , KE_XDOWN = 66
  , KE_XLEFT = 67
  , KE_XRIGHT = 68

  , KE_LEFTMOUSE_NM = 69
  , KE_LEFTRELEASE_NM = 70

  , KE_S_XF1 = 71
  , KE_S_XF2 = 72
  , KE_S_XF3 = 73
  , KE_S_XF4 = 74




  , KE_MOUSEDOWN = 75
  , KE_MOUSEUP = 76
  , KE_MOUSELEFT = 77
  , KE_MOUSERIGHT = 78

  , KE_KINS = 79
  , KE_KDEL = 80

  , KE_CSI = 81
  , KE_SNR = 82
  , KE_PLUG = 83
  , KE_CMDWIN = 84

  , KE_C_LEFT = 85
  , KE_C_RIGHT = 86
  , KE_C_HOME = 87
  , KE_C_END = 88

  , KE_X1MOUSE = 89
  , KE_X1DRAG = 90
  , KE_X1RELEASE = 91
  , KE_X2MOUSE = 92
  , KE_X2DRAG = 93
  , KE_X2RELEASE = 94

  , KE_DROP = 95

  , KE_NOP = 97




  , KE_EVENT = 102
  , KE_COMMAND = 104
};
# 34 "/home/toto/.env/encours/neovim/src/nvim/vim.h" 2
# 80 "/home/toto/.env/encours/neovim/src/nvim/vim.h"
typedef enum {
  kDirectionNotSet = 0,
  FORWARD = 1,
  BACKWARD = (-1),
  FORWARD_FILE = 3,
  BACKWARD_FILE = (-3),
} Direction;
# 108 "/home/toto/.env/encours/neovim/src/nvim/vim.h"
enum {
  EXPAND_UNSUCCESSFUL = -2,
  EXPAND_OK = -1,
  EXPAND_NOTHING = 0,
  EXPAND_COMMANDS,
  EXPAND_FILES,
  EXPAND_DIRECTORIES,
  EXPAND_SETTINGS,
  EXPAND_BOOL_SETTINGS,
  EXPAND_TAGS,
  EXPAND_OLD_SETTING,
  EXPAND_HELP,
  EXPAND_BUFFERS,
  EXPAND_EVENTS,
  EXPAND_MENUS,
  EXPAND_SYNTAX,
  EXPAND_HIGHLIGHT,
  EXPAND_AUGROUP,
  EXPAND_USER_VARS,
  EXPAND_MAPPINGS,
  EXPAND_TAGS_LISTFILES,
  EXPAND_FUNCTIONS,
  EXPAND_USER_FUNC,
  EXPAND_EXPRESSION,
  EXPAND_MENUNAMES,
  EXPAND_USER_COMMANDS,
  EXPAND_USER_CMD_FLAGS,
  EXPAND_USER_NARGS,
  EXPAND_USER_COMPLETE,
  EXPAND_ENV_VARS,
  EXPAND_LANGUAGE,
  EXPAND_COLORS,
  EXPAND_COMPILER,
  EXPAND_USER_DEFINED,
  EXPAND_USER_LIST,
  EXPAND_SHELLCMD,
  EXPAND_CSCOPE,
  EXPAND_SIGN,
  EXPAND_PROFILE,
  EXPAND_BEHAVE,
  EXPAND_FILETYPE,
  EXPAND_FILES_IN_PATH,
  EXPAND_OWNSYNTAX,
  EXPAND_LOCALES,
  EXPAND_HISTORY,
  EXPAND_USER,
  EXPAND_SYNTIME,
  EXPAND_USER_ADDR_TYPE,
  EXPAND_PACKADD,
  EXPAND_MESSAGES,
  EXPAND_MAPCLEAR,
  EXPAND_ARGLIST,
  EXPAND_CHECKHEALTH,
};
# 199 "/home/toto/.env/encours/neovim/src/nvim/vim.h"
enum { FOLD_TEXT_LEN = 51 };
# 263 "/home/toto/.env/encours/neovim/src/nvim/vim.h"
# 1 "/home/toto/.env/encours/neovim/src/nvim/path.h" 1



# 1 "/home/toto/.env/encours/neovim/src/nvim/func_attr.h" 1
# 5 "/home/toto/.env/encours/neovim/src/nvim/path.h" 2
# 31 "/home/toto/.env/encours/neovim/src/nvim/path.h"
typedef enum file_comparison {
  kEqualFiles = 1,
  kDifferentFiles = 2,
  kBothFilesMissing = 4,
  kOneFileMissing = 6,
  kEqualFileNames = 7
} FileComparison;
# 264 "/home/toto/.env/encours/neovim/src/nvim/vim.h" 2
# 300 "/home/toto/.env/encours/neovim/src/nvim/vim.h"
# 1 "/home/toto/.env/encours/neovim/src/nvim/globals.h" 1







# 1 "/home/toto/.env/encours/neovim/src/nvim/ex_eval.h" 1




# 1 "/home/toto/.env/encours/neovim/src/nvim/ex_cmds_defs.h" 1







# 1 "/home/toto/.env/encours/neovim/src/nvim/normal.h" 1





# 1 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h" 1
# 9 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h"
typedef struct file_buffer buf_T;



typedef struct {
  buf_T *br_buf;
  int br_fnum;
  int br_buf_free_count;
} bufref_T;






# 1 "/home/toto/.env/encours/neovim/src/nvim/highlight_defs.h" 1







typedef int32_t RgbValue;




typedef enum {
  HL_INVERSE = 0x01,
  HL_BOLD = 0x02,
  HL_ITALIC = 0x04,
  HL_UNDERLINE = 0x08,
  HL_UNDERCURL = 0x10,
  HL_STANDOUT = 0x20,
  HL_STRIKETHROUGH = 0x40,
  HL_NOCOMBINE = 0x80,
  HL_BG_INDEXED = 0x0100,
  HL_FG_INDEXED = 0x0200,
} HlAttrFlags;



typedef struct attr_entry {
  int16_t rgb_ae_attr, cterm_ae_attr;
  RgbValue rgb_fg_color, rgb_bg_color, rgb_sp_color;
  int cterm_fg_color, cterm_bg_color;
  int hl_blend;
} HlAttrs;
# 48 "/home/toto/.env/encours/neovim/src/nvim/highlight_defs.h"
typedef enum {
  HLF_8 = 0

  , HLF_EOB
  , HLF_TERM
  , HLF_TERMNC
  , HLF_AT

  , HLF_D
  , HLF_E
  , HLF_I
  , HLF_L
  , HLF_M
  , HLF_CM
  , HLF_N
  , HLF_CLN
  , HLF_R
  , HLF_S
  , HLF_SNC
  , HLF_C
  , HLF_T
  , HLF_V
  , HLF_VNC
  , HLF_W
  , HLF_WM
  , HLF_FL
  , HLF_FC
  , HLF_ADD
  , HLF_CHD
  , HLF_DED
  , HLF_TXD
  , HLF_SC
  , HLF_CONCEAL
  , HLF_SPB
  , HLF_SPC
  , HLF_SPR
  , HLF_SPL
  , HLF_PNI
  , HLF_PSI
  , HLF_PSB
  , HLF_PST
  , HLF_TP
  , HLF_TPS
  , HLF_TPF
  , HLF_CUC
  , HLF_CUL
  , HLF_MC
  , HLF_QFL
  , HLF_0
  , HLF_INACTIVE
  , HLF_MSGSEP
  , HLF_NFLOAT
  , HLF_MSG
  , HLF_COUNT
} hlf_T;

extern const char *hlf_names[]
# 155 "/home/toto/.env/encours/neovim/src/nvim/highlight_defs.h"
  ;


extern int highlight_attr[HLF_COUNT];
extern int highlight_attr_last[HLF_COUNT];
extern int highlight_user[9];
extern int highlight_stlnc[9];
extern int cterm_normal_fg_color ;
extern int cterm_normal_bg_color ;
extern RgbValue normal_fg ;
extern RgbValue normal_bg ;
extern RgbValue normal_sp ;

typedef enum {
  kHlUnknown,
  kHlUI,
  kHlSyntax,
  kHlTerminal,
  kHlCombine,
  kHlBlend,
  kHlBlendThrough,
} HlKind;

typedef struct {
  HlAttrs attr;
  HlKind kind;
  int id1;
  int id2;
} HlEntry;
# 25 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h" 2



# 1 "/home/toto/.env/encours/neovim/src/nvim/option_defs.h" 1





# 1 "/home/toto/.env/encours/neovim/src/nvim/eval/typval.h" 1
# 7 "/home/toto/.env/encours/neovim/src/nvim/option_defs.h" 2
# 156 "/home/toto/.env/encours/neovim/src/nvim/option_defs.h"
enum {
  SHM_RO = 'r',
  SHM_MOD = 'm',
  SHM_FILE = 'f',
  SHM_LAST = 'i',
  SHM_TEXT = 'x',
  SHM_LINES = 'l',
  SHM_NEW = 'n',
  SHM_WRI = 'w',
  SHM_ABBREVIATIONS = 'a',
  SHM_WRITE = 'W',
  SHM_TRUNC = 't',
  SHM_TRUNCALL = 'T',
  SHM_OVER = 'o',
  SHM_OVERALL = 'O',
  SHM_SEARCH = 's',
  SHM_ATTENTION = 'A',
  SHM_INTRO = 'I',
  SHM_COMPLETIONMENU = 'c',
  SHM_RECORDING = 'q',
  SHM_FILEINFO = 'F',
  SHM_SEARCHCOUNT = 'S',
};
# 224 "/home/toto/.env/encours/neovim/src/nvim/option_defs.h"
enum {
  STL_FILEPATH = 'f',
  STL_FULLPATH = 'F',
  STL_FILENAME = 't',
  STL_COLUMN = 'c',
  STL_VIRTCOL = 'v',
  STL_VIRTCOL_ALT = 'V',
  STL_LINE = 'l',
  STL_NUMLINES = 'L',
  STL_BUFNO = 'n',
  STL_KEYMAP = 'k',
  STL_OFFSET = 'o',
  STL_OFFSET_X = 'O',
  STL_BYTEVAL = 'b',
  STL_BYTEVAL_X = 'B',
  STL_ROFLAG = 'r',
  STL_ROFLAG_ALT = 'R',
  STL_HELPFLAG = 'h',
  STL_HELPFLAG_ALT = 'H',
  STL_FILETYPE = 'y',
  STL_FILETYPE_ALT = 'Y',
  STL_PREVIEWFLAG = 'w',
  STL_PREVIEWFLAG_ALT = 'W',
  STL_MODIFIED = 'm',
  STL_MODIFIED_ALT = 'M',
  STL_QUICKFIX = 'q',
  STL_PERCENTAGE = 'p',
  STL_ALTPERCENT = 'P',
  STL_ARGLISTSTAT = 'a',
  STL_PAGENUM = 'N',
  STL_VIM_EXPR = '{',
  STL_SEPARATE = '=',
  STL_TRUNCMARK = '<',
  STL_USER_HL = '*',
  STL_HIGHLIGHT = '#',
  STL_TABPAGENR = 'T',
  STL_TABCLOSENR = 'X',
  STL_CLICK_FUNC = '@',
};
# 294 "/home/toto/.env/encours/neovim/src/nvim/option_defs.h"
extern long p_aleph;
extern int p_acd;
extern char_u *p_ambw;
extern int p_ar;
extern int p_aw;
extern int p_awa;
extern char_u *p_bs;
extern char_u *p_bg;
extern int p_bk;
extern char_u *p_bkc;
extern unsigned int bkc_flags;
# 314 "/home/toto/.env/encours/neovim/src/nvim/option_defs.h"
extern char_u *p_bdir;
extern char_u *p_bex;
extern char_u *p_bo;
extern char breakat_flags[256];
extern unsigned bo_flags;
# 348 "/home/toto/.env/encours/neovim/src/nvim/option_defs.h"
extern char_u *p_bsk;
extern char_u *p_breakat;
extern char_u *p_cmp;
extern unsigned cmp_flags;





extern char_u *p_enc;
extern int p_deco;
extern char_u *p_ccv;
extern char_u *p_cedit;
extern char_u *p_cb;
extern unsigned cb_flags;






extern long p_cwh;
extern long p_ch;
extern long p_columns;
extern int p_confirm;
extern int p_cp;
extern char_u *p_cot;
extern long p_pb;
extern long p_ph;
extern long p_pw;
extern char_u *p_cpo;
extern char_u *p_csprg;
extern int p_csre;
extern char_u *p_csqf;


extern int p_cst;
extern long p_csto;
extern long p_cspc;
extern int p_csverbose;
extern char_u *p_debug;
extern char_u *p_def;
extern char_u *p_inc;
extern char_u *p_dip;
extern char_u *p_dex;
extern char_u *p_dict;
extern int p_dg;
extern char_u *p_dir;
extern char_u *p_dy;
extern unsigned dy_flags;
# 407 "/home/toto/.env/encours/neovim/src/nvim/option_defs.h"
extern int p_ed;
extern int p_emoji;
extern char_u *p_ead;
extern int p_ea;
extern char_u *p_ep;
extern int p_eb;
extern char_u *p_ef;
extern char_u *p_efm;
extern char_u *p_gefm;
extern char_u *p_gp;
extern char_u *p_ei;
extern int p_exrc;
extern char_u *p_fencs;
extern char_u *p_ffs;
extern int p_fic;
extern char_u *p_fcl;
extern long p_fdls;
extern char_u *p_fdo;
extern unsigned fdo_flags;
# 442 "/home/toto/.env/encours/neovim/src/nvim/option_defs.h"
extern char_u *p_fp;
extern int p_fs;
extern int p_gd;
extern char_u *p_pdev;
extern char_u *p_penc;
extern char_u *p_pexpr;
extern char_u *p_pmfn;
extern char_u *p_pmcs;
extern char_u *p_pfn;
extern char_u *p_popt;
extern char_u *p_header;
extern int p_prompt;
extern char_u *p_guicursor;
extern char_u *p_guifont;
extern char_u *p_guifontset;
extern char_u *p_guifontwide;
extern char_u *p_hf;
extern long p_hh;
extern char_u *p_hlg;
extern int p_hid;
extern char_u *p_hl;
extern int p_hls;
extern long p_hi;
extern int p_hkmap;
extern int p_hkmapp;
extern int p_arshape;
extern int p_icon;
extern char_u *p_iconstring;
extern int p_ic;
extern int p_is;
extern char_u *p_icm;
extern int p_im;
extern char_u *p_isf;
extern char_u *p_isi;
extern char_u *p_isp;
extern int p_js;
extern char_u *p_jop;
extern unsigned jop_flags;




extern char_u *p_kp;
extern char_u *p_km;
extern char_u *p_langmap;
extern int p_lnr;
extern int p_lrm;
extern char_u *p_lm;
extern long p_lines;
extern long p_linespace;
extern char_u *p_lispwords;
extern long p_ls;
extern long p_stal;
extern char_u *p_lcs;

extern int p_lz;
extern int p_lpl;
extern int p_magic;
extern char_u *p_menc;
extern char_u *p_mef;
extern char_u *p_mp;
extern char_u *p_cc;
extern int p_cc_cols[256];
extern long p_mat;
extern long p_mco;
extern long p_mfd;
extern long p_mmd;
extern long p_mmp;
extern long p_mis;
extern char_u *p_msm;
extern long p_mle;
extern long p_mls;
extern char_u *p_mouse;
extern char_u *p_mousem;
extern long p_mouset;
extern int p_more;
extern char_u *p_opfunc;
extern char_u *p_para;
extern int p_paste;
extern char_u *p_pt;
extern char_u *p_pex;
extern char_u *p_pm;
extern char_u *p_path;
extern char_u *p_cdpath;
extern long p_pyx;
extern char_u *p_rdb;
extern unsigned rdb_flags;
# 543 "/home/toto/.env/encours/neovim/src/nvim/option_defs.h"
extern long p_rdt;
extern int p_remap;
extern long p_re;
extern long p_report;
extern long p_pvh;
extern int p_ari;
extern int p_ri;
extern int p_ru;
extern char_u *p_ruf;
extern char_u *p_pp;
extern char_u *p_rtp;
extern long p_scbk;
extern long p_sj;
extern long p_so;
extern char_u *p_sbo;
extern char_u *p_sections;
extern int p_secure;
extern char_u *p_sel;
extern char_u *p_slm;
extern char_u *p_ssop;
extern unsigned ssop_flags;
# 589 "/home/toto/.env/encours/neovim/src/nvim/option_defs.h"
extern char_u *p_sh;
extern char_u *p_shcf;
extern char_u *p_sp;
extern char_u *p_shq;
extern char_u *p_sxq;
extern char_u *p_sxe;
extern char_u *p_srr;
extern int p_stmp;



extern char_u *p_stl;
extern int p_sr;
extern char_u *p_shm;
extern char_u *p_sbr;
extern int p_sc;
extern int p_sft;
extern int p_sm;
extern int p_smd;
extern long p_ss;
extern long p_siso;
extern int p_scs;
extern int p_sta;
extern int p_sb;
extern long p_tpm;
extern char_u *p_tal;
extern char_u *p_sps;
extern int p_spr;
extern int p_sol;
extern char_u *p_su;
extern char_u *p_swb;
extern unsigned swb_flags;
# 631 "/home/toto/.env/encours/neovim/src/nvim/option_defs.h"
extern int p_tbs;
extern char_u *p_tc;
extern unsigned tc_flags;
# 643 "/home/toto/.env/encours/neovim/src/nvim/option_defs.h"
extern long p_tl;
extern int p_tr;
extern char_u *p_tags;
extern int p_tgst;
extern int p_tbidi;
extern int p_terse;
extern int p_to;
extern int p_timeout;
extern long p_tm;
extern int p_title;
extern long p_titlelen;
extern char_u *p_titleold;
extern char_u *p_titlestring;
extern char_u *p_tsr;
extern int p_tgc;
extern int p_ttimeout;
extern long p_ttm;
extern char_u *p_udir;
extern long p_ul;
extern long p_ur;
extern long p_uc;
extern long p_ut;
extern char_u *p_fcs;
extern char_u *p_shada;
extern char *p_shadafile;
extern char_u *p_vdir;
extern char_u *p_vop;
extern unsigned vop_flags;
extern int p_vb;
extern char_u *p_ve;
extern unsigned ve_flags;







extern long p_verbose;



extern char_u *p_vfile;

extern int p_warn;
extern char_u *p_wop;
extern unsigned wop_flags;





extern long p_window;
extern char_u *p_wak;
extern char_u *p_wig;
extern char_u *p_ww;
extern long p_wc;
extern long p_wcm;
extern int p_wic;
extern char_u *p_wim;
extern int p_wmnu;
extern long p_wh;
extern long p_wmh;
extern long p_wmw;
extern long p_wiw;
extern int p_ws;
extern int p_write;
extern int p_wa;
extern int p_wb;
extern long p_wd;

extern int p_force_on;
extern int p_force_off;






enum {
  BV_AI = 0
  , BV_AR
  , BV_BH
  , BV_BKC
  , BV_BT
  , BV_EFM
  , BV_GP
  , BV_MP
  , BV_BIN
  , BV_BL
  , BV_BOMB
  , BV_CHANNEL
  , BV_CI
  , BV_CIN
  , BV_CINK
  , BV_CINO
  , BV_CINW
  , BV_CM
  , BV_CMS
  , BV_COM
  , BV_CPT
  , BV_DICT
  , BV_TSR
  , BV_CFU
  , BV_DEF
  , BV_INC
  , BV_EOL
  , BV_FIXEOL
  , BV_EP
  , BV_ET
  , BV_FENC
  , BV_FP
  , BV_BEXPR
  , BV_FEX
  , BV_FF
  , BV_FLP
  , BV_FO
  , BV_FT
  , BV_IMI
  , BV_IMS
  , BV_INDE
  , BV_INDK
  , BV_INEX
  , BV_INF
  , BV_ISK
  , BV_KMAP
  , BV_KP
  , BV_LISP
  , BV_LW
  , BV_MENC
  , BV_MA
  , BV_ML
  , BV_MOD
  , BV_MPS
  , BV_NF
  , BV_OFU
  , BV_PATH
  , BV_PI
  , BV_QE
  , BV_RO
  , BV_SCBK
  , BV_SI
  , BV_SMC
  , BV_SYN
  , BV_SPC
  , BV_SPF
  , BV_SPL
  , BV_STS
  , BV_SUA
  , BV_SW
  , BV_SWF
  , BV_TFU
  , BV_TAGS
  , BV_TC
  , BV_TS
  , BV_TW
  , BV_TX
  , BV_UDF
  , BV_UL
  , BV_WM
  , BV_COUNT
};






enum {
  WV_LIST = 0
  , WV_ARAB
  , WV_COCU
  , WV_COLE
  , WV_CRBIND
  , WV_BRI
  , WV_BRIOPT
  , WV_DIFF
  , WV_FDC
  , WV_FEN
  , WV_FDI
  , WV_FDL
  , WV_FDM
  , WV_FML
  , WV_FDN
  , WV_FDE
  , WV_FDT
  , WV_FMR
  , WV_LBR
  , WV_NU
  , WV_RNU
  , WV_NUW
  , WV_PVW
  , WV_RL
  , WV_RLC
  , WV_SCBIND
  , WV_SCROLL
  , WV_SISO
  , WV_SO
  , WV_SPELL
  , WV_CUC
  , WV_CUL
  , WV_CC
  , WV_STL
  , WV_WFH
  , WV_WFW
  , WV_WRAP
  , WV_SCL
  , WV_WINHL
  , WV_FCS
  , WV_LCS
  , WV_WINBL
  , WV_COUNT
};







typedef struct {
  sctx_T script_ctx;
  uint64_t channel_id;
} LastSet;
# 29 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h" 2

# 1 "/home/toto/.env/encours/neovim/src/nvim/mark_defs.h" 1




# 1 "/home/toto/.env/encours/neovim/src/nvim/os/time.h" 1







typedef uint64_t Timestamp;
# 6 "/home/toto/.env/encours/neovim/src/nvim/mark_defs.h" 2
# 35 "/home/toto/.env/encours/neovim/src/nvim/mark_defs.h"
typedef struct filemark {
  pos_T mark;
  int fnum;
  Timestamp timestamp;
  dict_T *additional_data;
} fmark_T;


typedef struct xfilemark {
  fmark_T fmark;
  char_u *fname;
} xfmark_T;
# 31 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h" 2

# 1 "/home/toto/.env/encours/neovim/src/nvim/undo_defs.h" 1






# 1 "/home/toto/.env/encours/neovim/src/nvim/extmark_defs.h" 1




# 1 "/home/toto/.env/encours/neovim/src/nvim/lib/kvec.h" 1
# 43 "/home/toto/.env/encours/neovim/src/nvim/lib/kvec.h"
# 1 "/home/toto/.env/encours/neovim/src/nvim/memory.h" 1





# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 7 "/home/toto/.env/encours/neovim/src/nvim/memory.h" 2



typedef void *(*MemMalloc)(size_t);


typedef void (*MemFree)(void *);


typedef void *(*MemCalloc)(size_t, size_t);


typedef void *(*MemRealloc)(void *, size_t);
# 44 "/home/toto/.env/encours/neovim/src/nvim/lib/kvec.h" 2
# 139 "/home/toto/.env/encours/neovim/src/nvim/lib/kvec.h"
static inline void *_memcpy_free(void *const restrict dest,
                                 void *const restrict src,
                                 const size_t size)
  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_NONNULL_RET FUNC_ATTR_ALWAYS_INLINE
{
  memcpy(dest, src, size);
  do { void **ptr_ = (void **)&(src); xfree(*ptr_); *ptr_ = 
# 145 "/home/toto/.env/encours/neovim/src/nvim/lib/kvec.h" 3 4
 ((void *)0)
# 145 "/home/toto/.env/encours/neovim/src/nvim/lib/kvec.h"
 ; (void)(*ptr_); } while (0);
  return dest;
}
# 6 "/home/toto/.env/encours/neovim/src/nvim/extmark_defs.h" 2

typedef struct {
  char *text;
  int hl_id;
} VirtTextChunk;

typedef struct { size_t size; size_t capacity; VirtTextChunk *items; } VirtText;


typedef struct
{
  uint64_t ns_id;
  uint64_t mark_id;
  int hl_id;


  VirtText virt_text;
} ExtmarkItem;

typedef struct undo_object ExtmarkUndoObject;
typedef struct { size_t size; size_t capacity; ExtmarkUndoObject *items; } extmark_undo_vec_t;



typedef enum {
  kExtmarkNOOP,
  kExtmarkUndo,
  kExtmarkNoUndo,
  kExtmarkUndoNoRedo,
} ExtmarkOp;
# 8 "/home/toto/.env/encours/neovim/src/nvim/undo_defs.h" 2


typedef struct u_header u_header_T;


typedef struct {
  pos_T vi_start;
  pos_T vi_end;
  int vi_mode;
  colnr_T vi_curswant;
} visualinfo_T;

# 1 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h" 1
# 21 "/home/toto/.env/encours/neovim/src/nvim/undo_defs.h" 2

typedef struct u_entry u_entry_T;
struct u_entry {
  u_entry_T *ue_next;
  linenr_T ue_top;
  linenr_T ue_bot;
  linenr_T ue_lcount;
  char_u **ue_array;
  long ue_size;



};

struct u_header {


  union {
    u_header_T *ptr;
    long seq;
  } uh_next;
  union {
    u_header_T *ptr;
    long seq;
  } uh_prev;
  union {
    u_header_T *ptr;
    long seq;
  } uh_alt_next;
  union {
    u_header_T *ptr;
    long seq;
  } uh_alt_prev;
  long uh_seq;
  int uh_walk;
  u_entry_T *uh_entry;
  u_entry_T *uh_getbot_entry;
  pos_T uh_cursor;
  long uh_cursor_vcol;
  int uh_flags;
  fmark_T uh_namedm[('z' - 'a' + 1)];
  extmark_undo_vec_t uh_extmark;
  visualinfo_T uh_visual;
  time_t uh_time;
  long uh_save_nr;




};






typedef struct {
  buf_T *bi_buf;
  FILE *bi_fp;
} bufinfo_T;
# 33 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h" 2







# 1 "/home/toto/.env/encours/neovim/src/nvim/api/private/defs.h" 1







# 1 "/home/toto/.env/encours/neovim/src/nvim/func_attr.h" 1
# 9 "/home/toto/.env/encours/neovim/src/nvim/api/private/defs.h" 2
# 25 "/home/toto/.env/encours/neovim/src/nvim/api/private/defs.h"
typedef enum {
  kErrorTypeNone = -1,
  kErrorTypeException,
  kErrorTypeValidation
} ErrorType;

typedef enum {
  kMessageTypeUnknown = -1,

  kMessageTypeRequest = 0,
  kMessageTypeResponse = 1,
  kMessageTypeNotification = 2,
} MessageType;
# 48 "/home/toto/.env/encours/neovim/src/nvim/api/private/defs.h"
static inline 
# 48 "/home/toto/.env/encours/neovim/src/nvim/api/private/defs.h" 3 4
             _Bool 
# 48 "/home/toto/.env/encours/neovim/src/nvim/api/private/defs.h"
                  is_internal_call(const uint64_t channel_id)
  __attribute__((always_inline)) __attribute__((const));






static inline 
# 56 "/home/toto/.env/encours/neovim/src/nvim/api/private/defs.h" 3 4
             _Bool 
# 56 "/home/toto/.env/encours/neovim/src/nvim/api/private/defs.h"
                  is_internal_call(const uint64_t channel_id)
{
  return !!(channel_id & (((uint64_t)1) << (sizeof(uint64_t) * 8 - 1)));
}

typedef struct {
  ErrorType type;
  char *msg;
} Error;

typedef 
# 66 "/home/toto/.env/encours/neovim/src/nvim/api/private/defs.h" 3 4
       _Bool 
# 66 "/home/toto/.env/encours/neovim/src/nvim/api/private/defs.h"
            Boolean;
typedef int64_t Integer;
typedef double Float;







typedef struct {
  char *data;
  size_t size;
} String;

typedef handle_T Buffer;
typedef handle_T Window;
typedef handle_T Tabpage;

typedef struct object Object;

typedef struct {
  Object *items;
  size_t size, capacity;
} Array;

typedef struct key_value_pair KeyValuePair;

typedef struct {
  KeyValuePair *items;
  size_t size, capacity;
} Dictionary;

typedef enum {
  kObjectTypeNil = 0,
  kObjectTypeBoolean,
  kObjectTypeInteger,
  kObjectTypeFloat,
  kObjectTypeString,
  kObjectTypeArray,
  kObjectTypeDictionary,
  kObjectTypeLuaRef,

  kObjectTypeBuffer,
  kObjectTypeWindow,
  kObjectTypeTabpage,
} ObjectType;

struct object {
  ObjectType type;
  union {
    Boolean boolean;
    Integer integer;
    Float floating;
    String string;
    Array array;
    Dictionary dictionary;
    LuaRef luaref;
  } data;
};

struct key_value_pair {
  String key;
  Object value;
};
# 41 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h" 2

# 1 "/home/toto/.env/encours/neovim/src/nvim/map.h" 1





# 1 "/home/toto/.env/encours/neovim/src/nvim/map_defs.h" 1



# 1 "/home/toto/.env/encours/neovim/src/nvim/lib/khash.h" 1
# 130 "/home/toto/.env/encours/neovim/src/nvim/lib/khash.h"
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include-fixed/limits.h" 1 3 4
# 131 "/home/toto/.env/encours/neovim/src/nvim/lib/khash.h" 2




# 1 "/home/toto/.env/encours/neovim/src/nvim/func_attr.h" 1
# 136 "/home/toto/.env/encours/neovim/src/nvim/lib/khash.h" 2




typedef unsigned int khint32_t;





typedef unsigned long khint64_t;
# 157 "/home/toto/.env/encours/neovim/src/nvim/lib/khash.h"
typedef khint32_t khint_t;
typedef khint_t khiter_t;
# 459 "/home/toto/.env/encours/neovim/src/nvim/lib/khash.h"
static inline khint_t __ac_X31_hash_string(const char *s)
{
 khint_t h = (khint_t)*s;
 if (h) for (++s ; *s; ++s) h = (h << 5) - h + (uint8_t)*s;
 return h;
}
# 476 "/home/toto/.env/encours/neovim/src/nvim/lib/khash.h"
static inline khint_t __ac_Wang_hash(khint_t key)
{
    key += ~(key << 15);
    key ^= (key >> 10);
    key += (key << 3);
    key ^= (key >> 6);
    key += ~(key << 11);
    key ^= (key >> 16);
    return key;
}
# 700 "/home/toto/.env/encours/neovim/src/nvim/lib/khash.h"
typedef const char *kh_cstr_t;
# 5 "/home/toto/.env/encours/neovim/src/nvim/map_defs.h" 2

typedef const char * cstr_t;
typedef void * ptr_t;
# 7 "/home/toto/.env/encours/neovim/src/nvim/map.h" 2


# 1 "/home/toto/.env/encours/neovim/src/nvim/api/private/dispatch.h" 1





typedef Object (*ApiDispatchWrapper)(uint64_t channel_id,
                                     Array args,
                                     Error *error);



typedef struct {
  ApiDispatchWrapper fn;
  
# 14 "/home/toto/.env/encours/neovim/src/nvim/api/private/dispatch.h" 3 4
 _Bool 
# 14 "/home/toto/.env/encours/neovim/src/nvim/api/private/dispatch.h"
      fast;



} MsgpackRpcRequestHandler;
# 10 "/home/toto/.env/encours/neovim/src/nvim/map.h" 2
# 37 "/home/toto/.env/encours/neovim/src/nvim/map.h"
typedef struct { khint_t n_buckets, size, n_occupied, upper_bound; khint32_t *flags; int *keys; int *vals; } kh_int_int_map_t; extern kh_int_int_map_t *kh_init_int_int_map(void); extern void kh_dealloc_int_int_map(kh_int_int_map_t *h); extern void kh_destroy_int_int_map(kh_int_int_map_t *h); extern void kh_clear_int_int_map(kh_int_int_map_t *h); extern khint_t kh_get_int_int_map(const kh_int_int_map_t *h, int key); extern void kh_resize_int_int_map(kh_int_int_map_t *h, khint_t new_n_buckets); extern khint_t kh_put_int_int_map(kh_int_int_map_t *h, int key, int *ret); extern void kh_del_int_int_map(kh_int_int_map_t *h, khint_t x); typedef struct { kh_int_int_map_t *table; } Map_int_int; Map_int_int *map_int_int_new(void); void map_int_int_free(Map_int_int *map); int map_int_int_get(Map_int_int *map, int key); 
# 37 "/home/toto/.env/encours/neovim/src/nvim/map.h" 3 4
_Bool 
# 37 "/home/toto/.env/encours/neovim/src/nvim/map.h"
map_int_int_has(Map_int_int *map, int key); int map_int_int_key(Map_int_int *map, int key); int map_int_int_put(Map_int_int *map, int key, int value); int *map_int_int_ref(Map_int_int *map, int key, 
# 37 "/home/toto/.env/encours/neovim/src/nvim/map.h" 3 4
_Bool 
# 37 "/home/toto/.env/encours/neovim/src/nvim/map.h"
put); int map_int_int_del(Map_int_int *map, int key); void map_int_int_clear(Map_int_int *map);
typedef struct { khint_t n_buckets, size, n_occupied, upper_bound; khint32_t *flags; cstr_t *keys; ptr_t *vals; } kh_cstr_t_ptr_t_map_t; extern kh_cstr_t_ptr_t_map_t *kh_init_cstr_t_ptr_t_map(void); extern void kh_dealloc_cstr_t_ptr_t_map(kh_cstr_t_ptr_t_map_t *h); extern void kh_destroy_cstr_t_ptr_t_map(kh_cstr_t_ptr_t_map_t *h); extern void kh_clear_cstr_t_ptr_t_map(kh_cstr_t_ptr_t_map_t *h); extern khint_t kh_get_cstr_t_ptr_t_map(const kh_cstr_t_ptr_t_map_t *h, cstr_t key); extern void kh_resize_cstr_t_ptr_t_map(kh_cstr_t_ptr_t_map_t *h, khint_t new_n_buckets); extern khint_t kh_put_cstr_t_ptr_t_map(kh_cstr_t_ptr_t_map_t *h, cstr_t key, int *ret); extern void kh_del_cstr_t_ptr_t_map(kh_cstr_t_ptr_t_map_t *h, khint_t x); typedef struct { kh_cstr_t_ptr_t_map_t *table; } Map_cstr_t_ptr_t; Map_cstr_t_ptr_t *map_cstr_t_ptr_t_new(void); void map_cstr_t_ptr_t_free(Map_cstr_t_ptr_t *map); ptr_t map_cstr_t_ptr_t_get(Map_cstr_t_ptr_t *map, cstr_t key); 
# 38 "/home/toto/.env/encours/neovim/src/nvim/map.h" 3 4
_Bool 
# 38 "/home/toto/.env/encours/neovim/src/nvim/map.h"
map_cstr_t_ptr_t_has(Map_cstr_t_ptr_t *map, cstr_t key); cstr_t map_cstr_t_ptr_t_key(Map_cstr_t_ptr_t *map, cstr_t key); ptr_t map_cstr_t_ptr_t_put(Map_cstr_t_ptr_t *map, cstr_t key, ptr_t value); ptr_t *map_cstr_t_ptr_t_ref(Map_cstr_t_ptr_t *map, cstr_t key, 
# 38 "/home/toto/.env/encours/neovim/src/nvim/map.h" 3 4
_Bool 
# 38 "/home/toto/.env/encours/neovim/src/nvim/map.h"
put); ptr_t map_cstr_t_ptr_t_del(Map_cstr_t_ptr_t *map, cstr_t key); void map_cstr_t_ptr_t_clear(Map_cstr_t_ptr_t *map);
typedef struct { khint_t n_buckets, size, n_occupied, upper_bound; khint32_t *flags; ptr_t *keys; ptr_t *vals; } kh_ptr_t_ptr_t_map_t; extern kh_ptr_t_ptr_t_map_t *kh_init_ptr_t_ptr_t_map(void); extern void kh_dealloc_ptr_t_ptr_t_map(kh_ptr_t_ptr_t_map_t *h); extern void kh_destroy_ptr_t_ptr_t_map(kh_ptr_t_ptr_t_map_t *h); extern void kh_clear_ptr_t_ptr_t_map(kh_ptr_t_ptr_t_map_t *h); extern khint_t kh_get_ptr_t_ptr_t_map(const kh_ptr_t_ptr_t_map_t *h, ptr_t key); extern void kh_resize_ptr_t_ptr_t_map(kh_ptr_t_ptr_t_map_t *h, khint_t new_n_buckets); extern khint_t kh_put_ptr_t_ptr_t_map(kh_ptr_t_ptr_t_map_t *h, ptr_t key, int *ret); extern void kh_del_ptr_t_ptr_t_map(kh_ptr_t_ptr_t_map_t *h, khint_t x); typedef struct { kh_ptr_t_ptr_t_map_t *table; } Map_ptr_t_ptr_t; Map_ptr_t_ptr_t *map_ptr_t_ptr_t_new(void); void map_ptr_t_ptr_t_free(Map_ptr_t_ptr_t *map); ptr_t map_ptr_t_ptr_t_get(Map_ptr_t_ptr_t *map, ptr_t key); 
# 39 "/home/toto/.env/encours/neovim/src/nvim/map.h" 3 4
_Bool 
# 39 "/home/toto/.env/encours/neovim/src/nvim/map.h"
map_ptr_t_ptr_t_has(Map_ptr_t_ptr_t *map, ptr_t key); ptr_t map_ptr_t_ptr_t_key(Map_ptr_t_ptr_t *map, ptr_t key); ptr_t map_ptr_t_ptr_t_put(Map_ptr_t_ptr_t *map, ptr_t key, ptr_t value); ptr_t *map_ptr_t_ptr_t_ref(Map_ptr_t_ptr_t *map, ptr_t key, 
# 39 "/home/toto/.env/encours/neovim/src/nvim/map.h" 3 4
_Bool 
# 39 "/home/toto/.env/encours/neovim/src/nvim/map.h"
put); ptr_t map_ptr_t_ptr_t_del(Map_ptr_t_ptr_t *map, ptr_t key); void map_ptr_t_ptr_t_clear(Map_ptr_t_ptr_t *map);
typedef struct { khint_t n_buckets, size, n_occupied, upper_bound; khint32_t *flags; uint64_t *keys; ptr_t *vals; } kh_uint64_t_ptr_t_map_t; extern kh_uint64_t_ptr_t_map_t *kh_init_uint64_t_ptr_t_map(void); extern void kh_dealloc_uint64_t_ptr_t_map(kh_uint64_t_ptr_t_map_t *h); extern void kh_destroy_uint64_t_ptr_t_map(kh_uint64_t_ptr_t_map_t *h); extern void kh_clear_uint64_t_ptr_t_map(kh_uint64_t_ptr_t_map_t *h); extern khint_t kh_get_uint64_t_ptr_t_map(const kh_uint64_t_ptr_t_map_t *h, uint64_t key); extern void kh_resize_uint64_t_ptr_t_map(kh_uint64_t_ptr_t_map_t *h, khint_t new_n_buckets); extern khint_t kh_put_uint64_t_ptr_t_map(kh_uint64_t_ptr_t_map_t *h, uint64_t key, int *ret); extern void kh_del_uint64_t_ptr_t_map(kh_uint64_t_ptr_t_map_t *h, khint_t x); typedef struct { kh_uint64_t_ptr_t_map_t *table; } Map_uint64_t_ptr_t; Map_uint64_t_ptr_t *map_uint64_t_ptr_t_new(void); void map_uint64_t_ptr_t_free(Map_uint64_t_ptr_t *map); ptr_t map_uint64_t_ptr_t_get(Map_uint64_t_ptr_t *map, uint64_t key); 
# 40 "/home/toto/.env/encours/neovim/src/nvim/map.h" 3 4
_Bool 
# 40 "/home/toto/.env/encours/neovim/src/nvim/map.h"
map_uint64_t_ptr_t_has(Map_uint64_t_ptr_t *map, uint64_t key); uint64_t map_uint64_t_ptr_t_key(Map_uint64_t_ptr_t *map, uint64_t key); ptr_t map_uint64_t_ptr_t_put(Map_uint64_t_ptr_t *map, uint64_t key, ptr_t value); ptr_t *map_uint64_t_ptr_t_ref(Map_uint64_t_ptr_t *map, uint64_t key, 
# 40 "/home/toto/.env/encours/neovim/src/nvim/map.h" 3 4
_Bool 
# 40 "/home/toto/.env/encours/neovim/src/nvim/map.h"
put); ptr_t map_uint64_t_ptr_t_del(Map_uint64_t_ptr_t *map, uint64_t key); void map_uint64_t_ptr_t_clear(Map_uint64_t_ptr_t *map);
typedef struct { khint_t n_buckets, size, n_occupied, upper_bound; khint32_t *flags; uint64_t *keys; ssize_t *vals; } kh_uint64_t_ssize_t_map_t; extern kh_uint64_t_ssize_t_map_t *kh_init_uint64_t_ssize_t_map(void); extern void kh_dealloc_uint64_t_ssize_t_map(kh_uint64_t_ssize_t_map_t *h); extern void kh_destroy_uint64_t_ssize_t_map(kh_uint64_t_ssize_t_map_t *h); extern void kh_clear_uint64_t_ssize_t_map(kh_uint64_t_ssize_t_map_t *h); extern khint_t kh_get_uint64_t_ssize_t_map(const kh_uint64_t_ssize_t_map_t *h, uint64_t key); extern void kh_resize_uint64_t_ssize_t_map(kh_uint64_t_ssize_t_map_t *h, khint_t new_n_buckets); extern khint_t kh_put_uint64_t_ssize_t_map(kh_uint64_t_ssize_t_map_t *h, uint64_t key, int *ret); extern void kh_del_uint64_t_ssize_t_map(kh_uint64_t_ssize_t_map_t *h, khint_t x); typedef struct { kh_uint64_t_ssize_t_map_t *table; } Map_uint64_t_ssize_t; Map_uint64_t_ssize_t *map_uint64_t_ssize_t_new(void); void map_uint64_t_ssize_t_free(Map_uint64_t_ssize_t *map); ssize_t map_uint64_t_ssize_t_get(Map_uint64_t_ssize_t *map, uint64_t key); 
# 41 "/home/toto/.env/encours/neovim/src/nvim/map.h" 3 4
_Bool 
# 41 "/home/toto/.env/encours/neovim/src/nvim/map.h"
map_uint64_t_ssize_t_has(Map_uint64_t_ssize_t *map, uint64_t key); uint64_t map_uint64_t_ssize_t_key(Map_uint64_t_ssize_t *map, uint64_t key); ssize_t map_uint64_t_ssize_t_put(Map_uint64_t_ssize_t *map, uint64_t key, ssize_t value); ssize_t *map_uint64_t_ssize_t_ref(Map_uint64_t_ssize_t *map, uint64_t key, 
# 41 "/home/toto/.env/encours/neovim/src/nvim/map.h" 3 4
_Bool 
# 41 "/home/toto/.env/encours/neovim/src/nvim/map.h"
put); ssize_t map_uint64_t_ssize_t_del(Map_uint64_t_ssize_t *map, uint64_t key); void map_uint64_t_ssize_t_clear(Map_uint64_t_ssize_t *map);
typedef struct { khint_t n_buckets, size, n_occupied, upper_bound; khint32_t *flags; uint64_t *keys; uint64_t *vals; } kh_uint64_t_uint64_t_map_t; extern kh_uint64_t_uint64_t_map_t *kh_init_uint64_t_uint64_t_map(void); extern void kh_dealloc_uint64_t_uint64_t_map(kh_uint64_t_uint64_t_map_t *h); extern void kh_destroy_uint64_t_uint64_t_map(kh_uint64_t_uint64_t_map_t *h); extern void kh_clear_uint64_t_uint64_t_map(kh_uint64_t_uint64_t_map_t *h); extern khint_t kh_get_uint64_t_uint64_t_map(const kh_uint64_t_uint64_t_map_t *h, uint64_t key); extern void kh_resize_uint64_t_uint64_t_map(kh_uint64_t_uint64_t_map_t *h, khint_t new_n_buckets); extern khint_t kh_put_uint64_t_uint64_t_map(kh_uint64_t_uint64_t_map_t *h, uint64_t key, int *ret); extern void kh_del_uint64_t_uint64_t_map(kh_uint64_t_uint64_t_map_t *h, khint_t x); typedef struct { kh_uint64_t_uint64_t_map_t *table; } Map_uint64_t_uint64_t; Map_uint64_t_uint64_t *map_uint64_t_uint64_t_new(void); void map_uint64_t_uint64_t_free(Map_uint64_t_uint64_t *map); uint64_t map_uint64_t_uint64_t_get(Map_uint64_t_uint64_t *map, uint64_t key); 
# 42 "/home/toto/.env/encours/neovim/src/nvim/map.h" 3 4
_Bool 
# 42 "/home/toto/.env/encours/neovim/src/nvim/map.h"
map_uint64_t_uint64_t_has(Map_uint64_t_uint64_t *map, uint64_t key); uint64_t map_uint64_t_uint64_t_key(Map_uint64_t_uint64_t *map, uint64_t key); uint64_t map_uint64_t_uint64_t_put(Map_uint64_t_uint64_t *map, uint64_t key, uint64_t value); uint64_t *map_uint64_t_uint64_t_ref(Map_uint64_t_uint64_t *map, uint64_t key, 
# 42 "/home/toto/.env/encours/neovim/src/nvim/map.h" 3 4
_Bool 
# 42 "/home/toto/.env/encours/neovim/src/nvim/map.h"
put); uint64_t map_uint64_t_uint64_t_del(Map_uint64_t_uint64_t *map, uint64_t key); void map_uint64_t_uint64_t_clear(Map_uint64_t_uint64_t *map);



typedef struct ExtmarkNs {
  Map_uint64_t_uint64_t *map;
  uint64_t free_id;
} ExtmarkNs;

typedef struct { khint_t n_buckets, size, n_occupied, upper_bound; khint32_t *flags; uint64_t *keys; ExtmarkNs *vals; } kh_uint64_t_ExtmarkNs_map_t; extern kh_uint64_t_ExtmarkNs_map_t *kh_init_uint64_t_ExtmarkNs_map(void); extern void kh_dealloc_uint64_t_ExtmarkNs_map(kh_uint64_t_ExtmarkNs_map_t *h); extern void kh_destroy_uint64_t_ExtmarkNs_map(kh_uint64_t_ExtmarkNs_map_t *h); extern void kh_clear_uint64_t_ExtmarkNs_map(kh_uint64_t_ExtmarkNs_map_t *h); extern khint_t kh_get_uint64_t_ExtmarkNs_map(const kh_uint64_t_ExtmarkNs_map_t *h, uint64_t key); extern void kh_resize_uint64_t_ExtmarkNs_map(kh_uint64_t_ExtmarkNs_map_t *h, khint_t new_n_buckets); extern khint_t kh_put_uint64_t_ExtmarkNs_map(kh_uint64_t_ExtmarkNs_map_t *h, uint64_t key, int *ret); extern void kh_del_uint64_t_ExtmarkNs_map(kh_uint64_t_ExtmarkNs_map_t *h, khint_t x); typedef struct { kh_uint64_t_ExtmarkNs_map_t *table; } Map_uint64_t_ExtmarkNs; Map_uint64_t_ExtmarkNs *map_uint64_t_ExtmarkNs_new(void); void map_uint64_t_ExtmarkNs_free(Map_uint64_t_ExtmarkNs *map); ExtmarkNs map_uint64_t_ExtmarkNs_get(Map_uint64_t_ExtmarkNs *map, uint64_t key); 
# 51 "/home/toto/.env/encours/neovim/src/nvim/map.h" 3 4
_Bool 
# 51 "/home/toto/.env/encours/neovim/src/nvim/map.h"
map_uint64_t_ExtmarkNs_has(Map_uint64_t_ExtmarkNs *map, uint64_t key); uint64_t map_uint64_t_ExtmarkNs_key(Map_uint64_t_ExtmarkNs *map, uint64_t key); ExtmarkNs map_uint64_t_ExtmarkNs_put(Map_uint64_t_ExtmarkNs *map, uint64_t key, ExtmarkNs value); ExtmarkNs *map_uint64_t_ExtmarkNs_ref(Map_uint64_t_ExtmarkNs *map, uint64_t key, 
# 51 "/home/toto/.env/encours/neovim/src/nvim/map.h" 3 4
_Bool 
# 51 "/home/toto/.env/encours/neovim/src/nvim/map.h"
put); ExtmarkNs map_uint64_t_ExtmarkNs_del(Map_uint64_t_ExtmarkNs *map, uint64_t key); void map_uint64_t_ExtmarkNs_clear(Map_uint64_t_ExtmarkNs *map);
typedef struct { khint_t n_buckets, size, n_occupied, upper_bound; khint32_t *flags; uint64_t *keys; ExtmarkItem *vals; } kh_uint64_t_ExtmarkItem_map_t; extern kh_uint64_t_ExtmarkItem_map_t *kh_init_uint64_t_ExtmarkItem_map(void); extern void kh_dealloc_uint64_t_ExtmarkItem_map(kh_uint64_t_ExtmarkItem_map_t *h); extern void kh_destroy_uint64_t_ExtmarkItem_map(kh_uint64_t_ExtmarkItem_map_t *h); extern void kh_clear_uint64_t_ExtmarkItem_map(kh_uint64_t_ExtmarkItem_map_t *h); extern khint_t kh_get_uint64_t_ExtmarkItem_map(const kh_uint64_t_ExtmarkItem_map_t *h, uint64_t key); extern void kh_resize_uint64_t_ExtmarkItem_map(kh_uint64_t_ExtmarkItem_map_t *h, khint_t new_n_buckets); extern khint_t kh_put_uint64_t_ExtmarkItem_map(kh_uint64_t_ExtmarkItem_map_t *h, uint64_t key, int *ret); extern void kh_del_uint64_t_ExtmarkItem_map(kh_uint64_t_ExtmarkItem_map_t *h, khint_t x); typedef struct { kh_uint64_t_ExtmarkItem_map_t *table; } Map_uint64_t_ExtmarkItem; Map_uint64_t_ExtmarkItem *map_uint64_t_ExtmarkItem_new(void); void map_uint64_t_ExtmarkItem_free(Map_uint64_t_ExtmarkItem *map); ExtmarkItem map_uint64_t_ExtmarkItem_get(Map_uint64_t_ExtmarkItem *map, uint64_t key); 
# 52 "/home/toto/.env/encours/neovim/src/nvim/map.h" 3 4
_Bool 
# 52 "/home/toto/.env/encours/neovim/src/nvim/map.h"
map_uint64_t_ExtmarkItem_has(Map_uint64_t_ExtmarkItem *map, uint64_t key); uint64_t map_uint64_t_ExtmarkItem_key(Map_uint64_t_ExtmarkItem *map, uint64_t key); ExtmarkItem map_uint64_t_ExtmarkItem_put(Map_uint64_t_ExtmarkItem *map, uint64_t key, ExtmarkItem value); ExtmarkItem *map_uint64_t_ExtmarkItem_ref(Map_uint64_t_ExtmarkItem *map, uint64_t key, 
# 52 "/home/toto/.env/encours/neovim/src/nvim/map.h" 3 4
_Bool 
# 52 "/home/toto/.env/encours/neovim/src/nvim/map.h"
put); ExtmarkItem map_uint64_t_ExtmarkItem_del(Map_uint64_t_ExtmarkItem *map, uint64_t key); void map_uint64_t_ExtmarkItem_clear(Map_uint64_t_ExtmarkItem *map);
typedef struct { khint_t n_buckets, size, n_occupied, upper_bound; khint32_t *flags; handle_T *keys; ptr_t *vals; } kh_handle_T_ptr_t_map_t; extern kh_handle_T_ptr_t_map_t *kh_init_handle_T_ptr_t_map(void); extern void kh_dealloc_handle_T_ptr_t_map(kh_handle_T_ptr_t_map_t *h); extern void kh_destroy_handle_T_ptr_t_map(kh_handle_T_ptr_t_map_t *h); extern void kh_clear_handle_T_ptr_t_map(kh_handle_T_ptr_t_map_t *h); extern khint_t kh_get_handle_T_ptr_t_map(const kh_handle_T_ptr_t_map_t *h, handle_T key); extern void kh_resize_handle_T_ptr_t_map(kh_handle_T_ptr_t_map_t *h, khint_t new_n_buckets); extern khint_t kh_put_handle_T_ptr_t_map(kh_handle_T_ptr_t_map_t *h, handle_T key, int *ret); extern void kh_del_handle_T_ptr_t_map(kh_handle_T_ptr_t_map_t *h, khint_t x); typedef struct { kh_handle_T_ptr_t_map_t *table; } Map_handle_T_ptr_t; Map_handle_T_ptr_t *map_handle_T_ptr_t_new(void); void map_handle_T_ptr_t_free(Map_handle_T_ptr_t *map); ptr_t map_handle_T_ptr_t_get(Map_handle_T_ptr_t *map, handle_T key); 
# 53 "/home/toto/.env/encours/neovim/src/nvim/map.h" 3 4
_Bool 
# 53 "/home/toto/.env/encours/neovim/src/nvim/map.h"
map_handle_T_ptr_t_has(Map_handle_T_ptr_t *map, handle_T key); handle_T map_handle_T_ptr_t_key(Map_handle_T_ptr_t *map, handle_T key); ptr_t map_handle_T_ptr_t_put(Map_handle_T_ptr_t *map, handle_T key, ptr_t value); ptr_t *map_handle_T_ptr_t_ref(Map_handle_T_ptr_t *map, handle_T key, 
# 53 "/home/toto/.env/encours/neovim/src/nvim/map.h" 3 4
_Bool 
# 53 "/home/toto/.env/encours/neovim/src/nvim/map.h"
put); ptr_t map_handle_T_ptr_t_del(Map_handle_T_ptr_t *map, handle_T key); void map_handle_T_ptr_t_clear(Map_handle_T_ptr_t *map);
typedef struct { khint_t n_buckets, size, n_occupied, upper_bound; khint32_t *flags; String *keys; MsgpackRpcRequestHandler *vals; } kh_String_MsgpackRpcRequestHandler_map_t; extern kh_String_MsgpackRpcRequestHandler_map_t *kh_init_String_MsgpackRpcRequestHandler_map(void); extern void kh_dealloc_String_MsgpackRpcRequestHandler_map(kh_String_MsgpackRpcRequestHandler_map_t *h); extern void kh_destroy_String_MsgpackRpcRequestHandler_map(kh_String_MsgpackRpcRequestHandler_map_t *h); extern void kh_clear_String_MsgpackRpcRequestHandler_map(kh_String_MsgpackRpcRequestHandler_map_t *h); extern khint_t kh_get_String_MsgpackRpcRequestHandler_map(const kh_String_MsgpackRpcRequestHandler_map_t *h, String key); extern void kh_resize_String_MsgpackRpcRequestHandler_map(kh_String_MsgpackRpcRequestHandler_map_t *h, khint_t new_n_buckets); extern khint_t kh_put_String_MsgpackRpcRequestHandler_map(kh_String_MsgpackRpcRequestHandler_map_t *h, String key, int *ret); extern void kh_del_String_MsgpackRpcRequestHandler_map(kh_String_MsgpackRpcRequestHandler_map_t *h, khint_t x); typedef struct { kh_String_MsgpackRpcRequestHandler_map_t *table; } Map_String_MsgpackRpcRequestHandler; Map_String_MsgpackRpcRequestHandler *map_String_MsgpackRpcRequestHandler_new(void); void map_String_MsgpackRpcRequestHandler_free(Map_String_MsgpackRpcRequestHandler *map); MsgpackRpcRequestHandler map_String_MsgpackRpcRequestHandler_get(Map_String_MsgpackRpcRequestHandler *map, String key); 
# 54 "/home/toto/.env/encours/neovim/src/nvim/map.h" 3 4
_Bool 
# 54 "/home/toto/.env/encours/neovim/src/nvim/map.h"
map_String_MsgpackRpcRequestHandler_has(Map_String_MsgpackRpcRequestHandler *map, String key); String map_String_MsgpackRpcRequestHandler_key(Map_String_MsgpackRpcRequestHandler *map, String key); MsgpackRpcRequestHandler map_String_MsgpackRpcRequestHandler_put(Map_String_MsgpackRpcRequestHandler *map, String key, MsgpackRpcRequestHandler value); MsgpackRpcRequestHandler *map_String_MsgpackRpcRequestHandler_ref(Map_String_MsgpackRpcRequestHandler *map, String key, 
# 54 "/home/toto/.env/encours/neovim/src/nvim/map.h" 3 4
_Bool 
# 54 "/home/toto/.env/encours/neovim/src/nvim/map.h"
put); MsgpackRpcRequestHandler map_String_MsgpackRpcRequestHandler_del(Map_String_MsgpackRpcRequestHandler *map, String key); void map_String_MsgpackRpcRequestHandler_clear(Map_String_MsgpackRpcRequestHandler *map);
typedef struct { khint_t n_buckets, size, n_occupied, upper_bound; khint32_t *flags; HlEntry *keys; int *vals; } kh_HlEntry_int_map_t; extern kh_HlEntry_int_map_t *kh_init_HlEntry_int_map(void); extern void kh_dealloc_HlEntry_int_map(kh_HlEntry_int_map_t *h); extern void kh_destroy_HlEntry_int_map(kh_HlEntry_int_map_t *h); extern void kh_clear_HlEntry_int_map(kh_HlEntry_int_map_t *h); extern khint_t kh_get_HlEntry_int_map(const kh_HlEntry_int_map_t *h, HlEntry key); extern void kh_resize_HlEntry_int_map(kh_HlEntry_int_map_t *h, khint_t new_n_buckets); extern khint_t kh_put_HlEntry_int_map(kh_HlEntry_int_map_t *h, HlEntry key, int *ret); extern void kh_del_HlEntry_int_map(kh_HlEntry_int_map_t *h, khint_t x); typedef struct { kh_HlEntry_int_map_t *table; } Map_HlEntry_int; Map_HlEntry_int *map_HlEntry_int_new(void); void map_HlEntry_int_free(Map_HlEntry_int *map); int map_HlEntry_int_get(Map_HlEntry_int *map, HlEntry key); 
# 55 "/home/toto/.env/encours/neovim/src/nvim/map.h" 3 4
_Bool 
# 55 "/home/toto/.env/encours/neovim/src/nvim/map.h"
map_HlEntry_int_has(Map_HlEntry_int *map, HlEntry key); HlEntry map_HlEntry_int_key(Map_HlEntry_int *map, HlEntry key); int map_HlEntry_int_put(Map_HlEntry_int *map, HlEntry key, int value); int *map_HlEntry_int_ref(Map_HlEntry_int *map, HlEntry key, 
# 55 "/home/toto/.env/encours/neovim/src/nvim/map.h" 3 4
_Bool 
# 55 "/home/toto/.env/encours/neovim/src/nvim/map.h"
put); int map_HlEntry_int_del(Map_HlEntry_int *map, HlEntry key); void map_HlEntry_int_clear(Map_HlEntry_int *map);
typedef struct { khint_t n_buckets, size, n_occupied, upper_bound; khint32_t *flags; String *keys; handle_T *vals; } kh_String_handle_T_map_t; extern kh_String_handle_T_map_t *kh_init_String_handle_T_map(void); extern void kh_dealloc_String_handle_T_map(kh_String_handle_T_map_t *h); extern void kh_destroy_String_handle_T_map(kh_String_handle_T_map_t *h); extern void kh_clear_String_handle_T_map(kh_String_handle_T_map_t *h); extern khint_t kh_get_String_handle_T_map(const kh_String_handle_T_map_t *h, String key); extern void kh_resize_String_handle_T_map(kh_String_handle_T_map_t *h, khint_t new_n_buckets); extern khint_t kh_put_String_handle_T_map(kh_String_handle_T_map_t *h, String key, int *ret); extern void kh_del_String_handle_T_map(kh_String_handle_T_map_t *h, khint_t x); typedef struct { kh_String_handle_T_map_t *table; } Map_String_handle_T; Map_String_handle_T *map_String_handle_T_new(void); void map_String_handle_T_free(Map_String_handle_T *map); handle_T map_String_handle_T_get(Map_String_handle_T *map, String key); 
# 56 "/home/toto/.env/encours/neovim/src/nvim/map.h" 3 4
_Bool 
# 56 "/home/toto/.env/encours/neovim/src/nvim/map.h"
map_String_handle_T_has(Map_String_handle_T *map, String key); String map_String_handle_T_key(Map_String_handle_T *map, String key); handle_T map_String_handle_T_put(Map_String_handle_T *map, String key, handle_T value); handle_T *map_String_handle_T_ref(Map_String_handle_T *map, String key, 
# 56 "/home/toto/.env/encours/neovim/src/nvim/map.h" 3 4
_Bool 
# 56 "/home/toto/.env/encours/neovim/src/nvim/map.h"
put); handle_T map_String_handle_T_del(Map_String_handle_T *map, String key); void map_String_handle_T_clear(Map_String_handle_T *map);
# 86 "/home/toto/.env/encours/neovim/src/nvim/map.h"
void pmap_del2(Map_cstr_t_ptr_t *map, const char *key);
# 43 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h" 2



# 1 "/home/toto/.env/encours/neovim/src/nvim/marktree.h" 1
# 11 "/home/toto/.env/encours/neovim/src/nvim/marktree.h"
typedef struct {
  int32_t row;
  int32_t col;
} mtpos_t;

typedef struct {
  int32_t row;
  int32_t col;
  uint64_t id;
  
# 20 "/home/toto/.env/encours/neovim/src/nvim/marktree.h" 3 4
 _Bool 
# 20 "/home/toto/.env/encours/neovim/src/nvim/marktree.h"
      right_gravity;
} mtmark_t;

typedef struct mtnode_s mtnode_t;
typedef struct {
  int oldcol;
  int i;
} iterstate_t;

typedef struct {
  mtpos_t pos;
  int lvl;
  mtnode_t *node;
  int i;
  iterstate_t s[20];
} MarkTreeIter;






typedef struct {
  mtpos_t pos;
  uint64_t id;
} mtkey_t;

struct mtnode_s {
  int32_t n;
  int32_t level;


  mtnode_t *parent;
  mtkey_t key[2 * 10 - 1];
  mtnode_t *ptr[];
};



typedef struct {
  mtnode_t *root;
  size_t n_keys, n_nodes;
  uint64_t next_id;


  Map_uint64_t_ptr_t *id2node;
} MarkTree;
# 47 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h" 2
# 98 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h"
typedef struct window_S win_T;
typedef struct wininfo_S wininfo_T;
typedef struct frame_S frame_T;
typedef uint16_t disptick_T;


# 1 "/home/toto/.env/encours/neovim/src/nvim/memline_defs.h" 1



# 1 "/home/toto/.env/encours/neovim/src/nvim/memfile_defs.h" 1
# 16 "/home/toto/.env/encours/neovim/src/nvim/memfile_defs.h"
typedef int64_t blocknr_T;
# 25 "/home/toto/.env/encours/neovim/src/nvim/memfile_defs.h"
typedef struct mf_hashitem {
  struct mf_hashitem *mhi_next;
  struct mf_hashitem *mhi_prev;
  blocknr_T mhi_key;
} mf_hashitem_T;
# 40 "/home/toto/.env/encours/neovim/src/nvim/memfile_defs.h"
typedef struct mf_hashtab {
  size_t mht_mask;

  size_t mht_count;
  mf_hashitem_T **mht_buckets;


  mf_hashitem_T *mht_small_buckets[64];
} mf_hashtab_T;
# 63 "/home/toto/.env/encours/neovim/src/nvim/memfile_defs.h"
typedef struct bhdr {
  mf_hashitem_T bh_hashitem;


  struct bhdr *bh_next;
  struct bhdr *bh_prev;
  void *bh_data;
  unsigned bh_page_count;



  unsigned bh_flags;
} bhdr_T;







typedef struct mf_blocknr_trans_item {
  mf_hashitem_T nt_hashitem;

  blocknr_T nt_new_bnum;
} mf_blocknr_trans_item_T;


typedef struct memfile {
  char_u *mf_fname;
  char_u *mf_ffname;
  int mf_fd;
  bhdr_T *mf_free_first;
  bhdr_T *mf_used_first;
  bhdr_T *mf_used_last;
  mf_hashtab_T mf_hash;
  mf_hashtab_T mf_trans;
  blocknr_T mf_blocknr_max;
  blocknr_T mf_blocknr_min;
  blocknr_T mf_neg_count;
  blocknr_T mf_infile_count;
  unsigned mf_page_size;
  
# 104 "/home/toto/.env/encours/neovim/src/nvim/memfile_defs.h" 3 4
 _Bool 
# 104 "/home/toto/.env/encours/neovim/src/nvim/memfile_defs.h"
      mf_dirty;
} memfile_T;
# 5 "/home/toto/.env/encours/neovim/src/nvim/memline_defs.h" 2






typedef struct info_pointer {
  blocknr_T ip_bnum;
  linenr_T ip_low;
  linenr_T ip_high;
  int ip_index;
} infoptr_T;

typedef struct ml_chunksize {
  int mlcs_numlines;
  long mlcs_totalsize;
} chunksize_T;
# 43 "/home/toto/.env/encours/neovim/src/nvim/memline_defs.h"
typedef struct memline {
  linenr_T ml_line_count;

  memfile_T *ml_mfp;





  int ml_flags;

  infoptr_T *ml_stack;
  int ml_stack_top;
  int ml_stack_size;

  linenr_T ml_line_lnum;
  char_u *ml_line_ptr;

  bhdr_T *ml_locked;
  linenr_T ml_locked_low;
  linenr_T ml_locked_high;
  int ml_locked_lineadd;
  chunksize_T *ml_chunksize;
  int ml_numchunks;
  int ml_usedchunks;
} memline_T;
# 105 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h" 2




# 1 "/home/toto/.env/encours/neovim/src/nvim/regexp_defs.h" 1
# 45 "/home/toto/.env/encours/neovim/src/nvim/regexp_defs.h"
typedef struct regengine regengine_T;
typedef struct regprog regprog_T;
typedef struct reg_extmatch reg_extmatch_T;







typedef struct {
  regprog_T *regprog;
  lpos_T startpos[10];
  lpos_T endpos[10];
  int rmm_ic;
  colnr_T rmm_maxcol;
} regmmatch_T;
# 70 "/home/toto/.env/encours/neovim/src/nvim/regexp_defs.h"
struct regprog {
  regengine_T *engine;
  unsigned regflags;
  unsigned re_engine;
  unsigned re_flags;
};






typedef struct {

  regengine_T *engine;
  unsigned regflags;
  unsigned re_engine;
  unsigned re_flags;

  int regstart;
  char_u reganch;
  char_u *regmust;
  int regmlen;
  char_u reghasz;
  char_u program[1];
} bt_regprog_T;



typedef struct nfa_state nfa_state_T;
struct nfa_state {
  int c;
  nfa_state_T *out;
  nfa_state_T *out1;
  int id;
  int lastlist[2];
  int val;
};




typedef struct {

  regengine_T *engine;
  unsigned regflags;
  unsigned re_engine;
  unsigned re_flags;

  nfa_state_T *start;

  int reganch;
  int regstart;
  char_u *match_text;

  int has_zend;
  int has_backref;
  int reghasz;
  char_u *pattern;
  int nsubexp;
  int nstate;
  nfa_state_T state[1];
} nfa_regprog_T;






typedef struct {
  regprog_T *regprog;
  char_u *startp[10];
  char_u *endp[10];
  
# 143 "/home/toto/.env/encours/neovim/src/nvim/regexp_defs.h" 3 4
 _Bool 
# 143 "/home/toto/.env/encours/neovim/src/nvim/regexp_defs.h"
                      rm_ic;
} regmatch_T;






struct reg_extmatch {
  int16_t refcnt;
  char_u *matches[10];
};

struct regengine {
  regprog_T *(*regcomp)(char_u *, int);
  void (*regfree)(regprog_T *);
  int (*regexec_nl)(regmatch_T *, char_u *, colnr_T, 
# 159 "/home/toto/.env/encours/neovim/src/nvim/regexp_defs.h" 3 4
                                                    _Bool
# 159 "/home/toto/.env/encours/neovim/src/nvim/regexp_defs.h"
                                                        );
  long (*regexec_multi)(regmmatch_T *, win_T *, buf_T *, linenr_T, colnr_T,
                        proftime_T *, int *);
  char_u *expr;
};
# 110 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h" 2

# 1 "/home/toto/.env/encours/neovim/src/nvim/syntax_defs.h" 1
# 12 "/home/toto/.env/encours/neovim/src/nvim/syntax_defs.h"
typedef struct syn_state synstate_T;





struct sp_syn {
  int inc_tag;
  int16_t id;
  int16_t *cont_in_list;
};




typedef struct keyentry keyentry_T;

struct keyentry {
  keyentry_T *ke_next;
  struct sp_syn k_syn;
  int16_t *next_list;
  int flags;
  int k_char;
  char_u keyword[1];
};




typedef struct buf_state {
  int bs_idx;
  int bs_flags;
  int bs_seqnr;
  int bs_cchar;
  reg_extmatch_T *bs_extmatch;
} bufstate_T;





struct syn_state {
  synstate_T *sst_next;
  linenr_T sst_lnum;
  union {
    bufstate_T sst_stack[7];
    garray_T sst_ga;
  } sst_union;
  int sst_next_flags;
  int sst_stacksize;
  int16_t *sst_next_list;

  disptick_T sst_tick;
  linenr_T sst_change_lnum;

};
# 112 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h" 2

# 1 "/home/toto/.env/encours/neovim/src/nvim/sign_defs.h" 1
# 10 "/home/toto/.env/encours/neovim/src/nvim/sign_defs.h"
typedef struct signgroup_S
{
    uint16_t refcount;
    int next_sign_id;
    char_u sg_name[1];
} signgroup_T;





typedef struct signlist signlist_T;

struct signlist
{
    int id;
    linenr_T lnum;
    int typenr;
    signgroup_T *group;
    int priority;
    signlist_T *next;
    signlist_T *prev;
};





typedef enum {
  SIGN_ANY,
  SIGN_LINEHL,
  SIGN_ICON,
  SIGN_TEXT,
  SIGN_NUMHL,
} SignType;
# 114 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h" 2

# 1 "/home/toto/.env/encours/neovim/src/nvim/os/fs_defs.h" 1



# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 1
# 52 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/uv/errno.h" 1
# 53 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/uv/version.h" 1
# 54 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 2
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 55 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 2
# 66 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/uv/unix.h" 1
# 27 "/home/toto/.env/encours/neovim/.deps/usr/include/uv/unix.h"
# 1 "/usr/include/fcntl.h" 1 3 4
# 28 "/usr/include/fcntl.h" 3 4







# 1 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 3 4

# 35 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 3 4
struct flock
  {
    short int l_type;
    short int l_whence;

    __off_t l_start;
    __off_t l_len;




    __pid_t l_pid;
  };


struct flock64
  {
    short int l_type;
    short int l_whence;
    __off64_t l_start;
    __off64_t l_len;
    __pid_t l_pid;
  };



# 1 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 1 3 4
# 38 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_iovec.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/types/struct_iovec.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/types/struct_iovec.h" 2 3 4


struct iovec
  {
    void *iov_base;
    size_t iov_len;
  };
# 39 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 2 3 4
# 265 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
enum __pid_type
  {
    F_OWNER_TID = 0,
    F_OWNER_PID,
    F_OWNER_PGRP,
    F_OWNER_GID = F_OWNER_PGRP
  };


struct f_owner_ex
  {
    enum __pid_type type;
    __pid_t pid;
  };
# 346 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
# 1 "/usr/include/linux/falloc.h" 1 3 4
# 347 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 2 3 4



struct file_handle
{
  unsigned int handle_bytes;
  int handle_type;

  unsigned char f_handle[0];
};
# 380 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4





extern __ssize_t readahead (int __fd, __off64_t __offset, size_t __count)
    __attribute__ ((__nothrow__ , __leaf__));






extern int sync_file_range (int __fd, __off64_t __offset, __off64_t __count,
       unsigned int __flags);






extern __ssize_t vmsplice (int __fdout, const struct iovec *__iov,
      size_t __count, unsigned int __flags);





extern __ssize_t splice (int __fdin, __off64_t *__offin, int __fdout,
    __off64_t *__offout, size_t __len,
    unsigned int __flags);





extern __ssize_t tee (int __fdin, int __fdout, size_t __len,
        unsigned int __flags);






extern int fallocate (int __fd, int __mode, __off_t __offset, __off_t __len);
# 435 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
extern int fallocate64 (int __fd, int __mode, __off64_t __offset,
   __off64_t __len);




extern int name_to_handle_at (int __dfd, const char *__name,
         struct file_handle *__handle, int *__mnt_id,
         int __flags) __attribute__ ((__nothrow__ , __leaf__));





extern int open_by_handle_at (int __mountdirfd, struct file_handle *__handle,
         int __flags);




# 61 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 2 3 4
# 36 "/usr/include/fcntl.h" 2 3 4
# 78 "/usr/include/fcntl.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stat.h" 1 3 4
# 79 "/usr/include/fcntl.h" 2 3 4
# 147 "/usr/include/fcntl.h" 3 4
extern int fcntl (int __fd, int __cmd, ...);
# 157 "/usr/include/fcntl.h" 3 4
extern int open (const char *__file, int __oflag, ...) __attribute__ ((__nonnull__ (1)));
# 167 "/usr/include/fcntl.h" 3 4
extern int open64 (const char *__file, int __oflag, ...) __attribute__ ((__nonnull__ (1)));
# 181 "/usr/include/fcntl.h" 3 4
extern int openat (int __fd, const char *__file, int __oflag, ...)
     __attribute__ ((__nonnull__ (2)));
# 192 "/usr/include/fcntl.h" 3 4
extern int openat64 (int __fd, const char *__file, int __oflag, ...)
     __attribute__ ((__nonnull__ (2)));
# 203 "/usr/include/fcntl.h" 3 4
extern int creat (const char *__file, mode_t __mode) __attribute__ ((__nonnull__ (1)));
# 213 "/usr/include/fcntl.h" 3 4
extern int creat64 (const char *__file, mode_t __mode) __attribute__ ((__nonnull__ (1)));
# 249 "/usr/include/fcntl.h" 3 4
extern int posix_fadvise (int __fd, off_t __offset, off_t __len,
     int __advise) __attribute__ ((__nothrow__ , __leaf__));
# 261 "/usr/include/fcntl.h" 3 4
extern int posix_fadvise64 (int __fd, off64_t __offset, off64_t __len,
       int __advise) __attribute__ ((__nothrow__ , __leaf__));
# 271 "/usr/include/fcntl.h" 3 4
extern int posix_fallocate (int __fd, off_t __offset, off_t __len);
# 282 "/usr/include/fcntl.h" 3 4
extern int posix_fallocate64 (int __fd, off64_t __offset, off64_t __len);
# 293 "/usr/include/fcntl.h" 3 4

# 28 "/home/toto/.env/encours/neovim/.deps/usr/include/uv/unix.h" 2
# 1 "/usr/include/dirent.h" 1 3 4
# 27 "/usr/include/dirent.h" 3 4

# 61 "/usr/include/dirent.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/dirent.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h" 3 4
struct dirent
  {

    __ino_t d_ino;
    __off_t d_off;




    unsigned short int d_reclen;
    unsigned char d_type;
    char d_name[256];
  };


struct dirent64
  {
    __ino64_t d_ino;
    __off64_t d_off;
    unsigned short int d_reclen;
    unsigned char d_type;
    char d_name[256];
  };
# 62 "/usr/include/dirent.h" 2 3 4
# 97 "/usr/include/dirent.h" 3 4
enum
  {
    DT_UNKNOWN = 0,

    DT_FIFO = 1,

    DT_CHR = 2,

    DT_DIR = 4,

    DT_BLK = 6,

    DT_REG = 8,

    DT_LNK = 10,

    DT_SOCK = 12,

    DT_WHT = 14

  };
# 127 "/usr/include/dirent.h" 3 4
typedef struct __dirstream DIR;






extern DIR *opendir (const char *__name) __attribute__ ((__nonnull__ (1)));






extern DIR *fdopendir (int __fd);







extern int closedir (DIR *__dirp) __attribute__ ((__nonnull__ (1)));
# 162 "/usr/include/dirent.h" 3 4
extern struct dirent *readdir (DIR *__dirp) __attribute__ ((__nonnull__ (1)));
# 173 "/usr/include/dirent.h" 3 4
extern struct dirent64 *readdir64 (DIR *__dirp) __attribute__ ((__nonnull__ (1)));
# 183 "/usr/include/dirent.h" 3 4
extern int readdir_r (DIR *__restrict __dirp,
        struct dirent *__restrict __entry,
        struct dirent **__restrict __result)
     __attribute__ ((__nonnull__ (1, 2, 3))) __attribute__ ((__deprecated__));
# 201 "/usr/include/dirent.h" 3 4
extern int readdir64_r (DIR *__restrict __dirp,
   struct dirent64 *__restrict __entry,
   struct dirent64 **__restrict __result)
  __attribute__ ((__nonnull__ (1, 2, 3))) __attribute__ ((__deprecated__));




extern void rewinddir (DIR *__dirp) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern void seekdir (DIR *__dirp, long int __pos) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int telldir (DIR *__dirp) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int dirfd (DIR *__dirp) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 245 "/usr/include/dirent.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 246 "/usr/include/dirent.h" 2 3 4
# 255 "/usr/include/dirent.h" 3 4
extern int scandir (const char *__restrict __dir,
      struct dirent ***__restrict __namelist,
      int (*__selector) (const struct dirent *),
      int (*__cmp) (const struct dirent **,
      const struct dirent **))
     __attribute__ ((__nonnull__ (1, 2)));
# 278 "/usr/include/dirent.h" 3 4
extern int scandir64 (const char *__restrict __dir,
        struct dirent64 ***__restrict __namelist,
        int (*__selector) (const struct dirent64 *),
        int (*__cmp) (const struct dirent64 **,
        const struct dirent64 **))
     __attribute__ ((__nonnull__ (1, 2)));
# 293 "/usr/include/dirent.h" 3 4
extern int scandirat (int __dfd, const char *__restrict __dir,
        struct dirent ***__restrict __namelist,
        int (*__selector) (const struct dirent *),
        int (*__cmp) (const struct dirent **,
        const struct dirent **))
     __attribute__ ((__nonnull__ (2, 3)));
# 315 "/usr/include/dirent.h" 3 4
extern int scandirat64 (int __dfd, const char *__restrict __dir,
   struct dirent64 ***__restrict __namelist,
   int (*__selector) (const struct dirent64 *),
   int (*__cmp) (const struct dirent64 **,
          const struct dirent64 **))
     __attribute__ ((__nonnull__ (2, 3)));




extern int alphasort (const struct dirent **__e1,
        const struct dirent **__e2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 340 "/usr/include/dirent.h" 3 4
extern int alphasort64 (const struct dirent64 **__e1,
   const struct dirent64 **__e2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 353 "/usr/include/dirent.h" 3 4
extern __ssize_t getdirentries (int __fd, char *__restrict __buf,
    size_t __nbytes,
    __off_t *__restrict __basep)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));
# 370 "/usr/include/dirent.h" 3 4
extern __ssize_t getdirentries64 (int __fd, char *__restrict __buf,
      size_t __nbytes,
      __off64_t *__restrict __basep)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));






extern int versionsort (const struct dirent **__e1,
   const struct dirent **__e2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 396 "/usr/include/dirent.h" 3 4
extern int versionsort64 (const struct dirent64 **__e1,
     const struct dirent64 **__e2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));




# 29 "/home/toto/.env/encours/neovim/.deps/usr/include/uv/unix.h" 2

# 1 "/usr/include/x86_64-linux-gnu/sys/socket.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/sys/socket.h" 3 4




# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 29 "/usr/include/x86_64-linux-gnu/sys/socket.h" 2 3 4




# 1 "/usr/include/x86_64-linux-gnu/bits/socket.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/socket.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/socket.h" 2 3 4
# 38 "/usr/include/x86_64-linux-gnu/bits/socket.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/socket_type.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/socket_type.h" 3 4
enum __socket_type
{
  SOCK_STREAM = 1,


  SOCK_DGRAM = 2,


  SOCK_RAW = 3,

  SOCK_RDM = 4,

  SOCK_SEQPACKET = 5,


  SOCK_DCCP = 6,

  SOCK_PACKET = 10,







  SOCK_CLOEXEC = 02000000,


  SOCK_NONBLOCK = 00004000


};
# 39 "/usr/include/x86_64-linux-gnu/bits/socket.h" 2 3 4
# 172 "/usr/include/x86_64-linux-gnu/bits/socket.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h" 3 4
typedef unsigned short int sa_family_t;
# 173 "/usr/include/x86_64-linux-gnu/bits/socket.h" 2 3 4


struct sockaddr
  {
    sa_family_t sa_family;
    char sa_data[14];
  };
# 188 "/usr/include/x86_64-linux-gnu/bits/socket.h" 3 4
struct sockaddr_storage
  {
    sa_family_t ss_family;
    char __ss_padding[(128 - (sizeof (unsigned short int)) - sizeof (unsigned long int))];
    unsigned long int __ss_align;
  };



enum
  {
    MSG_OOB = 0x01,

    MSG_PEEK = 0x02,

    MSG_DONTROUTE = 0x04,



    MSG_TRYHARD = MSG_DONTROUTE,


    MSG_CTRUNC = 0x08,

    MSG_PROXY = 0x10,

    MSG_TRUNC = 0x20,

    MSG_DONTWAIT = 0x40,

    MSG_EOR = 0x80,

    MSG_WAITALL = 0x100,

    MSG_FIN = 0x200,

    MSG_SYN = 0x400,

    MSG_CONFIRM = 0x800,

    MSG_RST = 0x1000,

    MSG_ERRQUEUE = 0x2000,

    MSG_NOSIGNAL = 0x4000,

    MSG_MORE = 0x8000,

    MSG_WAITFORONE = 0x10000,

    MSG_BATCH = 0x40000,

    MSG_ZEROCOPY = 0x4000000,

    MSG_FASTOPEN = 0x20000000,


    MSG_CMSG_CLOEXEC = 0x40000000



  };




struct msghdr
  {
    void *msg_name;
    socklen_t msg_namelen;

    struct iovec *msg_iov;
    size_t msg_iovlen;

    void *msg_control;
    size_t msg_controllen;




    int msg_flags;
  };


struct cmsghdr
  {
    size_t cmsg_len;




    int cmsg_level;
    int cmsg_type;

    __extension__ unsigned char __cmsg_data [];

  };
# 302 "/usr/include/x86_64-linux-gnu/bits/socket.h" 3 4
extern struct cmsghdr *__cmsg_nxthdr (struct msghdr *__mhdr,
          struct cmsghdr *__cmsg) __attribute__ ((__nothrow__ , __leaf__));
# 329 "/usr/include/x86_64-linux-gnu/bits/socket.h" 3 4
enum
  {
    SCM_RIGHTS = 0x01


    , SCM_CREDENTIALS = 0x02


  };



struct ucred
{
  pid_t pid;
  uid_t uid;
  gid_t gid;
};
# 390 "/usr/include/x86_64-linux-gnu/bits/socket.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/socket.h" 1 3 4
# 1 "/usr/include/asm-generic/socket.h" 1 3 4




# 1 "/usr/include/x86_64-linux-gnu/asm/sockios.h" 1 3 4
# 1 "/usr/include/asm-generic/sockios.h" 1 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/sockios.h" 2 3 4
# 6 "/usr/include/asm-generic/socket.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/socket.h" 2 3 4
# 391 "/usr/include/x86_64-linux-gnu/bits/socket.h" 2 3 4
# 444 "/usr/include/x86_64-linux-gnu/bits/socket.h" 3 4
struct linger
  {
    int l_onoff;
    int l_linger;
  };
# 34 "/usr/include/x86_64-linux-gnu/sys/socket.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_osockaddr.h" 1 3 4





struct osockaddr
{
  unsigned short int sa_family;
  unsigned char sa_data[14];
};
# 37 "/usr/include/x86_64-linux-gnu/sys/socket.h" 2 3 4




enum
{
  SHUT_RD = 0,

  SHUT_WR,

  SHUT_RDWR

};
# 79 "/usr/include/x86_64-linux-gnu/sys/socket.h" 3 4
typedef union { struct sockaddr *__restrict __sockaddr__; struct sockaddr_at *__restrict __sockaddr_at__; struct sockaddr_ax25 *__restrict __sockaddr_ax25__; struct sockaddr_dl *__restrict __sockaddr_dl__; struct sockaddr_eon *__restrict __sockaddr_eon__; struct sockaddr_in *__restrict __sockaddr_in__; struct sockaddr_in6 *__restrict __sockaddr_in6__; struct sockaddr_inarp *__restrict __sockaddr_inarp__; struct sockaddr_ipx *__restrict __sockaddr_ipx__; struct sockaddr_iso *__restrict __sockaddr_iso__; struct sockaddr_ns *__restrict __sockaddr_ns__; struct sockaddr_un *__restrict __sockaddr_un__; struct sockaddr_x25 *__restrict __sockaddr_x25__;
       } __SOCKADDR_ARG __attribute__ ((__transparent_union__));


typedef union { const struct sockaddr *__restrict __sockaddr__; const struct sockaddr_at *__restrict __sockaddr_at__; const struct sockaddr_ax25 *__restrict __sockaddr_ax25__; const struct sockaddr_dl *__restrict __sockaddr_dl__; const struct sockaddr_eon *__restrict __sockaddr_eon__; const struct sockaddr_in *__restrict __sockaddr_in__; const struct sockaddr_in6 *__restrict __sockaddr_in6__; const struct sockaddr_inarp *__restrict __sockaddr_inarp__; const struct sockaddr_ipx *__restrict __sockaddr_ipx__; const struct sockaddr_iso *__restrict __sockaddr_iso__; const struct sockaddr_ns *__restrict __sockaddr_ns__; const struct sockaddr_un *__restrict __sockaddr_un__; const struct sockaddr_x25 *__restrict __sockaddr_x25__;
       } __CONST_SOCKADDR_ARG __attribute__ ((__transparent_union__));





struct mmsghdr
  {
    struct msghdr msg_hdr;
    unsigned int msg_len;

  };






extern int socket (int __domain, int __type, int __protocol) __attribute__ ((__nothrow__ , __leaf__));





extern int socketpair (int __domain, int __type, int __protocol,
         int __fds[2]) __attribute__ ((__nothrow__ , __leaf__));


extern int bind (int __fd, __CONST_SOCKADDR_ARG __addr, socklen_t __len)
     __attribute__ ((__nothrow__ , __leaf__));


extern int getsockname (int __fd, __SOCKADDR_ARG __addr,
   socklen_t *__restrict __len) __attribute__ ((__nothrow__ , __leaf__));
# 126 "/usr/include/x86_64-linux-gnu/sys/socket.h" 3 4
extern int connect (int __fd, __CONST_SOCKADDR_ARG __addr, socklen_t __len);



extern int getpeername (int __fd, __SOCKADDR_ARG __addr,
   socklen_t *__restrict __len) __attribute__ ((__nothrow__ , __leaf__));






extern ssize_t send (int __fd, const void *__buf, size_t __n, int __flags);






extern ssize_t recv (int __fd, void *__buf, size_t __n, int __flags);






extern ssize_t sendto (int __fd, const void *__buf, size_t __n,
         int __flags, __CONST_SOCKADDR_ARG __addr,
         socklen_t __addr_len);
# 163 "/usr/include/x86_64-linux-gnu/sys/socket.h" 3 4
extern ssize_t recvfrom (int __fd, void *__restrict __buf, size_t __n,
    int __flags, __SOCKADDR_ARG __addr,
    socklen_t *__restrict __addr_len);







extern ssize_t sendmsg (int __fd, const struct msghdr *__message,
   int __flags);







extern int sendmmsg (int __fd, struct mmsghdr *__vmessages,
       unsigned int __vlen, int __flags);







extern ssize_t recvmsg (int __fd, struct msghdr *__message, int __flags);







extern int recvmmsg (int __fd, struct mmsghdr *__vmessages,
       unsigned int __vlen, int __flags,
       struct timespec *__tmo);






extern int getsockopt (int __fd, int __level, int __optname,
         void *__restrict __optval,
         socklen_t *__restrict __optlen) __attribute__ ((__nothrow__ , __leaf__));




extern int setsockopt (int __fd, int __level, int __optname,
         const void *__optval, socklen_t __optlen) __attribute__ ((__nothrow__ , __leaf__));





extern int listen (int __fd, int __n) __attribute__ ((__nothrow__ , __leaf__));
# 232 "/usr/include/x86_64-linux-gnu/sys/socket.h" 3 4
extern int accept (int __fd, __SOCKADDR_ARG __addr,
     socklen_t *__restrict __addr_len);






extern int accept4 (int __fd, __SOCKADDR_ARG __addr,
      socklen_t *__restrict __addr_len, int __flags);
# 250 "/usr/include/x86_64-linux-gnu/sys/socket.h" 3 4
extern int shutdown (int __fd, int __how) __attribute__ ((__nothrow__ , __leaf__));




extern int sockatmark (int __fd) __attribute__ ((__nothrow__ , __leaf__));







extern int isfdtype (int __fd, int __fdtype) __attribute__ ((__nothrow__ , __leaf__));
# 272 "/usr/include/x86_64-linux-gnu/sys/socket.h" 3 4

# 31 "/home/toto/.env/encours/neovim/.deps/usr/include/uv/unix.h" 2
# 1 "/usr/include/netinet/in.h" 1 3 4
# 27 "/usr/include/netinet/in.h" 3 4



typedef uint32_t in_addr_t;
struct in_addr
  {
    in_addr_t s_addr;
  };


# 1 "/usr/include/x86_64-linux-gnu/bits/in.h" 1 3 4
# 142 "/usr/include/x86_64-linux-gnu/bits/in.h" 3 4
struct ip_opts
  {
    struct in_addr ip_dst;
    char ip_opts[40];
  };


struct ip_mreqn
  {
    struct in_addr imr_multiaddr;
    struct in_addr imr_address;
    int imr_ifindex;
  };


struct in_pktinfo
  {
    int ipi_ifindex;
    struct in_addr ipi_spec_dst;
    struct in_addr ipi_addr;
  };
# 38 "/usr/include/netinet/in.h" 2 3 4


enum
  {
    IPPROTO_IP = 0,

    IPPROTO_ICMP = 1,

    IPPROTO_IGMP = 2,

    IPPROTO_IPIP = 4,

    IPPROTO_TCP = 6,

    IPPROTO_EGP = 8,

    IPPROTO_PUP = 12,

    IPPROTO_UDP = 17,

    IPPROTO_IDP = 22,

    IPPROTO_TP = 29,

    IPPROTO_DCCP = 33,

    IPPROTO_IPV6 = 41,

    IPPROTO_RSVP = 46,

    IPPROTO_GRE = 47,

    IPPROTO_ESP = 50,

    IPPROTO_AH = 51,

    IPPROTO_MTP = 92,

    IPPROTO_BEETPH = 94,

    IPPROTO_ENCAP = 98,

    IPPROTO_PIM = 103,

    IPPROTO_COMP = 108,

    IPPROTO_SCTP = 132,

    IPPROTO_UDPLITE = 136,

    IPPROTO_MPLS = 137,

    IPPROTO_RAW = 255,

    IPPROTO_MAX
  };





enum
  {
    IPPROTO_HOPOPTS = 0,

    IPPROTO_ROUTING = 43,

    IPPROTO_FRAGMENT = 44,

    IPPROTO_ICMPV6 = 58,

    IPPROTO_NONE = 59,

    IPPROTO_DSTOPTS = 60,

    IPPROTO_MH = 135

  };



typedef uint16_t in_port_t;


enum
  {
    IPPORT_ECHO = 7,
    IPPORT_DISCARD = 9,
    IPPORT_SYSTAT = 11,
    IPPORT_DAYTIME = 13,
    IPPORT_NETSTAT = 15,
    IPPORT_FTP = 21,
    IPPORT_TELNET = 23,
    IPPORT_SMTP = 25,
    IPPORT_TIMESERVER = 37,
    IPPORT_NAMESERVER = 42,
    IPPORT_WHOIS = 43,
    IPPORT_MTP = 57,

    IPPORT_TFTP = 69,
    IPPORT_RJE = 77,
    IPPORT_FINGER = 79,
    IPPORT_TTYLINK = 87,
    IPPORT_SUPDUP = 95,


    IPPORT_EXECSERVER = 512,
    IPPORT_LOGINSERVER = 513,
    IPPORT_CMDSERVER = 514,
    IPPORT_EFSSERVER = 520,


    IPPORT_BIFFUDP = 512,
    IPPORT_WHOSERVER = 513,
    IPPORT_ROUTESERVER = 520,


    IPPORT_RESERVED = 1024,


    IPPORT_USERRESERVED = 5000
  };
# 211 "/usr/include/netinet/in.h" 3 4
struct in6_addr
  {
    union
      {
 uint8_t __u6_addr8[16];
 uint16_t __u6_addr16[8];
 uint32_t __u6_addr32[4];
      } __in6_u;





  };


extern const struct in6_addr in6addr_any;
extern const struct in6_addr in6addr_loopback;
# 237 "/usr/include/netinet/in.h" 3 4
struct sockaddr_in
  {
    sa_family_t sin_family;
    in_port_t sin_port;
    struct in_addr sin_addr;


    unsigned char sin_zero[sizeof (struct sockaddr) -
      (sizeof (unsigned short int)) -
      sizeof (in_port_t) -
      sizeof (struct in_addr)];
  };



struct sockaddr_in6
  {
    sa_family_t sin6_family;
    in_port_t sin6_port;
    uint32_t sin6_flowinfo;
    struct in6_addr sin6_addr;
    uint32_t sin6_scope_id;
  };




struct ip_mreq
  {

    struct in_addr imr_multiaddr;


    struct in_addr imr_interface;
  };

struct ip_mreq_source
  {

    struct in_addr imr_multiaddr;


    struct in_addr imr_interface;


    struct in_addr imr_sourceaddr;
  };




struct ipv6_mreq
  {

    struct in6_addr ipv6mr_multiaddr;


    unsigned int ipv6mr_interface;
  };




struct group_req
  {

    uint32_t gr_interface;


    struct sockaddr_storage gr_group;
  };

struct group_source_req
  {

    uint32_t gsr_interface;


    struct sockaddr_storage gsr_group;


    struct sockaddr_storage gsr_source;
  };



struct ip_msfilter
  {

    struct in_addr imsf_multiaddr;


    struct in_addr imsf_interface;


    uint32_t imsf_fmode;


    uint32_t imsf_numsrc;

    struct in_addr imsf_slist[1];
  };





struct group_filter
  {

    uint32_t gf_interface;


    struct sockaddr_storage gf_group;


    uint32_t gf_fmode;


    uint32_t gf_numsrc;

    struct sockaddr_storage gf_slist[1];
};
# 374 "/usr/include/netinet/in.h" 3 4
extern uint32_t ntohl (uint32_t __netlong) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern uint16_t ntohs (uint16_t __netshort)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern uint32_t htonl (uint32_t __hostlong)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern uint16_t htons (uint16_t __hostshort)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 1 3 4
# 386 "/usr/include/netinet/in.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 1 3 4
# 387 "/usr/include/netinet/in.h" 2 3 4
# 502 "/usr/include/netinet/in.h" 3 4
extern int bindresvport (int __sockfd, struct sockaddr_in *__sock_in) __attribute__ ((__nothrow__ , __leaf__));


extern int bindresvport6 (int __sockfd, struct sockaddr_in6 *__sock_in)
     __attribute__ ((__nothrow__ , __leaf__));
# 532 "/usr/include/netinet/in.h" 3 4
struct cmsghdr;



struct in6_pktinfo
  {
    struct in6_addr ipi6_addr;
    unsigned int ipi6_ifindex;
  };


struct ip6_mtuinfo
  {
    struct sockaddr_in6 ip6m_addr;
    uint32_t ip6m_mtu;
  };



extern int inet6_option_space (int __nbytes)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));
extern int inet6_option_init (void *__bp, struct cmsghdr **__cmsgp,
         int __type) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));
extern int inet6_option_append (struct cmsghdr *__cmsg,
    const uint8_t *__typep, int __multx,
    int __plusy) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));
extern uint8_t *inet6_option_alloc (struct cmsghdr *__cmsg, int __datalen,
        int __multx, int __plusy)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));
extern int inet6_option_next (const struct cmsghdr *__cmsg,
         uint8_t **__tptrp)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));
extern int inet6_option_find (const struct cmsghdr *__cmsg,
         uint8_t **__tptrp, int __type)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));



extern int inet6_opt_init (void *__extbuf, socklen_t __extlen) __attribute__ ((__nothrow__ , __leaf__));
extern int inet6_opt_append (void *__extbuf, socklen_t __extlen, int __offset,
        uint8_t __type, socklen_t __len, uint8_t __align,
        void **__databufp) __attribute__ ((__nothrow__ , __leaf__));
extern int inet6_opt_finish (void *__extbuf, socklen_t __extlen, int __offset)
     __attribute__ ((__nothrow__ , __leaf__));
extern int inet6_opt_set_val (void *__databuf, int __offset, void *__val,
         socklen_t __vallen) __attribute__ ((__nothrow__ , __leaf__));
extern int inet6_opt_next (void *__extbuf, socklen_t __extlen, int __offset,
      uint8_t *__typep, socklen_t *__lenp,
      void **__databufp) __attribute__ ((__nothrow__ , __leaf__));
extern int inet6_opt_find (void *__extbuf, socklen_t __extlen, int __offset,
      uint8_t __type, socklen_t *__lenp,
      void **__databufp) __attribute__ ((__nothrow__ , __leaf__));
extern int inet6_opt_get_val (void *__databuf, int __offset, void *__val,
         socklen_t __vallen) __attribute__ ((__nothrow__ , __leaf__));



extern socklen_t inet6_rth_space (int __type, int __segments) __attribute__ ((__nothrow__ , __leaf__));
extern void *inet6_rth_init (void *__bp, socklen_t __bp_len, int __type,
        int __segments) __attribute__ ((__nothrow__ , __leaf__));
extern int inet6_rth_add (void *__bp, const struct in6_addr *__addr) __attribute__ ((__nothrow__ , __leaf__));
extern int inet6_rth_reverse (const void *__in, void *__out) __attribute__ ((__nothrow__ , __leaf__));
extern int inet6_rth_segments (const void *__bp) __attribute__ ((__nothrow__ , __leaf__));
extern struct in6_addr *inet6_rth_getaddr (const void *__bp, int __index)
     __attribute__ ((__nothrow__ , __leaf__));





extern int getipv4sourcefilter (int __s, struct in_addr __interface_addr,
    struct in_addr __group, uint32_t *__fmode,
    uint32_t *__numsrc, struct in_addr *__slist)
     __attribute__ ((__nothrow__ , __leaf__));


extern int setipv4sourcefilter (int __s, struct in_addr __interface_addr,
    struct in_addr __group, uint32_t __fmode,
    uint32_t __numsrc,
    const struct in_addr *__slist)
     __attribute__ ((__nothrow__ , __leaf__));



extern int getsourcefilter (int __s, uint32_t __interface_addr,
       const struct sockaddr *__group,
       socklen_t __grouplen, uint32_t *__fmode,
       uint32_t *__numsrc,
       struct sockaddr_storage *__slist) __attribute__ ((__nothrow__ , __leaf__));


extern int setsourcefilter (int __s, uint32_t __interface_addr,
       const struct sockaddr *__group,
       socklen_t __grouplen, uint32_t __fmode,
       uint32_t __numsrc,
       const struct sockaddr_storage *__slist) __attribute__ ((__nothrow__ , __leaf__));



# 32 "/home/toto/.env/encours/neovim/.deps/usr/include/uv/unix.h" 2
# 1 "/usr/include/netinet/tcp.h" 1 3 4
# 82 "/usr/include/netinet/tcp.h" 3 4
typedef uint32_t tcp_seq;




struct tcphdr
  {
    __extension__ union
    {
      struct
      {
 uint16_t th_sport;
 uint16_t th_dport;
 tcp_seq th_seq;
 tcp_seq th_ack;

 uint8_t th_x2:4;
 uint8_t th_off:4;





 uint8_t th_flags;






 uint16_t th_win;
 uint16_t th_sum;
 uint16_t th_urp;
      };
      struct
      {
 uint16_t source;
 uint16_t dest;
 uint32_t seq;
 uint32_t ack_seq;

 uint16_t res1:4;
 uint16_t doff:4;
 uint16_t fin:1;
 uint16_t syn:1;
 uint16_t rst:1;
 uint16_t psh:1;
 uint16_t ack:1;
 uint16_t urg:1;
 uint16_t res2:2;
# 145 "/usr/include/netinet/tcp.h" 3 4
 uint16_t window;
 uint16_t check;
 uint16_t urg_ptr;
      };
    };
};

enum
{
  TCP_ESTABLISHED = 1,
  TCP_SYN_SENT,
  TCP_SYN_RECV,
  TCP_FIN_WAIT1,
  TCP_FIN_WAIT2,
  TCP_TIME_WAIT,
  TCP_CLOSE,
  TCP_CLOSE_WAIT,
  TCP_LAST_ACK,
  TCP_LISTEN,
  TCP_CLOSING
};
# 206 "/usr/include/netinet/tcp.h" 3 4
enum tcp_ca_state
{
  TCP_CA_Open = 0,
  TCP_CA_Disorder = 1,
  TCP_CA_CWR = 2,
  TCP_CA_Recovery = 3,
  TCP_CA_Loss = 4
};

struct tcp_info
{
  uint8_t tcpi_state;
  uint8_t tcpi_ca_state;
  uint8_t tcpi_retransmits;
  uint8_t tcpi_probes;
  uint8_t tcpi_backoff;
  uint8_t tcpi_options;
  uint8_t tcpi_snd_wscale : 4, tcpi_rcv_wscale : 4;

  uint32_t tcpi_rto;
  uint32_t tcpi_ato;
  uint32_t tcpi_snd_mss;
  uint32_t tcpi_rcv_mss;

  uint32_t tcpi_unacked;
  uint32_t tcpi_sacked;
  uint32_t tcpi_lost;
  uint32_t tcpi_retrans;
  uint32_t tcpi_fackets;


  uint32_t tcpi_last_data_sent;
  uint32_t tcpi_last_ack_sent;
  uint32_t tcpi_last_data_recv;
  uint32_t tcpi_last_ack_recv;


  uint32_t tcpi_pmtu;
  uint32_t tcpi_rcv_ssthresh;
  uint32_t tcpi_rtt;
  uint32_t tcpi_rttvar;
  uint32_t tcpi_snd_ssthresh;
  uint32_t tcpi_snd_cwnd;
  uint32_t tcpi_advmss;
  uint32_t tcpi_reordering;

  uint32_t tcpi_rcv_rtt;
  uint32_t tcpi_rcv_space;

  uint32_t tcpi_total_retrans;
};
# 265 "/usr/include/netinet/tcp.h" 3 4
struct tcp_md5sig
{
  struct sockaddr_storage tcpm_addr;
  uint8_t tcpm_flags;
  uint8_t tcpm_prefixlen;
  uint16_t tcpm_keylen;
  uint32_t __tcpm_pad;
  uint8_t tcpm_key[80];
};


struct tcp_repair_opt
{
  uint32_t opt_code;
  uint32_t opt_val;
};


enum
{
  TCP_NO_QUEUE,
  TCP_RECV_QUEUE,
  TCP_SEND_QUEUE,
  TCP_QUEUES_NR,
};
# 308 "/usr/include/netinet/tcp.h" 3 4
struct tcp_cookie_transactions
{
  uint16_t tcpct_flags;
  uint8_t __tcpct_pad1;
  uint8_t tcpct_cookie_desired;
  uint16_t tcpct_s_data_desired;
  uint16_t tcpct_used;
  uint8_t tcpct_value[536U];
};


struct tcp_repair_window
{
  uint32_t snd_wl1;
  uint32_t snd_wnd;
  uint32_t max_window;
  uint32_t rcv_wnd;
  uint32_t rcv_wup;
};
# 33 "/home/toto/.env/encours/neovim/.deps/usr/include/uv/unix.h" 2
# 1 "/usr/include/arpa/inet.h" 1 3 4
# 30 "/usr/include/arpa/inet.h" 3 4




extern in_addr_t inet_addr (const char *__cp) __attribute__ ((__nothrow__ , __leaf__));


extern in_addr_t inet_lnaof (struct in_addr __in) __attribute__ ((__nothrow__ , __leaf__));



extern struct in_addr inet_makeaddr (in_addr_t __net, in_addr_t __host)
     __attribute__ ((__nothrow__ , __leaf__));


extern in_addr_t inet_netof (struct in_addr __in) __attribute__ ((__nothrow__ , __leaf__));



extern in_addr_t inet_network (const char *__cp) __attribute__ ((__nothrow__ , __leaf__));



extern char *inet_ntoa (struct in_addr __in) __attribute__ ((__nothrow__ , __leaf__));




extern int inet_pton (int __af, const char *__restrict __cp,
        void *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));




extern const char *inet_ntop (int __af, const void *__restrict __cp,
         char *__restrict __buf, socklen_t __len)
     __attribute__ ((__nothrow__ , __leaf__));






extern int inet_aton (const char *__cp, struct in_addr *__inp) __attribute__ ((__nothrow__ , __leaf__));



extern char *inet_neta (in_addr_t __net, char *__buf, size_t __len) __attribute__ ((__nothrow__ , __leaf__));




extern char *inet_net_ntop (int __af, const void *__cp, int __bits,
       char *__buf, size_t __len) __attribute__ ((__nothrow__ , __leaf__));




extern int inet_net_pton (int __af, const char *__cp,
     void *__buf, size_t __len) __attribute__ ((__nothrow__ , __leaf__));




extern unsigned int inet_nsap_addr (const char *__cp,
        unsigned char *__buf, int __len) __attribute__ ((__nothrow__ , __leaf__));



extern char *inet_nsap_ntoa (int __len, const unsigned char *__cp,
        char *__buf) __attribute__ ((__nothrow__ , __leaf__));



# 34 "/home/toto/.env/encours/neovim/.deps/usr/include/uv/unix.h" 2
# 1 "/usr/include/netdb.h" 1 3 4
# 32 "/usr/include/netdb.h" 3 4
# 1 "/usr/include/rpc/netdb.h" 1 3 4
# 42 "/usr/include/rpc/netdb.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 43 "/usr/include/rpc/netdb.h" 2 3 4



struct rpcent
{
  char *r_name;
  char **r_aliases;
  int r_number;
};

extern void setrpcent (int __stayopen) __attribute__ ((__nothrow__ , __leaf__));
extern void endrpcent (void) __attribute__ ((__nothrow__ , __leaf__));
extern struct rpcent *getrpcbyname (const char *__name) __attribute__ ((__nothrow__ , __leaf__));
extern struct rpcent *getrpcbynumber (int __number) __attribute__ ((__nothrow__ , __leaf__));
extern struct rpcent *getrpcent (void) __attribute__ ((__nothrow__ , __leaf__));


extern int getrpcbyname_r (const char *__name, struct rpcent *__result_buf,
      char *__buffer, size_t __buflen,
      struct rpcent **__result) __attribute__ ((__nothrow__ , __leaf__));

extern int getrpcbynumber_r (int __number, struct rpcent *__result_buf,
        char *__buffer, size_t __buflen,
        struct rpcent **__result) __attribute__ ((__nothrow__ , __leaf__));

extern int getrpcent_r (struct rpcent *__result_buf, char *__buffer,
   size_t __buflen, struct rpcent **__result) __attribute__ ((__nothrow__ , __leaf__));



# 33 "/usr/include/netdb.h" 2 3 4







# 1 "/usr/include/x86_64-linux-gnu/bits/netdb.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/netdb.h" 3 4
struct netent
{
  char *n_name;
  char **n_aliases;
  int n_addrtype;
  uint32_t n_net;
};
# 41 "/usr/include/netdb.h" 2 3 4
# 51 "/usr/include/netdb.h" 3 4








extern int *__h_errno_location (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 90 "/usr/include/netdb.h" 3 4
extern void herror (const char *__str) __attribute__ ((__nothrow__ , __leaf__));


extern const char *hstrerror (int __err_num) __attribute__ ((__nothrow__ , __leaf__));




struct hostent
{
  char *h_name;
  char **h_aliases;
  int h_addrtype;
  int h_length;
  char **h_addr_list;



};






extern void sethostent (int __stay_open);





extern void endhostent (void);






extern struct hostent *gethostent (void);






extern struct hostent *gethostbyaddr (const void *__addr, __socklen_t __len,
          int __type);





extern struct hostent *gethostbyname (const char *__name);
# 153 "/usr/include/netdb.h" 3 4
extern struct hostent *gethostbyname2 (const char *__name, int __af);
# 165 "/usr/include/netdb.h" 3 4
extern int gethostent_r (struct hostent *__restrict __result_buf,
    char *__restrict __buf, size_t __buflen,
    struct hostent **__restrict __result,
    int *__restrict __h_errnop);

extern int gethostbyaddr_r (const void *__restrict __addr, __socklen_t __len,
       int __type,
       struct hostent *__restrict __result_buf,
       char *__restrict __buf, size_t __buflen,
       struct hostent **__restrict __result,
       int *__restrict __h_errnop);

extern int gethostbyname_r (const char *__restrict __name,
       struct hostent *__restrict __result_buf,
       char *__restrict __buf, size_t __buflen,
       struct hostent **__restrict __result,
       int *__restrict __h_errnop);

extern int gethostbyname2_r (const char *__restrict __name, int __af,
        struct hostent *__restrict __result_buf,
        char *__restrict __buf, size_t __buflen,
        struct hostent **__restrict __result,
        int *__restrict __h_errnop);
# 196 "/usr/include/netdb.h" 3 4
extern void setnetent (int __stay_open);





extern void endnetent (void);






extern struct netent *getnetent (void);






extern struct netent *getnetbyaddr (uint32_t __net, int __type);





extern struct netent *getnetbyname (const char *__name);
# 235 "/usr/include/netdb.h" 3 4
extern int getnetent_r (struct netent *__restrict __result_buf,
   char *__restrict __buf, size_t __buflen,
   struct netent **__restrict __result,
   int *__restrict __h_errnop);

extern int getnetbyaddr_r (uint32_t __net, int __type,
      struct netent *__restrict __result_buf,
      char *__restrict __buf, size_t __buflen,
      struct netent **__restrict __result,
      int *__restrict __h_errnop);

extern int getnetbyname_r (const char *__restrict __name,
      struct netent *__restrict __result_buf,
      char *__restrict __buf, size_t __buflen,
      struct netent **__restrict __result,
      int *__restrict __h_errnop);




struct servent
{
  char *s_name;
  char **s_aliases;
  int s_port;
  char *s_proto;
};






extern void setservent (int __stay_open);





extern void endservent (void);






extern struct servent *getservent (void);






extern struct servent *getservbyname (const char *__name, const char *__proto);






extern struct servent *getservbyport (int __port, const char *__proto);
# 306 "/usr/include/netdb.h" 3 4
extern int getservent_r (struct servent *__restrict __result_buf,
    char *__restrict __buf, size_t __buflen,
    struct servent **__restrict __result);

extern int getservbyname_r (const char *__restrict __name,
       const char *__restrict __proto,
       struct servent *__restrict __result_buf,
       char *__restrict __buf, size_t __buflen,
       struct servent **__restrict __result);

extern int getservbyport_r (int __port, const char *__restrict __proto,
       struct servent *__restrict __result_buf,
       char *__restrict __buf, size_t __buflen,
       struct servent **__restrict __result);




struct protoent
{
  char *p_name;
  char **p_aliases;
  int p_proto;
};






extern void setprotoent (int __stay_open);





extern void endprotoent (void);






extern struct protoent *getprotoent (void);





extern struct protoent *getprotobyname (const char *__name);





extern struct protoent *getprotobynumber (int __proto);
# 372 "/usr/include/netdb.h" 3 4
extern int getprotoent_r (struct protoent *__restrict __result_buf,
     char *__restrict __buf, size_t __buflen,
     struct protoent **__restrict __result);

extern int getprotobyname_r (const char *__restrict __name,
        struct protoent *__restrict __result_buf,
        char *__restrict __buf, size_t __buflen,
        struct protoent **__restrict __result);

extern int getprotobynumber_r (int __proto,
          struct protoent *__restrict __result_buf,
          char *__restrict __buf, size_t __buflen,
          struct protoent **__restrict __result);
# 393 "/usr/include/netdb.h" 3 4
extern int setnetgrent (const char *__netgroup);







extern void endnetgrent (void);
# 410 "/usr/include/netdb.h" 3 4
extern int getnetgrent (char **__restrict __hostp,
   char **__restrict __userp,
   char **__restrict __domainp);
# 421 "/usr/include/netdb.h" 3 4
extern int innetgr (const char *__netgroup, const char *__host,
      const char *__user, const char *__domain);







extern int getnetgrent_r (char **__restrict __hostp,
     char **__restrict __userp,
     char **__restrict __domainp,
     char *__restrict __buffer, size_t __buflen);
# 449 "/usr/include/netdb.h" 3 4
extern int rcmd (char **__restrict __ahost, unsigned short int __rport,
   const char *__restrict __locuser,
   const char *__restrict __remuser,
   const char *__restrict __cmd, int *__restrict __fd2p);
# 461 "/usr/include/netdb.h" 3 4
extern int rcmd_af (char **__restrict __ahost, unsigned short int __rport,
      const char *__restrict __locuser,
      const char *__restrict __remuser,
      const char *__restrict __cmd, int *__restrict __fd2p,
      sa_family_t __af);
# 477 "/usr/include/netdb.h" 3 4
extern int rexec (char **__restrict __ahost, int __rport,
    const char *__restrict __name,
    const char *__restrict __pass,
    const char *__restrict __cmd, int *__restrict __fd2p);
# 489 "/usr/include/netdb.h" 3 4
extern int rexec_af (char **__restrict __ahost, int __rport,
       const char *__restrict __name,
       const char *__restrict __pass,
       const char *__restrict __cmd, int *__restrict __fd2p,
       sa_family_t __af);
# 503 "/usr/include/netdb.h" 3 4
extern int ruserok (const char *__rhost, int __suser,
      const char *__remuser, const char *__locuser);
# 513 "/usr/include/netdb.h" 3 4
extern int ruserok_af (const char *__rhost, int __suser,
         const char *__remuser, const char *__locuser,
         sa_family_t __af);
# 526 "/usr/include/netdb.h" 3 4
extern int iruserok (uint32_t __raddr, int __suser,
       const char *__remuser, const char *__locuser);
# 537 "/usr/include/netdb.h" 3 4
extern int iruserok_af (const void *__raddr, int __suser,
   const char *__remuser, const char *__locuser,
   sa_family_t __af);
# 549 "/usr/include/netdb.h" 3 4
extern int rresvport (int *__alport);
# 558 "/usr/include/netdb.h" 3 4
extern int rresvport_af (int *__alport, sa_family_t __af);






struct addrinfo
{
  int ai_flags;
  int ai_family;
  int ai_socktype;
  int ai_protocol;
  socklen_t ai_addrlen;
  struct sockaddr *ai_addr;
  char *ai_canonname;
  struct addrinfo *ai_next;
};



struct gaicb
{
  const char *ar_name;
  const char *ar_service;
  const struct addrinfo *ar_request;
  struct addrinfo *ar_result;

  int __return;
  int __glibc_reserved[5];
};
# 660 "/usr/include/netdb.h" 3 4
extern int getaddrinfo (const char *__restrict __name,
   const char *__restrict __service,
   const struct addrinfo *__restrict __req,
   struct addrinfo **__restrict __pai);


extern void freeaddrinfo (struct addrinfo *__ai) __attribute__ ((__nothrow__ , __leaf__));


extern const char *gai_strerror (int __ecode) __attribute__ ((__nothrow__ , __leaf__));





extern int getnameinfo (const struct sockaddr *__restrict __sa,
   socklen_t __salen, char *__restrict __host,
   socklen_t __hostlen, char *__restrict __serv,
   socklen_t __servlen, int __flags);
# 690 "/usr/include/netdb.h" 3 4
extern int getaddrinfo_a (int __mode, struct gaicb *__list[__restrict],
     int __ent, struct sigevent *__restrict __sig);
# 701 "/usr/include/netdb.h" 3 4
extern int gai_suspend (const struct gaicb *const __list[], int __ent,
   const struct timespec *__timeout);


extern int gai_error (struct gaicb *__req) __attribute__ ((__nothrow__ , __leaf__));


extern int gai_cancel (struct gaicb *__gaicbp) __attribute__ ((__nothrow__ , __leaf__));



# 35 "/home/toto/.env/encours/neovim/.deps/usr/include/uv/unix.h" 2

# 1 "/usr/include/termios.h" 1 3 4
# 35 "/usr/include/termios.h" 3 4




# 1 "/usr/include/x86_64-linux-gnu/bits/termios.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/termios.h" 3 4
typedef unsigned char cc_t;
typedef unsigned int speed_t;
typedef unsigned int tcflag_t;


struct termios
  {
    tcflag_t c_iflag;
    tcflag_t c_oflag;
    tcflag_t c_cflag;
    tcflag_t c_lflag;
    cc_t c_line;
    cc_t c_cc[32];
    speed_t c_ispeed;
    speed_t c_ospeed;


  };
# 40 "/usr/include/termios.h" 2 3 4
# 48 "/usr/include/termios.h" 3 4
extern speed_t cfgetospeed (const struct termios *__termios_p) __attribute__ ((__nothrow__ , __leaf__));


extern speed_t cfgetispeed (const struct termios *__termios_p) __attribute__ ((__nothrow__ , __leaf__));


extern int cfsetospeed (struct termios *__termios_p, speed_t __speed) __attribute__ ((__nothrow__ , __leaf__));


extern int cfsetispeed (struct termios *__termios_p, speed_t __speed) __attribute__ ((__nothrow__ , __leaf__));



extern int cfsetspeed (struct termios *__termios_p, speed_t __speed) __attribute__ ((__nothrow__ , __leaf__));




extern int tcgetattr (int __fd, struct termios *__termios_p) __attribute__ ((__nothrow__ , __leaf__));



extern int tcsetattr (int __fd, int __optional_actions,
        const struct termios *__termios_p) __attribute__ ((__nothrow__ , __leaf__));




extern void cfmakeraw (struct termios *__termios_p) __attribute__ ((__nothrow__ , __leaf__));



extern int tcsendbreak (int __fd, int __duration) __attribute__ ((__nothrow__ , __leaf__));





extern int tcdrain (int __fd);



extern int tcflush (int __fd, int __queue_selector) __attribute__ ((__nothrow__ , __leaf__));



extern int tcflow (int __fd, int __action) __attribute__ ((__nothrow__ , __leaf__));




extern __pid_t tcgetsid (int __fd) __attribute__ ((__nothrow__ , __leaf__));




# 1 "/usr/include/x86_64-linux-gnu/sys/ttydefaults.h" 1 3 4
# 105 "/usr/include/termios.h" 2 3 4



# 37 "/home/toto/.env/encours/neovim/.deps/usr/include/uv/unix.h" 2
# 1 "/usr/include/pwd.h" 1 3 4
# 27 "/usr/include/pwd.h" 3 4





# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 33 "/usr/include/pwd.h" 2 3 4
# 49 "/usr/include/pwd.h" 3 4
struct passwd
{
  char *pw_name;
  char *pw_passwd;
  __uid_t pw_uid;
  __gid_t pw_gid;
  char *pw_gecos;
  char *pw_dir;
  char *pw_shell;
};
# 71 "/usr/include/pwd.h" 3 4
extern void setpwent (void);





extern void endpwent (void);





extern struct passwd *getpwent (void);
# 93 "/usr/include/pwd.h" 3 4
extern struct passwd *fgetpwent (FILE *__stream) __attribute__ ((__nonnull__ (1)));







extern int putpwent (const struct passwd *__restrict __p,
       FILE *__restrict __f);






extern struct passwd *getpwuid (__uid_t __uid);





extern struct passwd *getpwnam (const char *__name) __attribute__ ((__nonnull__ (1)));
# 138 "/usr/include/pwd.h" 3 4
extern int getpwent_r (struct passwd *__restrict __resultbuf,
         char *__restrict __buffer, size_t __buflen,
         struct passwd **__restrict __result)
         __attribute__ ((__nonnull__ (1, 2, 4)));


extern int getpwuid_r (__uid_t __uid,
         struct passwd *__restrict __resultbuf,
         char *__restrict __buffer, size_t __buflen,
         struct passwd **__restrict __result)
         __attribute__ ((__nonnull__ (2, 3, 5)));

extern int getpwnam_r (const char *__restrict __name,
         struct passwd *__restrict __resultbuf,
         char *__restrict __buffer, size_t __buflen,
         struct passwd **__restrict __result)
         __attribute__ ((__nonnull__ (1, 2, 3, 5)));
# 165 "/usr/include/pwd.h" 3 4
extern int fgetpwent_r (FILE *__restrict __stream,
   struct passwd *__restrict __resultbuf,
   char *__restrict __buffer, size_t __buflen,
   struct passwd **__restrict __result)
   __attribute__ ((__nonnull__ (1, 2, 3, 5)));
# 183 "/usr/include/pwd.h" 3 4
extern int getpw (__uid_t __uid, char *__buffer);



# 38 "/home/toto/.env/encours/neovim/.deps/usr/include/uv/unix.h" 2


# 1 "/usr/include/semaphore.h" 1 3 4
# 28 "/usr/include/semaphore.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/semaphore.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/semaphore.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/semaphore.h" 2 3 4
# 36 "/usr/include/x86_64-linux-gnu/bits/semaphore.h" 3 4
typedef union
{
  char __size[32];
  long int __align;
} sem_t;
# 29 "/usr/include/semaphore.h" 2 3 4






extern int sem_init (sem_t *__sem, int __pshared, unsigned int __value)
     __attribute__ ((__nothrow__ , __leaf__));

extern int sem_destroy (sem_t *__sem) __attribute__ ((__nothrow__ , __leaf__));


extern sem_t *sem_open (const char *__name, int __oflag, ...) __attribute__ ((__nothrow__ , __leaf__));


extern int sem_close (sem_t *__sem) __attribute__ ((__nothrow__ , __leaf__));


extern int sem_unlink (const char *__name) __attribute__ ((__nothrow__ , __leaf__));





extern int sem_wait (sem_t *__sem);






extern int sem_timedwait (sem_t *__restrict __sem,
     const struct timespec *__restrict __abstime);



extern int sem_trywait (sem_t *__sem) __attribute__ ((__nothrow__));


extern int sem_post (sem_t *__sem) __attribute__ ((__nothrow__));


extern int sem_getvalue (sem_t *__restrict __sem, int *__restrict __sval)
     __attribute__ ((__nothrow__ , __leaf__));



# 41 "/home/toto/.env/encours/neovim/.deps/usr/include/uv/unix.h" 2


# 1 "/usr/include/pthread.h" 1 3 4
# 23 "/usr/include/pthread.h" 3 4
# 1 "/usr/include/sched.h" 1 3 4
# 29 "/usr/include/sched.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 30 "/usr/include/sched.h" 2 3 4
# 43 "/usr/include/sched.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/sched.h" 1 3 4
# 75 "/usr/include/x86_64-linux-gnu/bits/sched.h" 3 4
struct sched_param
{
  int sched_priority;
};





extern int clone (int (*__fn) (void *__arg), void *__child_stack,
    int __flags, void *__arg, ...) __attribute__ ((__nothrow__ , __leaf__));


extern int unshare (int __flags) __attribute__ ((__nothrow__ , __leaf__));


extern int sched_getcpu (void) __attribute__ ((__nothrow__ , __leaf__));


extern int setns (int __fd, int __nstype) __attribute__ ((__nothrow__ , __leaf__));



# 44 "/usr/include/sched.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h" 1 3 4
# 32 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h" 3 4
typedef unsigned long int __cpu_mask;






typedef struct
{
  __cpu_mask __bits[1024 / (8 * sizeof (__cpu_mask))];
} cpu_set_t;
# 115 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h" 3 4


extern int __sched_cpucount (size_t __setsize, const cpu_set_t *__setp)
     __attribute__ ((__nothrow__ , __leaf__));
extern cpu_set_t *__sched_cpualloc (size_t __count) __attribute__ ((__nothrow__ , __leaf__)) ;
extern void __sched_cpufree (cpu_set_t *__set) __attribute__ ((__nothrow__ , __leaf__));


# 45 "/usr/include/sched.h" 2 3 4









extern int sched_setparam (__pid_t __pid, const struct sched_param *__param)
     __attribute__ ((__nothrow__ , __leaf__));


extern int sched_getparam (__pid_t __pid, struct sched_param *__param) __attribute__ ((__nothrow__ , __leaf__));


extern int sched_setscheduler (__pid_t __pid, int __policy,
          const struct sched_param *__param) __attribute__ ((__nothrow__ , __leaf__));


extern int sched_getscheduler (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));


extern int sched_yield (void) __attribute__ ((__nothrow__ , __leaf__));


extern int sched_get_priority_max (int __algorithm) __attribute__ ((__nothrow__ , __leaf__));


extern int sched_get_priority_min (int __algorithm) __attribute__ ((__nothrow__ , __leaf__));


extern int sched_rr_get_interval (__pid_t __pid, struct timespec *__t) __attribute__ ((__nothrow__ , __leaf__));
# 121 "/usr/include/sched.h" 3 4
extern int sched_setaffinity (__pid_t __pid, size_t __cpusetsize,
         const cpu_set_t *__cpuset) __attribute__ ((__nothrow__ , __leaf__));


extern int sched_getaffinity (__pid_t __pid, size_t __cpusetsize,
         cpu_set_t *__cpuset) __attribute__ ((__nothrow__ , __leaf__));



# 24 "/usr/include/pthread.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 2 3 4




typedef long int __jmp_buf[8];
# 28 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 29 "/usr/include/pthread.h" 2 3 4




enum
{
  PTHREAD_CREATE_JOINABLE,

  PTHREAD_CREATE_DETACHED

};



enum
{
  PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_ADAPTIVE_NP

  ,
  PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL



  , PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_TIMED_NP

};




enum
{
  PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_STALLED_NP = PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_ROBUST,
  PTHREAD_MUTEX_ROBUST_NP = PTHREAD_MUTEX_ROBUST
};





enum
{
  PTHREAD_PRIO_NONE,
  PTHREAD_PRIO_INHERIT,
  PTHREAD_PRIO_PROTECT
};
# 115 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_RWLOCK_PREFER_READER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,
  PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP
};
# 156 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_INHERIT_SCHED,

  PTHREAD_EXPLICIT_SCHED

};



enum
{
  PTHREAD_SCOPE_SYSTEM,

  PTHREAD_SCOPE_PROCESS

};



enum
{
  PTHREAD_PROCESS_PRIVATE,

  PTHREAD_PROCESS_SHARED

};
# 191 "/usr/include/pthread.h" 3 4
struct _pthread_cleanup_buffer
{
  void (*__routine) (void *);
  void *__arg;
  int __canceltype;
  struct _pthread_cleanup_buffer *__prev;
};


enum
{
  PTHREAD_CANCEL_ENABLE,

  PTHREAD_CANCEL_DISABLE

};
enum
{
  PTHREAD_CANCEL_DEFERRED,

  PTHREAD_CANCEL_ASYNCHRONOUS

};
# 229 "/usr/include/pthread.h" 3 4





extern int pthread_create (pthread_t *__restrict __newthread,
      const pthread_attr_t *__restrict __attr,
      void *(*__start_routine) (void *),
      void *__restrict __arg) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 3)));





extern void pthread_exit (void *__retval) __attribute__ ((__noreturn__));







extern int pthread_join (pthread_t __th, void **__thread_return);




extern int pthread_tryjoin_np (pthread_t __th, void **__thread_return) __attribute__ ((__nothrow__ , __leaf__));







extern int pthread_timedjoin_np (pthread_t __th, void **__thread_return,
     const struct timespec *__abstime);






extern int pthread_detach (pthread_t __th) __attribute__ ((__nothrow__ , __leaf__));



extern pthread_t pthread_self (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int pthread_equal (pthread_t __thread1, pthread_t __thread2)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));







extern int pthread_attr_init (pthread_attr_t *__attr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_destroy (pthread_attr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getdetachstate (const pthread_attr_t *__attr,
     int *__detachstate)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setdetachstate (pthread_attr_t *__attr,
     int __detachstate)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getguardsize (const pthread_attr_t *__attr,
          size_t *__guardsize)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setguardsize (pthread_attr_t *__attr,
          size_t __guardsize)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getschedparam (const pthread_attr_t *__restrict __attr,
           struct sched_param *__restrict __param)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedparam (pthread_attr_t *__restrict __attr,
           const struct sched_param *__restrict
           __param) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_getschedpolicy (const pthread_attr_t *__restrict
     __attr, int *__restrict __policy)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedpolicy (pthread_attr_t *__attr, int __policy)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getinheritsched (const pthread_attr_t *__restrict
      __attr, int *__restrict __inherit)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setinheritsched (pthread_attr_t *__attr,
      int __inherit)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getscope (const pthread_attr_t *__restrict __attr,
      int *__restrict __scope)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setscope (pthread_attr_t *__attr, int __scope)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getstackaddr (const pthread_attr_t *__restrict
          __attr, void **__restrict __stackaddr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__deprecated__));





extern int pthread_attr_setstackaddr (pthread_attr_t *__attr,
          void *__stackaddr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__));


extern int pthread_attr_getstacksize (const pthread_attr_t *__restrict
          __attr, size_t *__restrict __stacksize)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_attr_setstacksize (pthread_attr_t *__attr,
          size_t __stacksize)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getstack (const pthread_attr_t *__restrict __attr,
      void **__restrict __stackaddr,
      size_t *__restrict __stacksize)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_attr_setstack (pthread_attr_t *__attr, void *__stackaddr,
      size_t __stacksize) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int pthread_attr_setaffinity_np (pthread_attr_t *__attr,
     size_t __cpusetsize,
     const cpu_set_t *__cpuset)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));



extern int pthread_attr_getaffinity_np (const pthread_attr_t *__attr,
     size_t __cpusetsize,
     cpu_set_t *__cpuset)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));


extern int pthread_getattr_default_np (pthread_attr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_setattr_default_np (const pthread_attr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




extern int pthread_getattr_np (pthread_t __th, pthread_attr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));







extern int pthread_setschedparam (pthread_t __target_thread, int __policy,
      const struct sched_param *__param)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));


extern int pthread_getschedparam (pthread_t __target_thread,
      int *__restrict __policy,
      struct sched_param *__restrict __param)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));


extern int pthread_setschedprio (pthread_t __target_thread, int __prio)
     __attribute__ ((__nothrow__ , __leaf__));




extern int pthread_getname_np (pthread_t __target_thread, char *__buf,
          size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));


extern int pthread_setname_np (pthread_t __target_thread, const char *__name)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));





extern int pthread_getconcurrency (void) __attribute__ ((__nothrow__ , __leaf__));


extern int pthread_setconcurrency (int __level) __attribute__ ((__nothrow__ , __leaf__));







extern int pthread_yield (void) __attribute__ ((__nothrow__ , __leaf__));




extern int pthread_setaffinity_np (pthread_t __th, size_t __cpusetsize,
       const cpu_set_t *__cpuset)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));


extern int pthread_getaffinity_np (pthread_t __th, size_t __cpusetsize,
       cpu_set_t *__cpuset)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));
# 495 "/usr/include/pthread.h" 3 4
extern int pthread_once (pthread_once_t *__once_control,
    void (*__init_routine) (void)) __attribute__ ((__nonnull__ (1, 2)));
# 507 "/usr/include/pthread.h" 3 4
extern int pthread_setcancelstate (int __state, int *__oldstate);



extern int pthread_setcanceltype (int __type, int *__oldtype);


extern int pthread_cancel (pthread_t __th);




extern void pthread_testcancel (void);




typedef struct
{
  struct
  {
    __jmp_buf __cancel_jmp_buf;
    int __mask_was_saved;
  } __cancel_jmp_buf[1];
  void *__pad[4];
} __pthread_unwind_buf_t __attribute__ ((__aligned__));
# 541 "/usr/include/pthread.h" 3 4
struct __pthread_cleanup_frame
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;
};
# 681 "/usr/include/pthread.h" 3 4
extern void __pthread_register_cancel (__pthread_unwind_buf_t *__buf)
     ;
# 693 "/usr/include/pthread.h" 3 4
extern void __pthread_unregister_cancel (__pthread_unwind_buf_t *__buf)
  ;
# 716 "/usr/include/pthread.h" 3 4
extern void __pthread_register_cancel_defer (__pthread_unwind_buf_t *__buf)
     ;
# 729 "/usr/include/pthread.h" 3 4
extern void __pthread_unregister_cancel_restore (__pthread_unwind_buf_t *__buf)
  ;



extern void __pthread_unwind_next (__pthread_unwind_buf_t *__buf)
     __attribute__ ((__noreturn__))

     __attribute__ ((__weak__))

     ;



struct __jmp_buf_tag;
extern int __sigsetjmp (struct __jmp_buf_tag *__env, int __savemask) __attribute__ ((__nothrow__));





extern int pthread_mutex_init (pthread_mutex_t *__mutex,
          const pthread_mutexattr_t *__mutexattr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_destroy (pthread_mutex_t *__mutex)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_trylock (pthread_mutex_t *__mutex)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_lock (pthread_mutex_t *__mutex)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_timedlock (pthread_mutex_t *__restrict __mutex,
        const struct timespec *__restrict
        __abstime) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_unlock (pthread_mutex_t *__mutex)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_getprioceiling (const pthread_mutex_t *
      __restrict __mutex,
      int *__restrict __prioceiling)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_setprioceiling (pthread_mutex_t *__restrict __mutex,
      int __prioceiling,
      int *__restrict __old_ceiling)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));




extern int pthread_mutex_consistent (pthread_mutex_t *__mutex)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern int pthread_mutex_consistent_np (pthread_mutex_t *__mutex)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 807 "/usr/include/pthread.h" 3 4
extern int pthread_mutexattr_init (pthread_mutexattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_destroy (pthread_mutexattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getpshared (const pthread_mutexattr_t *
      __restrict __attr,
      int *__restrict __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setpshared (pthread_mutexattr_t *__attr,
      int __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_gettype (const pthread_mutexattr_t *__restrict
          __attr, int *__restrict __kind)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_mutexattr_settype (pthread_mutexattr_t *__attr, int __kind)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getprotocol (const pthread_mutexattr_t *
       __restrict __attr,
       int *__restrict __protocol)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setprotocol (pthread_mutexattr_t *__attr,
       int __protocol)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getprioceiling (const pthread_mutexattr_t *
          __restrict __attr,
          int *__restrict __prioceiling)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setprioceiling (pthread_mutexattr_t *__attr,
          int __prioceiling)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getrobust (const pthread_mutexattr_t *__attr,
     int *__robustness)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int pthread_mutexattr_getrobust_np (const pthread_mutexattr_t *__attr,
        int *__robustness)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setrobust (pthread_mutexattr_t *__attr,
     int __robustness)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern int pthread_mutexattr_setrobust_np (pthread_mutexattr_t *__attr,
        int __robustness)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 889 "/usr/include/pthread.h" 3 4
extern int pthread_rwlock_init (pthread_rwlock_t *__restrict __rwlock,
    const pthread_rwlockattr_t *__restrict
    __attr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_destroy (pthread_rwlock_t *__rwlock)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_rdlock (pthread_rwlock_t *__rwlock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_tryrdlock (pthread_rwlock_t *__rwlock)
  __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedrdlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_wrlock (pthread_rwlock_t *__rwlock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_trywrlock (pthread_rwlock_t *__rwlock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedwrlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_unlock (pthread_rwlock_t *__rwlock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));





extern int pthread_rwlockattr_init (pthread_rwlockattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_destroy (pthread_rwlockattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getpshared (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setpshared (pthread_rwlockattr_t *__attr,
       int __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getkind_np (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pref)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setkind_np (pthread_rwlockattr_t *__attr,
       int __pref) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







extern int pthread_cond_init (pthread_cond_t *__restrict __cond,
         const pthread_condattr_t *__restrict __cond_attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_destroy (pthread_cond_t *__cond)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_signal (pthread_cond_t *__cond)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_broadcast (pthread_cond_t *__cond)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));






extern int pthread_cond_wait (pthread_cond_t *__restrict __cond,
         pthread_mutex_t *__restrict __mutex)
     __attribute__ ((__nonnull__ (1, 2)));
# 1001 "/usr/include/pthread.h" 3 4
extern int pthread_cond_timedwait (pthread_cond_t *__restrict __cond,
       pthread_mutex_t *__restrict __mutex,
       const struct timespec *__restrict __abstime)
     __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_condattr_init (pthread_condattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_destroy (pthread_condattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_getpshared (const pthread_condattr_t *
     __restrict __attr,
     int *__restrict __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setpshared (pthread_condattr_t *__attr,
     int __pshared) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_condattr_getclock (const pthread_condattr_t *
          __restrict __attr,
          __clockid_t *__restrict __clock_id)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setclock (pthread_condattr_t *__attr,
          __clockid_t __clock_id)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 1045 "/usr/include/pthread.h" 3 4
extern int pthread_spin_init (pthread_spinlock_t *__lock, int __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_destroy (pthread_spinlock_t *__lock)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_lock (pthread_spinlock_t *__lock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_trylock (pthread_spinlock_t *__lock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_unlock (pthread_spinlock_t *__lock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));






extern int pthread_barrier_init (pthread_barrier_t *__restrict __barrier,
     const pthread_barrierattr_t *__restrict
     __attr, unsigned int __count)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_destroy (pthread_barrier_t *__barrier)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_wait (pthread_barrier_t *__barrier)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_barrierattr_init (pthread_barrierattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_destroy (pthread_barrierattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_getpshared (const pthread_barrierattr_t *
        __restrict __attr,
        int *__restrict __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_barrierattr_setpshared (pthread_barrierattr_t *__attr,
        int __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 1112 "/usr/include/pthread.h" 3 4
extern int pthread_key_create (pthread_key_t *__key,
          void (*__destr_function) (void *))
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_key_delete (pthread_key_t __key) __attribute__ ((__nothrow__ , __leaf__));


extern void *pthread_getspecific (pthread_key_t __key) __attribute__ ((__nothrow__ , __leaf__));


extern int pthread_setspecific (pthread_key_t __key,
    const void *__pointer) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int pthread_getcpuclockid (pthread_t __thread_id,
      __clockid_t *__clock_id)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));
# 1146 "/usr/include/pthread.h" 3 4
extern int pthread_atfork (void (*__prepare) (void),
      void (*__parent) (void),
      void (*__child) (void)) __attribute__ ((__nothrow__ , __leaf__));
# 1160 "/usr/include/pthread.h" 3 4

# 44 "/home/toto/.env/encours/neovim/.deps/usr/include/uv/unix.h" 2


# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/uv/threadpool.h" 1
# 30 "/home/toto/.env/encours/neovim/.deps/usr/include/uv/threadpool.h"

# 30 "/home/toto/.env/encours/neovim/.deps/usr/include/uv/threadpool.h"
struct uv__work {
  void (*work)(struct uv__work *w);
  void (*done)(struct uv__work *w, int status);
  struct uv_loop_s* loop;
  void* wq[2];
};
# 47 "/home/toto/.env/encours/neovim/.deps/usr/include/uv/unix.h" 2


# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/uv/linux.h" 1
# 50 "/home/toto/.env/encours/neovim/.deps/usr/include/uv/unix.h" 2
# 86 "/home/toto/.env/encours/neovim/.deps/usr/include/uv/unix.h"
struct uv__io_s;
struct uv_loop_s;

typedef void (*uv__io_cb)(struct uv_loop_s* loop,
                          struct uv__io_s* w,
                          unsigned int events);
typedef struct uv__io_s uv__io_t;

struct uv__io_s {
  uv__io_cb cb;
  void* pending_queue[2];
  void* watcher_queue[2];
  unsigned int pevents;
  unsigned int events;
  int fd;
 
};
# 121 "/home/toto/.env/encours/neovim/.deps/usr/include/uv/unix.h"
typedef struct uv_buf_t {
  char* base;
  size_t len;
} uv_buf_t;

typedef int uv_file;
typedef int uv_os_sock_t;
typedef int uv_os_fd_t;
typedef pid_t uv_pid_t;



typedef pthread_once_t uv_once_t;
typedef pthread_t uv_thread_t;
typedef pthread_mutex_t uv_mutex_t;
typedef pthread_rwlock_t uv_rwlock_t;
typedef sem_t uv_sem_t;
typedef pthread_cond_t uv_cond_t;
typedef pthread_key_t uv_key_t;
# 162 "/home/toto/.env/encours/neovim/.deps/usr/include/uv/unix.h"
typedef pthread_barrier_t uv_barrier_t;



typedef gid_t uv_gid_t;
typedef uid_t uv_uid_t;

typedef struct dirent uv__dirent_t;
# 216 "/home/toto/.env/encours/neovim/.deps/usr/include/uv/unix.h"
typedef struct {
  void* handle;
  char* errmsg;
} uv_lib_t;
# 67 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 2
# 182 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
typedef enum {

  UV_E2BIG = (-(
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 3 4
 7
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
 )), UV_EACCES = (-(
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 3 4
 13
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
 )), UV_EADDRINUSE = (-(
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 3 4
 98
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
 )), UV_EADDRNOTAVAIL = (-(
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 3 4
 99
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
 )), UV_EAFNOSUPPORT = (-(
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 3 4
 97
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
 )), UV_EAGAIN = (-(
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 3 4
 11
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
 )), UV_EAI_ADDRFAMILY = (-3000), UV_EAI_AGAIN = (-3001), UV_EAI_BADFLAGS = (-3002), UV_EAI_BADHINTS = (-3013), UV_EAI_CANCELED = (-3003), UV_EAI_FAIL = (-3004), UV_EAI_FAMILY = (-3005), UV_EAI_MEMORY = (-3006), UV_EAI_NODATA = (-3007), UV_EAI_NONAME = (-3008), UV_EAI_OVERFLOW = (-3009), UV_EAI_PROTOCOL = (-3014), UV_EAI_SERVICE = (-3010), UV_EAI_SOCKTYPE = (-3011), UV_EALREADY = (-(
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 3 4
 114
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
 )), UV_EBADF = (-(
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 3 4
 9
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
 )), UV_EBUSY = (-(
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 3 4
 16
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
 )), UV_ECANCELED = (-(
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 3 4
 125
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
 )), UV_ECHARSET = (-4080), UV_ECONNABORTED = (-(
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 3 4
 103
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
 )), UV_ECONNREFUSED = (-(
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 3 4
 111
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
 )), UV_ECONNRESET = (-(
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 3 4
 104
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
 )), UV_EDESTADDRREQ = (-(
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 3 4
 89
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
 )), UV_EEXIST = (-(
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 3 4
 17
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
 )), UV_EFAULT = (-(
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 3 4
 14
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
 )), UV_EFBIG = (-(
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 3 4
 27
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
 )), UV_EHOSTUNREACH = (-(
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 3 4
 113
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
 )), UV_EINTR = (-(
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 3 4
 4
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
 )), UV_EINVAL = (-(
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 3 4
 22
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
 )), UV_EIO = (-(
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 3 4
 5
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
 )), UV_EISCONN = (-(
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 3 4
 106
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
 )), UV_EISDIR = (-(
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 3 4
 21
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
 )), UV_ELOOP = (-(
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 3 4
 40
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
 )), UV_EMFILE = (-(
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 3 4
 24
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
 )), UV_EMSGSIZE = (-(
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 3 4
 90
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
 )), UV_ENAMETOOLONG = (-(
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 3 4
 36
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
 )), UV_ENETDOWN = (-(
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 3 4
 100
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
 )), UV_ENETUNREACH = (-(
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 3 4
 101
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
 )), UV_ENFILE = (-(
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 3 4
 23
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
 )), UV_ENOBUFS = (-(
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 3 4
 105
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
 )), UV_ENODEV = (-(
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 3 4
 19
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
 )), UV_ENOENT = (-(
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 3 4
 2
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
 )), UV_ENOMEM = (-(
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 3 4
 12
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
 )), UV_ENONET = (-(
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 3 4
 64
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
 )), UV_ENOPROTOOPT = (-(
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 3 4
 92
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
 )), UV_ENOSPC = (-(
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 3 4
 28
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
 )), UV_ENOSYS = (-(
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 3 4
 38
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
 )), UV_ENOTCONN = (-(
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 3 4
 107
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
 )), UV_ENOTDIR = (-(
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 3 4
 20
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
 )), UV_ENOTEMPTY = (-(
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 3 4
 39
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
 )), UV_ENOTSOCK = (-(
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 3 4
 88
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
 )), UV_ENOTSUP = (-(
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 3 4
 95
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
 )), UV_EPERM = (-(
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 3 4
 1
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
 )), UV_EPIPE = (-(
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 3 4
 32
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
 )), UV_EPROTO = (-(
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 3 4
 71
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
 )), UV_EPROTONOSUPPORT = (-(
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 3 4
 93
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
 )), UV_EPROTOTYPE = (-(
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 3 4
 91
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
 )), UV_ERANGE = (-(
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 3 4
 34
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
 )), UV_EROFS = (-(
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 3 4
 30
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
 )), UV_ESHUTDOWN = (-(
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 3 4
 108
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
 )), UV_ESPIPE = (-(
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 3 4
 29
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
 )), UV_ESRCH = (-(
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 3 4
 3
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
 )), UV_ETIMEDOUT = (-(
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 3 4
 110
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
 )), UV_ETXTBSY = (-(
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 3 4
 26
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
 )), UV_EXDEV = (-(
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 3 4
 18
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
 )), UV_UNKNOWN = (-4094), UV_EOF = (-4095), UV_ENXIO = (-(
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 3 4
 6
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
 )), UV_EMLINK = (-(
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 3 4
 31
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
 )), UV_EHOSTDOWN = (-(
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 3 4
 112
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
 )), UV_EREMOTEIO = (-(
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 3 4
 121
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
 )), UV_ENOTTY = (-(
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 3 4
 25
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
 )), UV_EFTYPE = (-4028), UV_EILSEQ = (-(
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 3 4
 84
# 184 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
 )),

  UV_ERRNO_MAX = (-4095) - 1
} uv_errno_t;

typedef enum {
  UV_UNKNOWN_HANDLE = 0,

  UV_ASYNC, UV_CHECK, UV_FS_EVENT, UV_FS_POLL, UV_HANDLE, UV_IDLE, UV_NAMED_PIPE, UV_POLL, UV_PREPARE, UV_PROCESS, UV_STREAM, UV_TCP, UV_TIMER, UV_TTY, UV_UDP, UV_SIGNAL,

  UV_FILE,
  UV_HANDLE_TYPE_MAX
} uv_handle_type;

typedef enum {
  UV_UNKNOWN_REQ = 0,

  UV_REQ, UV_CONNECT, UV_WRITE, UV_SHUTDOWN, UV_UDP_SEND, UV_FS, UV_WORK, UV_GETADDRINFO, UV_GETNAMEINFO, UV_RANDOM,

 
  UV_REQ_TYPE_MAX
} uv_req_type;



typedef struct uv_loop_s uv_loop_t;
typedef struct uv_handle_s uv_handle_t;
typedef struct uv_dir_s uv_dir_t;
typedef struct uv_stream_s uv_stream_t;
typedef struct uv_tcp_s uv_tcp_t;
typedef struct uv_udp_s uv_udp_t;
typedef struct uv_pipe_s uv_pipe_t;
typedef struct uv_tty_s uv_tty_t;
typedef struct uv_poll_s uv_poll_t;
typedef struct uv_timer_s uv_timer_t;
typedef struct uv_prepare_s uv_prepare_t;
typedef struct uv_check_s uv_check_t;
typedef struct uv_idle_s uv_idle_t;
typedef struct uv_async_s uv_async_t;
typedef struct uv_process_s uv_process_t;
typedef struct uv_fs_event_s uv_fs_event_t;
typedef struct uv_fs_poll_s uv_fs_poll_t;
typedef struct uv_signal_s uv_signal_t;


typedef struct uv_req_s uv_req_t;
typedef struct uv_getaddrinfo_s uv_getaddrinfo_t;
typedef struct uv_getnameinfo_s uv_getnameinfo_t;
typedef struct uv_shutdown_s uv_shutdown_t;
typedef struct uv_write_s uv_write_t;
typedef struct uv_connect_s uv_connect_t;
typedef struct uv_udp_send_s uv_udp_send_t;
typedef struct uv_fs_s uv_fs_t;
typedef struct uv_work_s uv_work_t;
typedef struct uv_random_s uv_random_t;


typedef struct uv_env_item_s uv_env_item_t;
typedef struct uv_cpu_info_s uv_cpu_info_t;
typedef struct uv_interface_address_s uv_interface_address_t;
typedef struct uv_dirent_s uv_dirent_t;
typedef struct uv_passwd_s uv_passwd_t;
typedef struct uv_utsname_s uv_utsname_t;
typedef struct uv_statfs_s uv_statfs_t;

typedef enum {
  UV_LOOP_BLOCK_SIGNAL
} uv_loop_option;

typedef enum {
  UV_RUN_DEFAULT = 0,
  UV_RUN_ONCE,
  UV_RUN_NOWAIT
} uv_run_mode;


__attribute__((visibility("default"))) unsigned int uv_version(void);
__attribute__((visibility("default"))) const char* uv_version_string(void);

typedef void* (*uv_malloc_func)(size_t size);
typedef void* (*uv_realloc_func)(void* ptr, size_t size);
typedef void* (*uv_calloc_func)(size_t count, size_t size);
typedef void (*uv_free_func)(void* ptr);

__attribute__((visibility("default"))) int uv_replace_allocator(uv_malloc_func malloc_func,
                                   uv_realloc_func realloc_func,
                                   uv_calloc_func calloc_func,
                                   uv_free_func free_func);

__attribute__((visibility("default"))) uv_loop_t* uv_default_loop(void);
__attribute__((visibility("default"))) int uv_loop_init(uv_loop_t* loop);
__attribute__((visibility("default"))) int uv_loop_close(uv_loop_t* loop);





__attribute__((visibility("default"))) uv_loop_t* uv_loop_new(void);





__attribute__((visibility("default"))) void uv_loop_delete(uv_loop_t*);
__attribute__((visibility("default"))) size_t uv_loop_size(void);
__attribute__((visibility("default"))) int uv_loop_alive(const uv_loop_t* loop);
__attribute__((visibility("default"))) int uv_loop_configure(uv_loop_t* loop, uv_loop_option option, ...);
__attribute__((visibility("default"))) int uv_loop_fork(uv_loop_t* loop);

__attribute__((visibility("default"))) int uv_run(uv_loop_t*, uv_run_mode mode);
__attribute__((visibility("default"))) void uv_stop(uv_loop_t*);

__attribute__((visibility("default"))) void uv_ref(uv_handle_t*);
__attribute__((visibility("default"))) void uv_unref(uv_handle_t*);
__attribute__((visibility("default"))) int uv_has_ref(const uv_handle_t*);

__attribute__((visibility("default"))) void uv_update_time(uv_loop_t*);
__attribute__((visibility("default"))) uint64_t uv_now(const uv_loop_t*);

__attribute__((visibility("default"))) int uv_backend_fd(const uv_loop_t*);
__attribute__((visibility("default"))) int uv_backend_timeout(const uv_loop_t*);

typedef void (*uv_alloc_cb)(uv_handle_t* handle,
                            size_t suggested_size,
                            uv_buf_t* buf);
typedef void (*uv_read_cb)(uv_stream_t* stream,
                           ssize_t nread,
                           const uv_buf_t* buf);
typedef void (*uv_write_cb)(uv_write_t* req, int status);
typedef void (*uv_connect_cb)(uv_connect_t* req, int status);
typedef void (*uv_shutdown_cb)(uv_shutdown_t* req, int status);
typedef void (*uv_connection_cb)(uv_stream_t* server, int status);
typedef void (*uv_close_cb)(uv_handle_t* handle);
typedef void (*uv_poll_cb)(uv_poll_t* handle, int status, int events);
typedef void (*uv_timer_cb)(uv_timer_t* handle);
typedef void (*uv_async_cb)(uv_async_t* handle);
typedef void (*uv_prepare_cb)(uv_prepare_t* handle);
typedef void (*uv_check_cb)(uv_check_t* handle);
typedef void (*uv_idle_cb)(uv_idle_t* handle);
typedef void (*uv_exit_cb)(uv_process_t*, int64_t exit_status, int term_signal);
typedef void (*uv_walk_cb)(uv_handle_t* handle, void* arg);
typedef void (*uv_fs_cb)(uv_fs_t* req);
typedef void (*uv_work_cb)(uv_work_t* req);
typedef void (*uv_after_work_cb)(uv_work_t* req, int status);
typedef void (*uv_getaddrinfo_cb)(uv_getaddrinfo_t* req,
                                  int status,
                                  struct addrinfo* res);
typedef void (*uv_getnameinfo_cb)(uv_getnameinfo_t* req,
                                  int status,
                                  const char* hostname,
                                  const char* service);
typedef void (*uv_random_cb)(uv_random_t* req,
                             int status,
                             void* buf,
                             size_t buflen);

typedef struct {
  long tv_sec;
  long tv_nsec;
} uv_timespec_t;


typedef struct {
  uint64_t st_dev;
  uint64_t st_mode;
  uint64_t st_nlink;
  uint64_t st_uid;
  uint64_t st_gid;
  uint64_t st_rdev;
  uint64_t st_ino;
  uint64_t st_size;
  uint64_t st_blksize;
  uint64_t st_blocks;
  uint64_t st_flags;
  uint64_t st_gen;
  uv_timespec_t st_atim;
  uv_timespec_t st_mtim;
  uv_timespec_t st_ctim;
  uv_timespec_t st_birthtim;
} uv_stat_t;


typedef void (*uv_fs_event_cb)(uv_fs_event_t* handle,
                               const char* filename,
                               int events,
                               int status);

typedef void (*uv_fs_poll_cb)(uv_fs_poll_t* handle,
                              int status,
                              const uv_stat_t* prev,
                              const uv_stat_t* curr);

typedef void (*uv_signal_cb)(uv_signal_t* handle, int signum);


typedef enum {
  UV_LEAVE_GROUP = 0,
  UV_JOIN_GROUP
} uv_membership;


__attribute__((visibility("default"))) int uv_translate_sys_error(int sys_errno);

__attribute__((visibility("default"))) const char* uv_strerror(int err);
__attribute__((visibility("default"))) char* uv_strerror_r(int err, char* buf, size_t buflen);

__attribute__((visibility("default"))) const char* uv_err_name(int err);
__attribute__((visibility("default"))) char* uv_err_name_r(int err, char* buf, size_t buflen);
# 404 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
struct uv_req_s {
  void* data; uv_req_type type; void* reserved[6];
};






__attribute__((visibility("default"))) int uv_shutdown(uv_shutdown_t* req,
                          uv_stream_t* handle,
                          uv_shutdown_cb cb);

struct uv_shutdown_s {
  void* data; uv_req_type type; void* reserved[6];
  uv_stream_t* handle;
  uv_shutdown_cb cb;
 
};
# 441 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
struct uv_handle_s {
  void* data; uv_loop_t* loop; uv_handle_type type; uv_close_cb close_cb; void* handle_queue[2]; union { int fd; void* reserved[4]; } u; uv_handle_t* next_closing; unsigned int flags;
};

__attribute__((visibility("default"))) size_t uv_handle_size(uv_handle_type type);
__attribute__((visibility("default"))) uv_handle_type uv_handle_get_type(const uv_handle_t* handle);
__attribute__((visibility("default"))) const char* uv_handle_type_name(uv_handle_type type);
__attribute__((visibility("default"))) void* uv_handle_get_data(const uv_handle_t* handle);
__attribute__((visibility("default"))) uv_loop_t* uv_handle_get_loop(const uv_handle_t* handle);
__attribute__((visibility("default"))) void uv_handle_set_data(uv_handle_t* handle, void* data);

__attribute__((visibility("default"))) size_t uv_req_size(uv_req_type type);
__attribute__((visibility("default"))) void* uv_req_get_data(const uv_req_t* req);
__attribute__((visibility("default"))) void uv_req_set_data(uv_req_t* req, void* data);
__attribute__((visibility("default"))) uv_req_type uv_req_get_type(const uv_req_t* req);
__attribute__((visibility("default"))) const char* uv_req_type_name(uv_req_type type);

__attribute__((visibility("default"))) int uv_is_active(const uv_handle_t* handle);

__attribute__((visibility("default"))) void uv_walk(uv_loop_t* loop, uv_walk_cb walk_cb, void* arg);


__attribute__((visibility("default"))) void uv_print_all_handles(uv_loop_t* loop, FILE* stream);
__attribute__((visibility("default"))) void uv_print_active_handles(uv_loop_t* loop, FILE* stream);

__attribute__((visibility("default"))) void uv_close(uv_handle_t* handle, uv_close_cb close_cb);

__attribute__((visibility("default"))) int uv_send_buffer_size(uv_handle_t* handle, int* value);
__attribute__((visibility("default"))) int uv_recv_buffer_size(uv_handle_t* handle, int* value);

__attribute__((visibility("default"))) int uv_fileno(const uv_handle_t* handle, uv_os_fd_t* fd);

__attribute__((visibility("default"))) uv_buf_t uv_buf_init(char* base, unsigned int len);
# 491 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
struct uv_stream_s {
  void* data; uv_loop_t* loop; uv_handle_type type; uv_close_cb close_cb; void* handle_queue[2]; union { int fd; void* reserved[4]; } u; uv_handle_t* next_closing; unsigned int flags;
  size_t write_queue_size; uv_alloc_cb alloc_cb; uv_read_cb read_cb; uv_connect_t *connect_req; uv_shutdown_t *shutdown_req; uv__io_t io_watcher; void* write_queue[2]; void* write_completed_queue[2]; uv_connection_cb connection_cb; int delayed_error; int accepted_fd; void* queued_fds;
};

__attribute__((visibility("default"))) size_t uv_stream_get_write_queue_size(const uv_stream_t* stream);

__attribute__((visibility("default"))) int uv_listen(uv_stream_t* stream, int backlog, uv_connection_cb cb);
__attribute__((visibility("default"))) int uv_accept(uv_stream_t* server, uv_stream_t* client);

__attribute__((visibility("default"))) int uv_read_start(uv_stream_t*,
                            uv_alloc_cb alloc_cb,
                            uv_read_cb read_cb);
__attribute__((visibility("default"))) int uv_read_stop(uv_stream_t*);

__attribute__((visibility("default"))) int uv_write(uv_write_t* req,
                       uv_stream_t* handle,
                       const uv_buf_t bufs[],
                       unsigned int nbufs,
                       uv_write_cb cb);
__attribute__((visibility("default"))) int uv_write2(uv_write_t* req,
                        uv_stream_t* handle,
                        const uv_buf_t bufs[],
                        unsigned int nbufs,
                        uv_stream_t* send_handle,
                        uv_write_cb cb);
__attribute__((visibility("default"))) int uv_try_write(uv_stream_t* handle,
                           const uv_buf_t bufs[],
                           unsigned int nbufs);


struct uv_write_s {
  void* data; uv_req_type type; void* reserved[6];
  uv_write_cb cb;
  uv_stream_t* send_handle;
  uv_stream_t* handle;
  void* queue[2]; unsigned int write_index; uv_buf_t* bufs; unsigned int nbufs; int error; uv_buf_t bufsml[4];
};


__attribute__((visibility("default"))) int uv_is_readable(const uv_stream_t* handle);
__attribute__((visibility("default"))) int uv_is_writable(const uv_stream_t* handle);

__attribute__((visibility("default"))) int uv_stream_set_blocking(uv_stream_t* handle, int blocking);

__attribute__((visibility("default"))) int uv_is_closing(const uv_handle_t* handle);







struct uv_tcp_s {
  void* data; uv_loop_t* loop; uv_handle_type type; uv_close_cb close_cb; void* handle_queue[2]; union { int fd; void* reserved[4]; } u; uv_handle_t* next_closing; unsigned int flags;
  size_t write_queue_size; uv_alloc_cb alloc_cb; uv_read_cb read_cb; uv_connect_t *connect_req; uv_shutdown_t *shutdown_req; uv__io_t io_watcher; void* write_queue[2]; void* write_completed_queue[2]; uv_connection_cb connection_cb; int delayed_error; int accepted_fd; void* queued_fds;
 
};

__attribute__((visibility("default"))) int uv_tcp_init(uv_loop_t*, uv_tcp_t* handle);
__attribute__((visibility("default"))) int uv_tcp_init_ex(uv_loop_t*, uv_tcp_t* handle, unsigned int flags);
__attribute__((visibility("default"))) int uv_tcp_open(uv_tcp_t* handle, uv_os_sock_t sock);
__attribute__((visibility("default"))) int uv_tcp_nodelay(uv_tcp_t* handle, int enable);
__attribute__((visibility("default"))) int uv_tcp_keepalive(uv_tcp_t* handle,
                               int enable,
                               unsigned int delay);
__attribute__((visibility("default"))) int uv_tcp_simultaneous_accepts(uv_tcp_t* handle, int enable);

enum uv_tcp_flags {

  UV_TCP_IPV6ONLY = 1
};

__attribute__((visibility("default"))) int uv_tcp_bind(uv_tcp_t* handle,
                          const struct sockaddr* addr,
                          unsigned int flags);
__attribute__((visibility("default"))) int uv_tcp_getsockname(const uv_tcp_t* handle,
                                 struct sockaddr* name,
                                 int* namelen);
__attribute__((visibility("default"))) int uv_tcp_getpeername(const uv_tcp_t* handle,
                                 struct sockaddr* name,
                                 int* namelen);
__attribute__((visibility("default"))) int uv_tcp_close_reset(uv_tcp_t* handle, uv_close_cb close_cb);
__attribute__((visibility("default"))) int uv_tcp_connect(uv_connect_t* req,
                             uv_tcp_t* handle,
                             const struct sockaddr* addr,
                             uv_connect_cb cb);


struct uv_connect_s {
  void* data; uv_req_type type; void* reserved[6];
  uv_connect_cb cb;
  uv_stream_t* handle;
  void* queue[2];
};






enum uv_udp_flags {

  UV_UDP_IPV6ONLY = 1,




  UV_UDP_PARTIAL = 2,
# 608 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
  UV_UDP_REUSEADDR = 4
};

typedef void (*uv_udp_send_cb)(uv_udp_send_t* req, int status);
typedef void (*uv_udp_recv_cb)(uv_udp_t* handle,
                               ssize_t nread,
                               const uv_buf_t* buf,
                               const struct sockaddr* addr,
                               unsigned flags);


struct uv_udp_s {
  void* data; uv_loop_t* loop; uv_handle_type type; uv_close_cb close_cb; void* handle_queue[2]; union { int fd; void* reserved[4]; } u; uv_handle_t* next_closing; unsigned int flags;





  size_t send_queue_size;



  size_t send_queue_count;
  uv_alloc_cb alloc_cb; uv_udp_recv_cb recv_cb; uv__io_t io_watcher; void* write_queue[2]; void* write_completed_queue[2];
};


struct uv_udp_send_s {
  void* data; uv_req_type type; void* reserved[6];
  uv_udp_t* handle;
  uv_udp_send_cb cb;
  void* queue[2]; struct sockaddr_storage addr; unsigned int nbufs; uv_buf_t* bufs; ssize_t status; uv_udp_send_cb send_cb; uv_buf_t bufsml[4];
};

__attribute__((visibility("default"))) int uv_udp_init(uv_loop_t*, uv_udp_t* handle);
__attribute__((visibility("default"))) int uv_udp_init_ex(uv_loop_t*, uv_udp_t* handle, unsigned int flags);
__attribute__((visibility("default"))) int uv_udp_open(uv_udp_t* handle, uv_os_sock_t sock);
__attribute__((visibility("default"))) int uv_udp_bind(uv_udp_t* handle,
                          const struct sockaddr* addr,
                          unsigned int flags);
__attribute__((visibility("default"))) int uv_udp_connect(uv_udp_t* handle, const struct sockaddr* addr);

__attribute__((visibility("default"))) int uv_udp_getpeername(const uv_udp_t* handle,
                                 struct sockaddr* name,
                                 int* namelen);
__attribute__((visibility("default"))) int uv_udp_getsockname(const uv_udp_t* handle,
                                 struct sockaddr* name,
                                 int* namelen);
__attribute__((visibility("default"))) int uv_udp_set_membership(uv_udp_t* handle,
                                    const char* multicast_addr,
                                    const char* interface_addr,
                                    uv_membership membership);
__attribute__((visibility("default"))) int uv_udp_set_source_membership(uv_udp_t* handle,
                                           const char* multicast_addr,
                                           const char* interface_addr,
                                           const char* source_addr,
                                           uv_membership membership);
__attribute__((visibility("default"))) int uv_udp_set_multicast_loop(uv_udp_t* handle, int on);
__attribute__((visibility("default"))) int uv_udp_set_multicast_ttl(uv_udp_t* handle, int ttl);
__attribute__((visibility("default"))) int uv_udp_set_multicast_interface(uv_udp_t* handle,
                                             const char* interface_addr);
__attribute__((visibility("default"))) int uv_udp_set_broadcast(uv_udp_t* handle, int on);
__attribute__((visibility("default"))) int uv_udp_set_ttl(uv_udp_t* handle, int ttl);
__attribute__((visibility("default"))) int uv_udp_send(uv_udp_send_t* req,
                          uv_udp_t* handle,
                          const uv_buf_t bufs[],
                          unsigned int nbufs,
                          const struct sockaddr* addr,
                          uv_udp_send_cb send_cb);
__attribute__((visibility("default"))) int uv_udp_try_send(uv_udp_t* handle,
                              const uv_buf_t bufs[],
                              unsigned int nbufs,
                              const struct sockaddr* addr);
__attribute__((visibility("default"))) int uv_udp_recv_start(uv_udp_t* handle,
                                uv_alloc_cb alloc_cb,
                                uv_udp_recv_cb recv_cb);
__attribute__((visibility("default"))) int uv_udp_recv_stop(uv_udp_t* handle);
__attribute__((visibility("default"))) size_t uv_udp_get_send_queue_size(const uv_udp_t* handle);
__attribute__((visibility("default"))) size_t uv_udp_get_send_queue_count(const uv_udp_t* handle);







struct uv_tty_s {
  void* data; uv_loop_t* loop; uv_handle_type type; uv_close_cb close_cb; void* handle_queue[2]; union { int fd; void* reserved[4]; } u; uv_handle_t* next_closing; unsigned int flags;
  size_t write_queue_size; uv_alloc_cb alloc_cb; uv_read_cb read_cb; uv_connect_t *connect_req; uv_shutdown_t *shutdown_req; uv__io_t io_watcher; void* write_queue[2]; void* write_completed_queue[2]; uv_connection_cb connection_cb; int delayed_error; int accepted_fd; void* queued_fds;
  struct termios orig_termios; int mode;
};

typedef enum {

  UV_TTY_MODE_NORMAL,

  UV_TTY_MODE_RAW,

  UV_TTY_MODE_IO
} uv_tty_mode_t;

typedef enum {




  UV_TTY_SUPPORTED,



  UV_TTY_UNSUPPORTED
} uv_tty_vtermstate_t;


__attribute__((visibility("default"))) int uv_tty_init(uv_loop_t*, uv_tty_t*, uv_file fd, int readable);
__attribute__((visibility("default"))) int uv_tty_set_mode(uv_tty_t*, uv_tty_mode_t mode);
__attribute__((visibility("default"))) int uv_tty_reset_mode(void);
__attribute__((visibility("default"))) int uv_tty_get_winsize(uv_tty_t*, int* width, int* height);
__attribute__((visibility("default"))) void uv_tty_set_vterm_state(uv_tty_vtermstate_t state);
__attribute__((visibility("default"))) int uv_tty_get_vterm_state(uv_tty_vtermstate_t* state);
# 739 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
__attribute__((visibility("default"))) uv_handle_type uv_guess_handle(uv_file file);







struct uv_pipe_s {
  void* data; uv_loop_t* loop; uv_handle_type type; uv_close_cb close_cb; void* handle_queue[2]; union { int fd; void* reserved[4]; } u; uv_handle_t* next_closing; unsigned int flags;
  size_t write_queue_size; uv_alloc_cb alloc_cb; uv_read_cb read_cb; uv_connect_t *connect_req; uv_shutdown_t *shutdown_req; uv__io_t io_watcher; void* write_queue[2]; void* write_completed_queue[2]; uv_connection_cb connection_cb; int delayed_error; int accepted_fd; void* queued_fds;
  int ipc;
  const char* pipe_fname;
};

__attribute__((visibility("default"))) int uv_pipe_init(uv_loop_t*, uv_pipe_t* handle, int ipc);
__attribute__((visibility("default"))) int uv_pipe_open(uv_pipe_t*, uv_file file);
__attribute__((visibility("default"))) int uv_pipe_bind(uv_pipe_t* handle, const char* name);
__attribute__((visibility("default"))) void uv_pipe_connect(uv_connect_t* req,
                               uv_pipe_t* handle,
                               const char* name,
                               uv_connect_cb cb);
__attribute__((visibility("default"))) int uv_pipe_getsockname(const uv_pipe_t* handle,
                                  char* buffer,
                                  size_t* size);
__attribute__((visibility("default"))) int uv_pipe_getpeername(const uv_pipe_t* handle,
                                  char* buffer,
                                  size_t* size);
__attribute__((visibility("default"))) void uv_pipe_pending_instances(uv_pipe_t* handle, int count);
__attribute__((visibility("default"))) int uv_pipe_pending_count(uv_pipe_t* handle);
__attribute__((visibility("default"))) uv_handle_type uv_pipe_pending_type(uv_pipe_t* handle);
__attribute__((visibility("default"))) int uv_pipe_chmod(uv_pipe_t* handle, int flags);


struct uv_poll_s {
  void* data; uv_loop_t* loop; uv_handle_type type; uv_close_cb close_cb; void* handle_queue[2]; union { int fd; void* reserved[4]; } u; uv_handle_t* next_closing; unsigned int flags;
  uv_poll_cb poll_cb;
  uv__io_t io_watcher;
};

enum uv_poll_event {
  UV_READABLE = 1,
  UV_WRITABLE = 2,
  UV_DISCONNECT = 4,
  UV_PRIORITIZED = 8
};

__attribute__((visibility("default"))) int uv_poll_init(uv_loop_t* loop, uv_poll_t* handle, int fd);
__attribute__((visibility("default"))) int uv_poll_init_socket(uv_loop_t* loop,
                                  uv_poll_t* handle,
                                  uv_os_sock_t socket);
__attribute__((visibility("default"))) int uv_poll_start(uv_poll_t* handle, int events, uv_poll_cb cb);
__attribute__((visibility("default"))) int uv_poll_stop(uv_poll_t* handle);


struct uv_prepare_s {
  void* data; uv_loop_t* loop; uv_handle_type type; uv_close_cb close_cb; void* handle_queue[2]; union { int fd; void* reserved[4]; } u; uv_handle_t* next_closing; unsigned int flags;
  uv_prepare_cb prepare_cb; void* queue[2];
};

__attribute__((visibility("default"))) int uv_prepare_init(uv_loop_t*, uv_prepare_t* prepare);
__attribute__((visibility("default"))) int uv_prepare_start(uv_prepare_t* prepare, uv_prepare_cb cb);
__attribute__((visibility("default"))) int uv_prepare_stop(uv_prepare_t* prepare);


struct uv_check_s {
  void* data; uv_loop_t* loop; uv_handle_type type; uv_close_cb close_cb; void* handle_queue[2]; union { int fd; void* reserved[4]; } u; uv_handle_t* next_closing; unsigned int flags;
  uv_check_cb check_cb; void* queue[2];
};

__attribute__((visibility("default"))) int uv_check_init(uv_loop_t*, uv_check_t* check);
__attribute__((visibility("default"))) int uv_check_start(uv_check_t* check, uv_check_cb cb);
__attribute__((visibility("default"))) int uv_check_stop(uv_check_t* check);


struct uv_idle_s {
  void* data; uv_loop_t* loop; uv_handle_type type; uv_close_cb close_cb; void* handle_queue[2]; union { int fd; void* reserved[4]; } u; uv_handle_t* next_closing; unsigned int flags;
  uv_idle_cb idle_cb; void* queue[2];
};

__attribute__((visibility("default"))) int uv_idle_init(uv_loop_t*, uv_idle_t* idle);
__attribute__((visibility("default"))) int uv_idle_start(uv_idle_t* idle, uv_idle_cb cb);
__attribute__((visibility("default"))) int uv_idle_stop(uv_idle_t* idle);


struct uv_async_s {
  void* data; uv_loop_t* loop; uv_handle_type type; uv_close_cb close_cb; void* handle_queue[2]; union { int fd; void* reserved[4]; } u; uv_handle_t* next_closing; unsigned int flags;
  uv_async_cb async_cb; void* queue[2]; int pending;
};

__attribute__((visibility("default"))) int uv_async_init(uv_loop_t*,
                            uv_async_t* async,
                            uv_async_cb async_cb);
__attribute__((visibility("default"))) int uv_async_send(uv_async_t* async);







struct uv_timer_s {
  void* data; uv_loop_t* loop; uv_handle_type type; uv_close_cb close_cb; void* handle_queue[2]; union { int fd; void* reserved[4]; } u; uv_handle_t* next_closing; unsigned int flags;
  uv_timer_cb timer_cb; void* heap_node[3]; uint64_t timeout; uint64_t repeat; uint64_t start_id;
};

__attribute__((visibility("default"))) int uv_timer_init(uv_loop_t*, uv_timer_t* handle);
__attribute__((visibility("default"))) int uv_timer_start(uv_timer_t* handle,
                             uv_timer_cb cb,
                             uint64_t timeout,
                             uint64_t repeat);
__attribute__((visibility("default"))) int uv_timer_stop(uv_timer_t* handle);
__attribute__((visibility("default"))) int uv_timer_again(uv_timer_t* handle);
__attribute__((visibility("default"))) void uv_timer_set_repeat(uv_timer_t* handle, uint64_t repeat);
__attribute__((visibility("default"))) uint64_t uv_timer_get_repeat(const uv_timer_t* handle);







struct uv_getaddrinfo_s {
  void* data; uv_req_type type; void* reserved[6];

  uv_loop_t* loop;

  struct uv__work work_req; uv_getaddrinfo_cb cb; struct addrinfo* hints; char* hostname; char* service; struct addrinfo* addrinfo; int retcode;
};


__attribute__((visibility("default"))) int uv_getaddrinfo(uv_loop_t* loop,
                             uv_getaddrinfo_t* req,
                             uv_getaddrinfo_cb getaddrinfo_cb,
                             const char* node,
                             const char* service,
                             const struct addrinfo* hints);
__attribute__((visibility("default"))) void uv_freeaddrinfo(struct addrinfo* ai);







struct uv_getnameinfo_s {
  void* data; uv_req_type type; void* reserved[6];

  uv_loop_t* loop;

  struct uv__work work_req; uv_getnameinfo_cb getnameinfo_cb; struct sockaddr_storage storage; int flags; char host[
# 889 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 3 4
 1025
# 889 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
 ]; char service[
# 889 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h" 3 4
 32
# 889 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
 ]; int retcode;
};

__attribute__((visibility("default"))) int uv_getnameinfo(uv_loop_t* loop,
                             uv_getnameinfo_t* req,
                             uv_getnameinfo_cb getnameinfo_cb,
                             const struct sockaddr* addr,
                             int flags);



typedef enum {
  UV_IGNORE = 0x00,
  UV_CREATE_PIPE = 0x01,
  UV_INHERIT_FD = 0x02,
  UV_INHERIT_STREAM = 0x04,






  UV_READABLE_PIPE = 0x10,
  UV_WRITABLE_PIPE = 0x20,





  UV_OVERLAPPED_PIPE = 0x40
} uv_stdio_flags;

typedef struct uv_stdio_container_s {
  uv_stdio_flags flags;

  union {
    uv_stream_t* stream;
    int fd;
  } data;
} uv_stdio_container_t;

typedef struct uv_process_options_s {
  uv_exit_cb exit_cb;
  const char* file;






  char** args;




  char** env;




  const char* cwd;




  unsigned int flags;
# 964 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
  int stdio_count;
  uv_stdio_container_t* stdio;





  uv_uid_t uid;
  uv_gid_t gid;
} uv_process_options_t;




enum uv_process_flags {





  UV_PROCESS_SETUID = (1 << 0),





  UV_PROCESS_SETGID = (1 << 1),





  UV_PROCESS_WINDOWS_VERBATIM_ARGUMENTS = (1 << 2),







  UV_PROCESS_DETACHED = (1 << 3),




  UV_PROCESS_WINDOWS_HIDE = (1 << 4),





  UV_PROCESS_WINDOWS_HIDE_CONSOLE = (1 << 5),





  UV_PROCESS_WINDOWS_HIDE_GUI = (1 << 6)
};




struct uv_process_s {
  void* data; uv_loop_t* loop; uv_handle_type type; uv_close_cb close_cb; void* handle_queue[2]; union { int fd; void* reserved[4]; } u; uv_handle_t* next_closing; unsigned int flags;
  uv_exit_cb exit_cb;
  int pid;
  void* queue[2]; int status;
};

__attribute__((visibility("default"))) int uv_spawn(uv_loop_t* loop,
                       uv_process_t* handle,
                       const uv_process_options_t* options);
__attribute__((visibility("default"))) int uv_process_kill(uv_process_t*, int signum);
__attribute__((visibility("default"))) int uv_kill(int pid, int signum);
__attribute__((visibility("default"))) uv_pid_t uv_process_get_pid(const uv_process_t*);





struct uv_work_s {
  void* data; uv_req_type type; void* reserved[6];
  uv_loop_t* loop;
  uv_work_cb work_cb;
  uv_after_work_cb after_work_cb;
  struct uv__work work_req;
};

__attribute__((visibility("default"))) int uv_queue_work(uv_loop_t* loop,
                            uv_work_t* req,
                            uv_work_cb work_cb,
                            uv_after_work_cb after_work_cb);

__attribute__((visibility("default"))) int uv_cancel(uv_req_t* req);


struct uv_cpu_times_s {
  uint64_t user;
  uint64_t nice;
  uint64_t sys;
  uint64_t idle;
  uint64_t irq;
};

struct uv_cpu_info_s {
  char* model;
  int speed;
  struct uv_cpu_times_s cpu_times;
};

struct uv_interface_address_s {
  char* name;
  char phys_addr[6];
  int is_internal;
  union {
    struct sockaddr_in address4;
    struct sockaddr_in6 address6;
  } address;
  union {
    struct sockaddr_in netmask4;
    struct sockaddr_in6 netmask6;
  } netmask;
};

struct uv_passwd_s {
  char* username;
  long uid;
  long gid;
  char* shell;
  char* homedir;
};

struct uv_utsname_s {
  char sysname[256];
  char release[256];
  char version[256];
  char machine[256];



};

struct uv_statfs_s {
  uint64_t f_type;
  uint64_t f_bsize;
  uint64_t f_blocks;
  uint64_t f_bfree;
  uint64_t f_bavail;
  uint64_t f_files;
  uint64_t f_ffree;
  uint64_t f_spare[4];
};

typedef enum {
  UV_DIRENT_UNKNOWN,
  UV_DIRENT_FILE,
  UV_DIRENT_DIR,
  UV_DIRENT_LINK,
  UV_DIRENT_FIFO,
  UV_DIRENT_SOCKET,
  UV_DIRENT_CHAR,
  UV_DIRENT_BLOCK
} uv_dirent_type_t;

struct uv_dirent_s {
  const char* name;
  uv_dirent_type_t type;
};

__attribute__((visibility("default"))) char** uv_setup_args(int argc, char** argv);
__attribute__((visibility("default"))) int uv_get_process_title(char* buffer, size_t size);
__attribute__((visibility("default"))) int uv_set_process_title(const char* title);
__attribute__((visibility("default"))) int uv_resident_set_memory(size_t* rss);
__attribute__((visibility("default"))) int uv_uptime(double* uptime);
__attribute__((visibility("default"))) uv_os_fd_t uv_get_osfhandle(int fd);
__attribute__((visibility("default"))) int uv_open_osfhandle(uv_os_fd_t os_fd);

typedef struct {
  long tv_sec;
  long tv_usec;
} uv_timeval_t;

typedef struct {
  int64_t tv_sec;
  int32_t tv_usec;
} uv_timeval64_t;

typedef struct {
   uv_timeval_t ru_utime;
   uv_timeval_t ru_stime;
   uint64_t ru_maxrss;
   uint64_t ru_ixrss;
   uint64_t ru_idrss;
   uint64_t ru_isrss;
   uint64_t ru_minflt;
   uint64_t ru_majflt;
   uint64_t ru_nswap;
   uint64_t ru_inblock;
   uint64_t ru_oublock;
   uint64_t ru_msgsnd;
   uint64_t ru_msgrcv;
   uint64_t ru_nsignals;
   uint64_t ru_nvcsw;
   uint64_t ru_nivcsw;
} uv_rusage_t;

__attribute__((visibility("default"))) int uv_getrusage(uv_rusage_t* rusage);

__attribute__((visibility("default"))) int uv_os_homedir(char* buffer, size_t* size);
__attribute__((visibility("default"))) int uv_os_tmpdir(char* buffer, size_t* size);
__attribute__((visibility("default"))) int uv_os_get_passwd(uv_passwd_t* pwd);
__attribute__((visibility("default"))) void uv_os_free_passwd(uv_passwd_t* pwd);
__attribute__((visibility("default"))) uv_pid_t uv_os_getpid(void);
__attribute__((visibility("default"))) uv_pid_t uv_os_getppid(void);
# 1187 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
__attribute__((visibility("default"))) int uv_os_getpriority(uv_pid_t pid, int* priority);
__attribute__((visibility("default"))) int uv_os_setpriority(uv_pid_t pid, int priority);

__attribute__((visibility("default"))) int uv_cpu_info(uv_cpu_info_t** cpu_infos, int* count);
__attribute__((visibility("default"))) void uv_free_cpu_info(uv_cpu_info_t* cpu_infos, int count);

__attribute__((visibility("default"))) int uv_interface_addresses(uv_interface_address_t** addresses,
                                     int* count);
__attribute__((visibility("default"))) void uv_free_interface_addresses(uv_interface_address_t* addresses,
                                           int count);

struct uv_env_item_s {
  char* name;
  char* value;
};

__attribute__((visibility("default"))) int uv_os_environ(uv_env_item_t** envitems, int* count);
__attribute__((visibility("default"))) void uv_os_free_environ(uv_env_item_t* envitems, int count);
__attribute__((visibility("default"))) int uv_os_getenv(const char* name, char* buffer, size_t* size);
__attribute__((visibility("default"))) int uv_os_setenv(const char* name, const char* value);
__attribute__((visibility("default"))) int uv_os_unsetenv(const char* name);
# 1220 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
__attribute__((visibility("default"))) int uv_os_gethostname(char* buffer, size_t* size);

__attribute__((visibility("default"))) int uv_os_uname(uv_utsname_t* buffer);


typedef enum {
  UV_FS_UNKNOWN = -1,
  UV_FS_CUSTOM,
  UV_FS_OPEN,
  UV_FS_CLOSE,
  UV_FS_READ,
  UV_FS_WRITE,
  UV_FS_SENDFILE,
  UV_FS_STAT,
  UV_FS_LSTAT,
  UV_FS_FSTAT,
  UV_FS_FTRUNCATE,
  UV_FS_UTIME,
  UV_FS_FUTIME,
  UV_FS_ACCESS,
  UV_FS_CHMOD,
  UV_FS_FCHMOD,
  UV_FS_FSYNC,
  UV_FS_FDATASYNC,
  UV_FS_UNLINK,
  UV_FS_RMDIR,
  UV_FS_MKDIR,
  UV_FS_MKDTEMP,
  UV_FS_RENAME,
  UV_FS_SCANDIR,
  UV_FS_LINK,
  UV_FS_SYMLINK,
  UV_FS_READLINK,
  UV_FS_CHOWN,
  UV_FS_FCHOWN,
  UV_FS_REALPATH,
  UV_FS_COPYFILE,
  UV_FS_LCHOWN,
  UV_FS_OPENDIR,
  UV_FS_READDIR,
  UV_FS_CLOSEDIR,
  UV_FS_STATFS,
  UV_FS_MKSTEMP
} uv_fs_type;

struct uv_dir_s {
  uv_dirent_t* dirents;
  size_t nentries;
  void* reserved[4];
  DIR* dir;
};


struct uv_fs_s {
  void* data; uv_req_type type; void* reserved[6];
  uv_fs_type fs_type;
  uv_loop_t* loop;
  uv_fs_cb cb;
  ssize_t result;
  void* ptr;
  const char* path;
  uv_stat_t statbuf;
  const char *new_path; uv_file file; int flags; mode_t mode; unsigned int nbufs; uv_buf_t* bufs; off_t off; uv_uid_t uid; uv_gid_t gid; double atime; double mtime; struct uv__work work_req; uv_buf_t bufsml[4];
};

__attribute__((visibility("default"))) uv_fs_type uv_fs_get_type(const uv_fs_t*);
__attribute__((visibility("default"))) ssize_t uv_fs_get_result(const uv_fs_t*);
__attribute__((visibility("default"))) void* uv_fs_get_ptr(const uv_fs_t*);
__attribute__((visibility("default"))) const char* uv_fs_get_path(const uv_fs_t*);
__attribute__((visibility("default"))) uv_stat_t* uv_fs_get_statbuf(uv_fs_t*);

__attribute__((visibility("default"))) void uv_fs_req_cleanup(uv_fs_t* req);
__attribute__((visibility("default"))) int uv_fs_close(uv_loop_t* loop,
                          uv_fs_t* req,
                          uv_file file,
                          uv_fs_cb cb);
__attribute__((visibility("default"))) int uv_fs_open(uv_loop_t* loop,
                         uv_fs_t* req,
                         const char* path,
                         int flags,
                         int mode,
                         uv_fs_cb cb);
__attribute__((visibility("default"))) int uv_fs_read(uv_loop_t* loop,
                         uv_fs_t* req,
                         uv_file file,
                         const uv_buf_t bufs[],
                         unsigned int nbufs,
                         int64_t offset,
                         uv_fs_cb cb);
__attribute__((visibility("default"))) int uv_fs_unlink(uv_loop_t* loop,
                           uv_fs_t* req,
                           const char* path,
                           uv_fs_cb cb);
__attribute__((visibility("default"))) int uv_fs_write(uv_loop_t* loop,
                          uv_fs_t* req,
                          uv_file file,
                          const uv_buf_t bufs[],
                          unsigned int nbufs,
                          int64_t offset,
                          uv_fs_cb cb);
# 1338 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
__attribute__((visibility("default"))) int uv_fs_copyfile(uv_loop_t* loop,
                             uv_fs_t* req,
                             const char* path,
                             const char* new_path,
                             int flags,
                             uv_fs_cb cb);
__attribute__((visibility("default"))) int uv_fs_mkdir(uv_loop_t* loop,
                          uv_fs_t* req,
                          const char* path,
                          int mode,
                          uv_fs_cb cb);
__attribute__((visibility("default"))) int uv_fs_mkdtemp(uv_loop_t* loop,
                            uv_fs_t* req,
                            const char* tpl,
                            uv_fs_cb cb);
__attribute__((visibility("default"))) int uv_fs_mkstemp(uv_loop_t* loop,
                            uv_fs_t* req,
                            const char* tpl,
                            uv_fs_cb cb);
__attribute__((visibility("default"))) int uv_fs_rmdir(uv_loop_t* loop,
                          uv_fs_t* req,
                          const char* path,
                          uv_fs_cb cb);
__attribute__((visibility("default"))) int uv_fs_scandir(uv_loop_t* loop,
                            uv_fs_t* req,
                            const char* path,
                            int flags,
                            uv_fs_cb cb);
__attribute__((visibility("default"))) int uv_fs_scandir_next(uv_fs_t* req,
                                 uv_dirent_t* ent);
__attribute__((visibility("default"))) int uv_fs_opendir(uv_loop_t* loop,
                            uv_fs_t* req,
                            const char* path,
                            uv_fs_cb cb);
__attribute__((visibility("default"))) int uv_fs_readdir(uv_loop_t* loop,
                            uv_fs_t* req,
                            uv_dir_t* dir,
                            uv_fs_cb cb);
__attribute__((visibility("default"))) int uv_fs_closedir(uv_loop_t* loop,
                             uv_fs_t* req,
                             uv_dir_t* dir,
                             uv_fs_cb cb);
__attribute__((visibility("default"))) int uv_fs_stat(uv_loop_t* loop,
                         uv_fs_t* req,
                         const char* path,
                         uv_fs_cb cb);
__attribute__((visibility("default"))) int uv_fs_fstat(uv_loop_t* loop,
                          uv_fs_t* req,
                          uv_file file,
                          uv_fs_cb cb);
__attribute__((visibility("default"))) int uv_fs_rename(uv_loop_t* loop,
                           uv_fs_t* req,
                           const char* path,
                           const char* new_path,
                           uv_fs_cb cb);
__attribute__((visibility("default"))) int uv_fs_fsync(uv_loop_t* loop,
                          uv_fs_t* req,
                          uv_file file,
                          uv_fs_cb cb);
__attribute__((visibility("default"))) int uv_fs_fdatasync(uv_loop_t* loop,
                              uv_fs_t* req,
                              uv_file file,
                              uv_fs_cb cb);
__attribute__((visibility("default"))) int uv_fs_ftruncate(uv_loop_t* loop,
                              uv_fs_t* req,
                              uv_file file,
                              int64_t offset,
                              uv_fs_cb cb);
__attribute__((visibility("default"))) int uv_fs_sendfile(uv_loop_t* loop,
                             uv_fs_t* req,
                             uv_file out_fd,
                             uv_file in_fd,
                             int64_t in_offset,
                             size_t length,
                             uv_fs_cb cb);
__attribute__((visibility("default"))) int uv_fs_access(uv_loop_t* loop,
                           uv_fs_t* req,
                           const char* path,
                           int mode,
                           uv_fs_cb cb);
__attribute__((visibility("default"))) int uv_fs_chmod(uv_loop_t* loop,
                          uv_fs_t* req,
                          const char* path,
                          int mode,
                          uv_fs_cb cb);
__attribute__((visibility("default"))) int uv_fs_utime(uv_loop_t* loop,
                          uv_fs_t* req,
                          const char* path,
                          double atime,
                          double mtime,
                          uv_fs_cb cb);
__attribute__((visibility("default"))) int uv_fs_futime(uv_loop_t* loop,
                           uv_fs_t* req,
                           uv_file file,
                           double atime,
                           double mtime,
                           uv_fs_cb cb);
__attribute__((visibility("default"))) int uv_fs_lstat(uv_loop_t* loop,
                          uv_fs_t* req,
                          const char* path,
                          uv_fs_cb cb);
__attribute__((visibility("default"))) int uv_fs_link(uv_loop_t* loop,
                         uv_fs_t* req,
                         const char* path,
                         const char* new_path,
                         uv_fs_cb cb);
# 1457 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
__attribute__((visibility("default"))) int uv_fs_symlink(uv_loop_t* loop,
                            uv_fs_t* req,
                            const char* path,
                            const char* new_path,
                            int flags,
                            uv_fs_cb cb);
__attribute__((visibility("default"))) int uv_fs_readlink(uv_loop_t* loop,
                             uv_fs_t* req,
                             const char* path,
                             uv_fs_cb cb);
__attribute__((visibility("default"))) int uv_fs_realpath(uv_loop_t* loop,
                             uv_fs_t* req,
                             const char* path,
                             uv_fs_cb cb);
__attribute__((visibility("default"))) int uv_fs_fchmod(uv_loop_t* loop,
                           uv_fs_t* req,
                           uv_file file,
                           int mode,
                           uv_fs_cb cb);
__attribute__((visibility("default"))) int uv_fs_chown(uv_loop_t* loop,
                          uv_fs_t* req,
                          const char* path,
                          uv_uid_t uid,
                          uv_gid_t gid,
                          uv_fs_cb cb);
__attribute__((visibility("default"))) int uv_fs_fchown(uv_loop_t* loop,
                           uv_fs_t* req,
                           uv_file file,
                           uv_uid_t uid,
                           uv_gid_t gid,
                           uv_fs_cb cb);
__attribute__((visibility("default"))) int uv_fs_lchown(uv_loop_t* loop,
                           uv_fs_t* req,
                           const char* path,
                           uv_uid_t uid,
                           uv_gid_t gid,
                           uv_fs_cb cb);
__attribute__((visibility("default"))) int uv_fs_statfs(uv_loop_t* loop,
                           uv_fs_t* req,
                           const char* path,
                           uv_fs_cb cb);


enum uv_fs_event {
  UV_RENAME = 1,
  UV_CHANGE = 2
};


struct uv_fs_event_s {
  void* data; uv_loop_t* loop; uv_handle_type type; uv_close_cb close_cb; void* handle_queue[2]; union { int fd; void* reserved[4]; } u; uv_handle_t* next_closing; unsigned int flags;

  char* path;
  uv_fs_event_cb cb; void* watchers[2]; int wd;
};





struct uv_fs_poll_s {
  void* data; uv_loop_t* loop; uv_handle_type type; uv_close_cb close_cb; void* handle_queue[2]; union { int fd; void* reserved[4]; } u; uv_handle_t* next_closing; unsigned int flags;

  void* poll_ctx;
};

__attribute__((visibility("default"))) int uv_fs_poll_init(uv_loop_t* loop, uv_fs_poll_t* handle);
__attribute__((visibility("default"))) int uv_fs_poll_start(uv_fs_poll_t* handle,
                               uv_fs_poll_cb poll_cb,
                               const char* path,
                               unsigned int interval);
__attribute__((visibility("default"))) int uv_fs_poll_stop(uv_fs_poll_t* handle);
__attribute__((visibility("default"))) int uv_fs_poll_getpath(uv_fs_poll_t* handle,
                                 char* buffer,
                                 size_t* size);


struct uv_signal_s {
  void* data; uv_loop_t* loop; uv_handle_type type; uv_close_cb close_cb; void* handle_queue[2]; union { int fd; void* reserved[4]; } u; uv_handle_t* next_closing; unsigned int flags;
  uv_signal_cb signal_cb;
  int signum;
  struct { struct uv_signal_s* rbe_left; struct uv_signal_s* rbe_right; struct uv_signal_s* rbe_parent; int rbe_color; } tree_entry; unsigned int caught_signals; unsigned int dispatched_signals;
};

__attribute__((visibility("default"))) int uv_signal_init(uv_loop_t* loop, uv_signal_t* handle);
__attribute__((visibility("default"))) int uv_signal_start(uv_signal_t* handle,
                              uv_signal_cb signal_cb,
                              int signum);
__attribute__((visibility("default"))) int uv_signal_start_oneshot(uv_signal_t* handle,
                                      uv_signal_cb signal_cb,
                                      int signum);
__attribute__((visibility("default"))) int uv_signal_stop(uv_signal_t* handle);

__attribute__((visibility("default"))) void uv_loadavg(double avg[3]);





enum uv_fs_event_flags {







  UV_FS_EVENT_WATCH_ENTRY = 1,
# 1573 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
  UV_FS_EVENT_STAT = 2,






  UV_FS_EVENT_RECURSIVE = 4
};


__attribute__((visibility("default"))) int uv_fs_event_init(uv_loop_t* loop, uv_fs_event_t* handle);
__attribute__((visibility("default"))) int uv_fs_event_start(uv_fs_event_t* handle,
                                uv_fs_event_cb cb,
                                const char* path,
                                unsigned int flags);
__attribute__((visibility("default"))) int uv_fs_event_stop(uv_fs_event_t* handle);
__attribute__((visibility("default"))) int uv_fs_event_getpath(uv_fs_event_t* handle,
                                  char* buffer,
                                  size_t* size);

__attribute__((visibility("default"))) int uv_ip4_addr(const char* ip, int port, struct sockaddr_in* addr);
__attribute__((visibility("default"))) int uv_ip6_addr(const char* ip, int port, struct sockaddr_in6* addr);

__attribute__((visibility("default"))) int uv_ip4_name(const struct sockaddr_in* src, char* dst, size_t size);
__attribute__((visibility("default"))) int uv_ip6_name(const struct sockaddr_in6* src, char* dst, size_t size);

__attribute__((visibility("default"))) int uv_inet_ntop(int af, const void* src, char* dst, size_t size);
__attribute__((visibility("default"))) int uv_inet_pton(int af, const char* src, void* dst);


struct uv_random_s {
  void* data; uv_req_type type; void* reserved[6];

  uv_loop_t* loop;

  int status;
  void* buf;
  size_t buflen;
  uv_random_cb cb;
  struct uv__work work_req;
};

__attribute__((visibility("default"))) int uv_random(uv_loop_t* loop,
                        uv_random_t* req,
                        void *buf,
                        size_t buflen,
                        unsigned flags,
                        uv_random_cb cb);
# 1631 "/home/toto/.env/encours/neovim/.deps/usr/include/uv.h"
__attribute__((visibility("default"))) int uv_if_indextoname(unsigned int ifindex,
                                char* buffer,
                                size_t* size);
__attribute__((visibility("default"))) int uv_if_indextoiid(unsigned int ifindex,
                               char* buffer,
                               size_t* size);

__attribute__((visibility("default"))) int uv_exepath(char* buffer, size_t* size);

__attribute__((visibility("default"))) int uv_cwd(char* buffer, size_t* size);

__attribute__((visibility("default"))) int uv_chdir(const char* dir);

__attribute__((visibility("default"))) uint64_t uv_get_free_memory(void);
__attribute__((visibility("default"))) uint64_t uv_get_total_memory(void);
__attribute__((visibility("default"))) uint64_t uv_get_constrained_memory(void);

__attribute__((visibility("default"))) uint64_t uv_hrtime(void);
__attribute__((visibility("default"))) void uv_sleep(unsigned int msec);

__attribute__((visibility("default"))) void uv_disable_stdio_inheritance(void);

__attribute__((visibility("default"))) int uv_dlopen(const char* filename, uv_lib_t* lib);
__attribute__((visibility("default"))) void uv_dlclose(uv_lib_t* lib);
__attribute__((visibility("default"))) int uv_dlsym(uv_lib_t* lib, const char* name, void** ptr);
__attribute__((visibility("default"))) const char* uv_dlerror(const uv_lib_t* lib);

__attribute__((visibility("default"))) int uv_mutex_init(uv_mutex_t* handle);
__attribute__((visibility("default"))) int uv_mutex_init_recursive(uv_mutex_t* handle);
__attribute__((visibility("default"))) void uv_mutex_destroy(uv_mutex_t* handle);
__attribute__((visibility("default"))) void uv_mutex_lock(uv_mutex_t* handle);
__attribute__((visibility("default"))) int uv_mutex_trylock(uv_mutex_t* handle);
__attribute__((visibility("default"))) void uv_mutex_unlock(uv_mutex_t* handle);

__attribute__((visibility("default"))) int uv_rwlock_init(uv_rwlock_t* rwlock);
__attribute__((visibility("default"))) void uv_rwlock_destroy(uv_rwlock_t* rwlock);
__attribute__((visibility("default"))) void uv_rwlock_rdlock(uv_rwlock_t* rwlock);
__attribute__((visibility("default"))) int uv_rwlock_tryrdlock(uv_rwlock_t* rwlock);
__attribute__((visibility("default"))) void uv_rwlock_rdunlock(uv_rwlock_t* rwlock);
__attribute__((visibility("default"))) void uv_rwlock_wrlock(uv_rwlock_t* rwlock);
__attribute__((visibility("default"))) int uv_rwlock_trywrlock(uv_rwlock_t* rwlock);
__attribute__((visibility("default"))) void uv_rwlock_wrunlock(uv_rwlock_t* rwlock);

__attribute__((visibility("default"))) int uv_sem_init(uv_sem_t* sem, unsigned int value);
__attribute__((visibility("default"))) void uv_sem_destroy(uv_sem_t* sem);
__attribute__((visibility("default"))) void uv_sem_post(uv_sem_t* sem);
__attribute__((visibility("default"))) void uv_sem_wait(uv_sem_t* sem);
__attribute__((visibility("default"))) int uv_sem_trywait(uv_sem_t* sem);

__attribute__((visibility("default"))) int uv_cond_init(uv_cond_t* cond);
__attribute__((visibility("default"))) void uv_cond_destroy(uv_cond_t* cond);
__attribute__((visibility("default"))) void uv_cond_signal(uv_cond_t* cond);
__attribute__((visibility("default"))) void uv_cond_broadcast(uv_cond_t* cond);

__attribute__((visibility("default"))) int uv_barrier_init(uv_barrier_t* barrier, unsigned int count);
__attribute__((visibility("default"))) void uv_barrier_destroy(uv_barrier_t* barrier);
__attribute__((visibility("default"))) int uv_barrier_wait(uv_barrier_t* barrier);

__attribute__((visibility("default"))) void uv_cond_wait(uv_cond_t* cond, uv_mutex_t* mutex);
__attribute__((visibility("default"))) int uv_cond_timedwait(uv_cond_t* cond,
                                uv_mutex_t* mutex,
                                uint64_t timeout);

__attribute__((visibility("default"))) void uv_once(uv_once_t* guard, void (*callback)(void));

__attribute__((visibility("default"))) int uv_key_create(uv_key_t* key);
__attribute__((visibility("default"))) void uv_key_delete(uv_key_t* key);
__attribute__((visibility("default"))) void* uv_key_get(uv_key_t* key);
__attribute__((visibility("default"))) void uv_key_set(uv_key_t* key, void* value);

__attribute__((visibility("default"))) int uv_gettimeofday(uv_timeval64_t* tv);

typedef void (*uv_thread_cb)(void* arg);

__attribute__((visibility("default"))) int uv_thread_create(uv_thread_t* tid, uv_thread_cb entry, void* arg);

typedef enum {
  UV_THREAD_NO_FLAGS = 0x00,
  UV_THREAD_HAS_STACK_SIZE = 0x01
} uv_thread_create_flags;

struct uv_thread_options_s {
  unsigned int flags;
  size_t stack_size;

};

typedef struct uv_thread_options_s uv_thread_options_t;

__attribute__((visibility("default"))) int uv_thread_create_ex(uv_thread_t* tid,
                                  const uv_thread_options_t* params,
                                  uv_thread_cb entry,
                                  void* arg);
__attribute__((visibility("default"))) uv_thread_t uv_thread_self(void);
__attribute__((visibility("default"))) int uv_thread_join(uv_thread_t *tid);
__attribute__((visibility("default"))) int uv_thread_equal(const uv_thread_t* t1, const uv_thread_t* t2);



union uv_any_handle {
  uv_async_t async; uv_check_t check; uv_fs_event_t fs_event; uv_fs_poll_t fs_poll; uv_handle_t handle; uv_idle_t idle; uv_pipe_t pipe; uv_poll_t poll; uv_prepare_t prepare; uv_process_t process; uv_stream_t stream; uv_tcp_t tcp; uv_timer_t timer; uv_tty_t tty; uv_udp_t udp; uv_signal_t signal;
};

union uv_any_req {
  uv_req_t req; uv_connect_t connect; uv_write_t write; uv_shutdown_t shutdown; uv_udp_send_t udp_send; uv_fs_t fs; uv_work_t work; uv_getaddrinfo_t getaddrinfo; uv_getnameinfo_t getnameinfo; uv_random_t random;
};



struct uv_loop_s {

  void* data;

  unsigned int active_handles;
  void* handle_queue[2];
  union {
    void* unused[2];
    unsigned int count;
  } active_reqs;

  unsigned int stop_flag;
  unsigned long flags; int backend_fd; void* pending_queue[2]; void* watcher_queue[2]; uv__io_t** watchers; unsigned int nwatchers; unsigned int nfds; void* wq[2]; uv_mutex_t wq_mutex; uv_async_t wq_async; uv_rwlock_t cloexec_lock; uv_handle_t* closing_handles; void* process_handles[2]; void* prepare_handles[2]; void* check_handles[2]; void* idle_handles[2]; void* async_handles[2]; void (*async_unused)(void); uv__io_t async_io_watcher; int async_wfd; struct { void* min; unsigned int nelts; } timer_heap; uint64_t timer_counter; uint64_t time; int signal_pipefd[2]; uv__io_t signal_io_watcher; uv_signal_t child_watcher; int emfile_fd; uv__io_t inotify_read_watcher; void* inotify_watchers; int inotify_fd;
};

__attribute__((visibility("default"))) void* uv_loop_get_data(const uv_loop_t*);
__attribute__((visibility("default"))) void uv_loop_set_data(uv_loop_t*, void* data);
# 5 "/home/toto/.env/encours/neovim/src/nvim/os/fs_defs.h" 2


typedef struct {
  uv_stat_t stat;
} FileInfo;


typedef struct {
  uint64_t inode;
  uint64_t device_id;
} FileID;



typedef struct {
  uv_fs_t request;
  uv_dirent_t ent;
} Directory;
# 116 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h" 2
# 1 "/home/toto/.env/encours/neovim/src/nvim/terminal.h" 1



# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 5 "/home/toto/.env/encours/neovim/src/nvim/terminal.h" 2



typedef struct terminal Terminal;
typedef void (*terminal_write_cb)(char *buffer, size_t size, void *data);
typedef void (*terminal_resize_cb)(uint16_t width, uint16_t height, void *data);
typedef void (*terminal_close_cb)(void *data);



typedef struct {
  void *data;
  uint16_t width, height;
  terminal_write_cb write_cb;
  terminal_resize_cb resize_cb;
  terminal_close_cb close_cb;
} TerminalOptions;
# 117 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h" 2




typedef struct taggy {
  char_u *tagname;
  fmark_T fmark;
  int cur_match;
  int cur_fnum;
  char_u *user_data;
} taggy_T;

typedef struct buffblock buffblock_T;
typedef struct buffheader buffheader_T;




struct buffblock {
  buffblock_T *b_next;
  char_u b_str[1];
};




struct buffheader {
  buffblock_T bh_first;
  buffblock_T *bh_curr;
  size_t bh_index;
  size_t bh_space;
};

typedef struct
{
  buffheader_T sr_redobuff;
  buffheader_T sr_old_redobuff;
} save_redo_T;






typedef struct {
  int wo_arab;

  int wo_bri;

  char_u *wo_briopt;

  int wo_diff;

  char_u *wo_fdc;

  char_u *wo_fdc_save;

  int wo_fen;

  int wo_fen_save;


  char_u *wo_fdi;

  long wo_fdl;

  int wo_fdl_save;


  char_u *wo_fdm;

  char_u *wo_fdm_save;

  long wo_fml;

  long wo_fdn;

  char_u *wo_fde;

  char_u *wo_fdt;

  char_u *wo_fmr;

  int wo_lbr;

  int wo_list;

  int wo_nu;

  int wo_rnu;

  long wo_nuw;

  int wo_wfh;

  int wo_wfw;

  int wo_pvw;

  int wo_rl;

  char_u *wo_rlc;

  long wo_scr;

  int wo_spell;

  int wo_cuc;

  int wo_cul;

  char_u *wo_cc;

  char_u *wo_stl;

  int wo_scb;

  int wo_diff_saved;

  int wo_scb_save;

  int wo_wrap;

  int wo_wrap_save;

  char_u *wo_cocu;

  long wo_cole;

  int wo_crb;

  int wo_crb_save;

  char_u *wo_scl;

  char_u *wo_winhl;

  char_u *wo_fcs;

  char_u *wo_lcs;

  long wo_winbl;


  LastSet wo_script_ctx[WV_COUNT];

} winopt_T;
# 275 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h"
struct wininfo_S {
  wininfo_T *wi_next;
  wininfo_T *wi_prev;
  win_T *wi_win;
  pos_T wi_fpos;
  
# 280 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 280 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h"
      wi_optset;
  winopt_T wi_opt;
  
# 282 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 282 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h"
      wi_fold_manual;
  garray_T wi_folds;
};







typedef struct arglist {
  garray_T al_ga;
  int al_refcount;
  int id;
} alist_T;
# 305 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h"
typedef struct argentry {
  char_u *ae_fname;
  int ae_fnum;
} aentry_T;
# 322 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h"
typedef struct {
  char_u *tb_buf;
  char_u *tb_noremap;
  int tb_buflen;
  int tb_off;
  int tb_len;
  int tb_maplen;
  int tb_silent;
  int tb_no_abbr_cnt;
  int tb_change_cnt;
} typebuf_T;


typedef struct {
  typebuf_T save_typebuf;
  
# 337 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 337 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h"
      typebuf_valid;
  int old_char;
  int old_mod_mask;
  buffheader_T save_readbuf1;
  buffheader_T save_readbuf2;
  String save_inputbuf;
} tasave_T;




typedef struct mapblock mapblock_T;
struct mapblock {
  mapblock_T *m_next;
  char_u *m_keys;
  char_u *m_str;
  char_u *m_orig_str;
  int m_keylen;
  int m_mode;
  int m_noremap;
  char m_silent;
  char m_nowait;
  char m_expr;
  sctx_T m_script_ctx;
};




struct stl_hlrec {
  char_u *start;
  int userhl;
};
# 379 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h"
typedef struct qf_info_S qf_info_T;




typedef struct {
  proftime_T total;
  proftime_T slowest;
  long count;
  long match;
} syn_time_T;





typedef struct {
  hashtab_T b_keywtab;
  hashtab_T b_keywtab_ic;
  int b_syn_error;
  
# 399 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 399 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h"
      b_syn_slow;
  int b_syn_ic;
  int b_syn_spell;
  garray_T b_syn_patterns;
  garray_T b_syn_clusters;
  int b_spell_cluster_id;
  int b_nospell_cluster_id;
  int b_syn_containedin;

  int b_syn_sync_flags;
  int16_t b_syn_sync_id;
  long b_syn_sync_minlines;
  long b_syn_sync_maxlines;
  long b_syn_sync_linebreaks;
  char_u *b_syn_linecont_pat;
  regprog_T *b_syn_linecont_prog;
  syn_time_T b_syn_linecont_time;
  int b_syn_linecont_ic;
  int b_syn_topgrp;
  int b_syn_conceal;
  int b_syn_folditems;
# 433 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h"
  synstate_T *b_sst_array;
  int b_sst_len;
  synstate_T *b_sst_first;
  synstate_T *b_sst_firstfree;
  int b_sst_freecount;
  linenr_T b_sst_check_lnum;
  disptick_T b_sst_lasttick;


  garray_T b_langp;
  
# 443 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 443 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h"
      b_spell_ismw[256];
  char_u *b_spell_ismw_mb;
  char_u *b_p_spc;
  regprog_T *b_cap_prog;
  char_u *b_p_spf;
  char_u *b_p_spl;
  int b_cjk;
  char_u b_syn_chartab[32];
  char_u *b_syn_isk;
} synblock_T;




typedef struct { typval_T di_tv; uint8_t di_flags; char_u di_key[sizeof("changedtick")]; } ChangedtickDictItem;

typedef struct {
  LuaRef on_lines;
  LuaRef on_bytes;
  LuaRef on_changedtick;
  LuaRef on_detach;
  
# 464 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 464 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h"
      utf_sizes;
} BufUpdateCallbacks;



extern int curbuf_splice_pending ;
# 485 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h"
struct file_buffer {
  handle_T handle;


  memline_T b_ml;

  buf_T *b_next;
  buf_T *b_prev;

  int b_nwindows;

  int b_flags;
  int b_locked;
# 506 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h"
  char_u *b_ffname;
  char_u *b_sfname;
  char_u *b_fname;

  
# 510 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 510 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h"
      file_id_valid;
  FileID file_id;

  int b_changed;





  ChangedtickDictItem changedtick_di;

  varnumber_T b_last_changedtick;

  varnumber_T b_last_changedtick_pum;


  
# 526 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 526 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h"
      b_saving;






  
# 533 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 533 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h"
      b_mod_set;

  linenr_T b_mod_top;
  linenr_T b_mod_bot;

  long b_mod_xlines;

  wininfo_T *b_wininfo;

  long b_mtime;
  long b_mtime_read;
  uint64_t b_orig_size;
  int b_orig_mode;
  time_t b_last_used;


  fmark_T b_namedm[('z' - 'a' + 1)];


  visualinfo_T b_visual;
  int b_visual_mode_eval;

  fmark_T b_last_cursor;

  fmark_T b_last_insert;
  fmark_T b_last_change;




  fmark_T b_changelist[100];
  int b_changelistlen;
  
# 565 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 565 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h"
      b_new_change;





  uint64_t b_chartab[4];


  mapblock_T *(b_maphash[256]);


  mapblock_T *b_first_abbr;

  garray_T b_ucmds;



  pos_T b_op_start;
  pos_T b_op_start_orig;
  pos_T b_op_end;

  
# 587 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 587 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h"
      b_marks_read;




  u_header_T *b_u_oldhead;
  u_header_T *b_u_newhead;

  u_header_T *b_u_curhead;
  int b_u_numhead;
  
# 597 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 597 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h"
      b_u_synced;
  long b_u_seq_last;
  long b_u_save_nr_last;
  long b_u_seq_cur;
  time_t b_u_time_cur;
  long b_u_save_nr_cur;




  char_u *b_u_line_ptr;
  linenr_T b_u_line_lnum;
  colnr_T b_u_line_colnr;

  
# 611 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 611 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h"
      b_scanned;


  long b_p_iminsert;
  long b_p_imsearch;





  int16_t b_kmap_state;


  garray_T b_kmap_ga;






  
# 631 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 631 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h"
      b_p_initialized;

  LastSet b_p_script_ctx[BV_COUNT];

  int b_p_ai;
  int b_p_ai_nopaste;
  char_u *b_p_bkc;
  unsigned int b_bkc_flags;
  int b_p_ci;
  int b_p_bin;
  int b_p_bomb;
  char_u *b_p_bh;
  char_u *b_p_bt;
  int b_has_qf_entry;
  int b_p_bl;
  long b_p_channel;
  int b_p_cin;
  char_u *b_p_cino;
  char_u *b_p_cink;
  char_u *b_p_cinw;
  char_u *b_p_com;
  char_u *b_p_cms;
  char_u *b_p_cpt;
  char_u *b_p_cfu;
  char_u *b_p_ofu;
  char_u *b_p_tfu;
  int b_p_eol;
  int b_p_fixeol;
  int b_p_et;
  int b_p_et_nobin;
  int b_p_et_nopaste;
  char_u *b_p_fenc;
  char_u *b_p_ff;
  char_u *b_p_ft;
  char_u *b_p_fo;
  char_u *b_p_flp;
  int b_p_inf;
  char_u *b_p_isk;
  char_u *b_p_def;
  char_u *b_p_inc;
  char_u *b_p_inex;
  uint32_t b_p_inex_flags;
  char_u *b_p_inde;
  uint32_t b_p_inde_flags;
  char_u *b_p_indk;
  char_u *b_p_fp;
  char_u *b_p_fex;
  uint32_t b_p_fex_flags;
  char_u *b_p_kp;
  int b_p_lisp;
  char_u *b_p_menc;
  char_u *b_p_mps;
  int b_p_ml;
  int b_p_ml_nobin;
  int b_p_ma;
  char_u *b_p_nf;
  int b_p_pi;
  char_u *b_p_qe;
  int b_p_ro;
  long b_p_sw;
  long b_p_scbk;
  int b_p_si;
  long b_p_sts;
  long b_p_sts_nopaste;
  char_u *b_p_sua;
  int b_p_swf;
  long b_p_smc;
  char_u *b_p_syn;
  long b_p_ts;
  long b_p_tw;
  long b_p_tw_nobin;
  long b_p_tw_nopaste;
  long b_p_wm;
  long b_p_wm_nobin;
  long b_p_wm_nopaste;
  char_u *b_p_keymap;


  char_u *b_p_gp;
  char_u *b_p_mp;
  char_u *b_p_efm;
  char_u *b_p_ep;
  char_u *b_p_path;
  int b_p_ar;
  char_u *b_p_tags;
  char_u *b_p_tc;
  unsigned b_tc_flags;
  char_u *b_p_dict;
  char_u *b_p_tsr;
  long b_p_ul;
  int b_p_udf;
  char_u *b_p_lw;




  int b_ind_level;
  int b_ind_open_imag;
  int b_ind_no_brace;
  int b_ind_first_open;
  int b_ind_open_extra;
  int b_ind_close_extra;
  int b_ind_open_left_imag;
  int b_ind_jump_label;
  int b_ind_case;
  int b_ind_case_code;
  int b_ind_case_break;
  int b_ind_param;
  int b_ind_func_type;
  int b_ind_comment;
  int b_ind_in_comment;
  int b_ind_in_comment2;
  int b_ind_cpp_baseclass;
  int b_ind_continuation;
  int b_ind_unclosed;
  int b_ind_unclosed2;
  int b_ind_unclosed_noignore;
  int b_ind_unclosed_wrapped;
  int b_ind_unclosed_whiteok;
  int b_ind_matching_paren;
  int b_ind_paren_prev;
  int b_ind_maxparen;
  int b_ind_maxcomment;
  int b_ind_scopedecl;
  int b_ind_scopedecl_code;
  int b_ind_java;
  int b_ind_js;
  int b_ind_keep_case_label;
  int b_ind_hash_comment;
  int b_ind_cpp_namespace;
  int b_ind_if_for_while;
  int b_ind_cpp_extern_c;

  linenr_T b_no_eol_lnum;


  int b_start_eol;
  int b_start_ffc;
  char_u *b_start_fenc;
  int b_bad_char;
  int b_start_bomb;

  ScopeDictDictItem b_bufvar;
  dict_T *b_vars;





  
# 780 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 780 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h"
      b_may_swap;
  
# 781 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 781 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h"
      b_did_warn;







  
# 789 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 789 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h"
      b_help;

  
# 791 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 791 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h"
      b_spell;



  char_u *b_prompt_text;
  Callback b_prompt_callback;
  Callback b_prompt_interrupt;
  int b_prompt_insert;


  synblock_T b_s;



  signlist_T *b_signlist;
  int b_signcols_max;
  int b_signcols;

  Terminal *terminal;

  dict_T *additional_data;

  int b_mapped_ctrl_c;

  MarkTree b_marktree[1];
  Map_uint64_t_ExtmarkItem *b_extmark_index;
  Map_uint64_t_ExtmarkNs *b_extmark_ns;



  struct { size_t size; size_t capacity; uint64_t *items; } update_channels;

  struct { size_t size; size_t capacity; BufUpdateCallbacks *items; } update_callbacks;


  
# 826 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 826 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h"
      update_need_codepoints;





  size_t deleted_bytes;
  size_t deleted_codepoints;
  size_t deleted_codeunits;


  int flush_count;

  
# 839 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 839 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h"
      b_luahl;
  LuaRef b_luahl_start;
  LuaRef b_luahl_window;
  LuaRef b_luahl_line;
  LuaRef b_luahl_end;

  int b_diff_failed;
};
# 867 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h"
typedef struct diffblock_S diff_T;
struct diffblock_S {
  diff_T *df_next;
  linenr_T df_lnum[8];
  linenr_T df_count[8];
};
# 882 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h"
typedef struct tabpage_S tabpage_T;
struct tabpage_S {
  handle_T handle;
  tabpage_T *tp_next;
  frame_T *tp_topframe;
  win_T *tp_curwin;
  win_T *tp_prevwin;
  win_T *tp_firstwin;
  win_T *tp_lastwin;
  long tp_old_Rows;
  long tp_old_Columns;
  long tp_ch_used;


  diff_T *tp_first_diff;
  buf_T *(tp_diffbuf[8]);
  int tp_diff_invalid;
  int tp_diff_update;
  frame_T *(tp_snapshot[2]);
  ScopeDictDictItem tp_winvar;
  dict_T *tp_vars;
  char_u *tp_localdir;
};
# 918 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h"
typedef struct w_line {
  linenr_T wl_lnum;
  uint16_t wl_size;
  char wl_valid;
  char wl_folded;
  linenr_T wl_lastlnum;
} wline_T;





struct frame_S {
  char fr_layout;
  int fr_width;
  int fr_newwidth;
  int fr_height;
  int fr_newheight;
  frame_T *fr_parent;
  frame_T *fr_next;

  frame_T *fr_prev;


  frame_T *fr_child;
  win_T *fr_win;
};
# 956 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h"
typedef struct {
  regmmatch_T rm;

  buf_T *buf;
  linenr_T lnum;
  int attr;
  int attr_cur;
  linenr_T first_lnum;
  colnr_T startcol;
  colnr_T endcol;
  
# 966 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 966 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h"
      is_addpos;
  proftime_T tm;
} match_T;





typedef struct
{
    linenr_T lnum;
    colnr_T col;
    int len;
} llpos_T;



typedef struct posmatch posmatch_T;
struct posmatch
{
    llpos_T pos[8];
    int cur;
    linenr_T toplnum;
    linenr_T botlnum;
};





typedef struct matchitem matchitem_T;
struct matchitem {
  matchitem_T *next;
  int id;
  int priority;
  char_u *pattern;
  int hlg_id;
  regmmatch_T match;
  posmatch_T pos;
  match_T hl;
  int conceal_char;
};

typedef int FloatAnchor;

enum {
  kFloatAnchorEast = 1,
  kFloatAnchorSouth = 2,
};





extern const char *const float_anchor_str[] ;

typedef enum {
  kFloatRelativeEditor = 0,
  kFloatRelativeWindow = 1,
  kFloatRelativeCursor = 2,
} FloatRelative;

extern const char *const float_relative_str[]
                                                                  ;

typedef enum {
  kWinStyleUnused = 0,
  kWinStyleMinimal,
} WinStyle;

typedef struct {
  Window window;
  lpos_T bufpos;
  int height, width;
  double row, col;
  FloatAnchor anchor;
  FloatRelative relative;
  
# 1043 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 1043 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h"
      external;
  
# 1044 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 1044 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h"
      focusable;
  WinStyle style;
} FloatConfig;
# 1057 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h"
typedef struct
{
  int w_topline_save;
  int w_topline_corr;
  pos_T w_cursor_save;
  pos_T w_cursor_corr;
} pos_save_T;




enum {
  MENU_INDEX_INVALID = -1,
  MENU_INDEX_NORMAL = 0,
  MENU_INDEX_VISUAL = 1,
  MENU_INDEX_SELECT = 2,
  MENU_INDEX_OP_PENDING = 3,
  MENU_INDEX_INSERT = 4,
  MENU_INDEX_CMDLINE = 5,
  MENU_INDEX_TIP = 6,
  MENU_MODES = 7,
};

typedef struct VimMenu vimmenu_T;

struct VimMenu {
  int modes;
  int enabled;
  char_u *name;
  char_u *dname;
  char_u *en_name;

  char_u *en_dname;
  int mnemonic;
  char_u *actext;
  long priority;
  char_u *strings[MENU_MODES];
  int noremap[MENU_MODES];
  
# 1095 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 1095 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h"
      silent[MENU_MODES];
  vimmenu_T *children;
  vimmenu_T *parent;
  vimmenu_T *next;
};

typedef struct {
  int wb_startcol;
  int wb_endcol;
  vimmenu_T *wb_menu;
} winbar_item_T;




struct window_S {
  handle_T handle;

  buf_T *w_buffer;


  synblock_T *w_s;

  int w_hl_id_normal;
  int w_hl_attr_normal;

  int w_hl_ids[HLF_COUNT];
  int w_hl_attrs[HLF_COUNT];

  int w_hl_needs_update;

  win_T *w_prev;
  win_T *w_next;
  
# 1128 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 1128 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h"
      w_closing;


  frame_T *w_frame;

  pos_T w_cursor;

  colnr_T w_curswant;



  int w_set_curswant;



  linenr_T w_last_cursorline;
  pos_T w_last_cursormoved;


  char w_old_visual_mode;
  linenr_T w_old_cursor_lnum;
  colnr_T w_old_cursor_fcol;
  colnr_T w_old_cursor_lcol;
  linenr_T w_old_visual_lnum;
  colnr_T w_old_visual_col;
  colnr_T w_old_curswant;


  struct {
    int eol;
    int ext;
    int prec;
    int nbsp;
    int space;
    int tab1;
    int tab2;
    int tab3;
    int trail;
    int conceal;
  } w_p_lcs_chars;


  struct {
    int stl;
    int stlnc;
    int vert;
    int fold;
    int foldopen;
    int foldclosed;
    int foldsep;
    int diff;
    int msgsep;
    int eob;
  } w_p_fcs_chars;





  linenr_T w_topline;

  char w_topline_was_set;

  int w_topfill;
  int w_old_topfill;
  
# 1193 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 1193 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h"
      w_botfill;

  
# 1195 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 1195 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h"
      w_old_botfill;
  colnr_T w_leftcol;


  colnr_T w_skipcol;






  int w_winrow;
  int w_height;

  int w_status_height;
  int w_wincol;
  int w_width;
  int w_vsep_width;
  pos_save_T w_save_cursor;


  int w_height_inner;
  int w_width_inner;

  int w_height_request;
  int w_width_request;
# 1231 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h"
  int w_valid;
  pos_T w_valid_cursor;

  colnr_T w_valid_leftcol;

  
# 1236 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 1236 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h"
      w_viewport_invalid;





  int w_cline_height;
  
# 1243 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 1243 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h"
      w_cline_folded;

  int w_cline_row;

  colnr_T w_virtcol;
# 1259 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h"
  int w_wrow, w_wcol;

  linenr_T w_botline;

  int w_empty_rows;
  int w_filler_rows;
# 1277 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h"
  int w_lines_valid;
  wline_T *w_lines;

  garray_T w_folds;
  
# 1281 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 1281 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h"
      w_fold_manual;

  
# 1283 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 1283 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h"
      w_foldinvalid;

  int w_nrwidth;






  int w_redr_type;
  int w_upd_rows;

  linenr_T w_redraw_top;
  linenr_T w_redraw_bot;
  int w_redr_status;


  pos_T w_ru_cursor;
  colnr_T w_ru_virtcol;
  linenr_T w_ru_topline;
  linenr_T w_ru_line_count;
  int w_ru_topfill;
  char w_ru_empty;

  int w_alt_fnum;

  alist_T *w_alist;
  int w_arg_idx;

  int w_arg_idx_invalid;

  char_u *w_localdir;

  vimmenu_T *w_winbar;
  winbar_item_T *w_winbar_items;
  int w_winbar_height;






  winopt_T w_onebuf_opt;
  winopt_T w_allbuf_opt;


  uint32_t w_p_stl_flags;
  uint32_t w_p_fde_flags;
  uint32_t w_p_fdt_flags;
  int *w_p_cc_cols;
  long w_p_siso;
  long w_p_so;

  int w_briopt_min;
  int w_briopt_shift;
  
# 1338 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 1338 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h"
      w_briopt_sbr;




  long w_scbind_pos;

  ScopeDictDictItem w_winvar;
  dict_T *w_vars;






  pos_T w_pcmark;
  pos_T w_prev_pcmark;




  xfmark_T w_jumplist[100];
  int w_jumplistlen;
  int w_jumplistidx;

  int w_changelistidx;

  matchitem_T *w_match_head;
  int w_next_match_id;







  taggy_T w_tagstack[20];
  int w_tagstackidx;
  int w_tagstacklen;

  ScreenGrid w_grid;
  
# 1379 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 1379 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h"
      w_pos_changed;
  
# 1380 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 1380 "/home/toto/.env/encours/neovim/src/nvim/buffer_defs.h"
      w_floating;
  FloatConfig w_float_config;







  int w_fraction;
  int w_prev_fraction_row;

  linenr_T w_nrwidth_line_count;

  int w_nrwidth_width;

  qf_info_T *w_llist;


  qf_info_T *w_llist_ref;
};

static inline int win_hl_attr(win_T *wp, int hlf)
{
  return wp->w_hl_attrs[hlf];
}
# 7 "/home/toto/.env/encours/neovim/src/nvim/normal.h" 2
# 17 "/home/toto/.env/encours/neovim/src/nvim/normal.h"
typedef enum {
  kMTCharWise = 0,
  kMTLineWise = 1,
  kMTBlockWise = 2,
  kMTUnknown = -1
} MotionType;




typedef struct oparg_S {
  int op_type;
  int regname;
  MotionType motion_type;
  int motion_force;
  
# 32 "/home/toto/.env/encours/neovim/src/nvim/normal.h" 3 4
 _Bool 
# 32 "/home/toto/.env/encours/neovim/src/nvim/normal.h"
      use_reg_one;

  
# 34 "/home/toto/.env/encours/neovim/src/nvim/normal.h" 3 4
 _Bool 
# 34 "/home/toto/.env/encours/neovim/src/nvim/normal.h"
      inclusive;

  
# 36 "/home/toto/.env/encours/neovim/src/nvim/normal.h" 3 4
 _Bool 
# 36 "/home/toto/.env/encours/neovim/src/nvim/normal.h"
      end_adjusted;

  pos_T start;
  pos_T end;
  pos_T cursor_start;

  long line_count;

  
# 44 "/home/toto/.env/encours/neovim/src/nvim/normal.h" 3 4
 _Bool 
# 44 "/home/toto/.env/encours/neovim/src/nvim/normal.h"
      empty;

  
# 46 "/home/toto/.env/encours/neovim/src/nvim/normal.h" 3 4
 _Bool 
# 46 "/home/toto/.env/encours/neovim/src/nvim/normal.h"
      is_VIsual;
  colnr_T start_vcol;
  colnr_T end_vcol;
  long prev_opcount;
  long prev_count0;
} oparg_T;




typedef struct cmdarg_S {
  oparg_T *oap;
  int prechar;
  int cmdchar;
  int nchar;
  int ncharC1;
  int ncharC2;
  int extra_char;
  long opcount;
  long count0;
  long count1;
  int arg;
  int retval;
  char_u *searchbuf;
} cmdarg_T;
# 9 "/home/toto/.env/encours/neovim/src/nvim/ex_cmds_defs.h" 2
# 81 "/home/toto/.env/encours/neovim/src/nvim/ex_cmds_defs.h"
typedef struct exarg exarg_T;






typedef void (*ex_func_T)(exarg_T *eap);

typedef char_u *(*LineGetter)(int, void *, int, 
# 90 "/home/toto/.env/encours/neovim/src/nvim/ex_cmds_defs.h" 3 4
                                               _Bool
# 90 "/home/toto/.env/encours/neovim/src/nvim/ex_cmds_defs.h"
                                                   );


typedef struct cmdname {
  char_u *cmd_name;
  ex_func_T cmd_func;
  uint32_t cmd_argt;
  int cmd_addr_type;
} CommandDefinition;




typedef struct eslist_elem eslist_T;
struct eslist_elem {
  int saved_emsg_silent;
  eslist_T *next;
};



enum {
  CSTACK_LEN = 50,
};

typedef struct {
  int cs_flags[CSTACK_LEN];
  char cs_pending[CSTACK_LEN];
  union {
    void *csp_rv[CSTACK_LEN];
    void *csp_ex[CSTACK_LEN];
  } cs_pend;
  void *cs_forinfo[CSTACK_LEN];
  int cs_line[CSTACK_LEN];
  int cs_idx;
  int cs_looplevel;
  int cs_trylevel;
  eslist_T *cs_emsg_silent_list;
  int cs_lflags;
} cstack_T;




enum {
  CSL_HAD_LOOP = 1,
  CSL_HAD_ENDLOOP = 2,
  CSL_HAD_CONT = 4,
  CSL_HAD_FINA = 8,
};


struct exarg {
  char_u *arg;
  char_u *nextcmd;
  char_u *cmd;
  char_u **cmdlinep;
  cmdidx_T cmdidx;
  uint32_t argt;
  int skip;
  int forceit;
  int addr_count;
  linenr_T line1;
  linenr_T line2;
  int addr_type;
  int flags;
  char_u *do_ecmd_cmd;
  linenr_T do_ecmd_lnum;
  int append;
  int usefilter;
  int amount;
  int regname;
  int force_bin;
  int read_edit;
  int force_ff;
  int force_enc;
  int bad_char;
  int useridx;
  char_u *errmsg;
  LineGetter getline;
  void *cookie;
  cstack_T *cstack;
};
# 183 "/home/toto/.env/encours/neovim/src/nvim/ex_cmds_defs.h"
struct expand {
  int xp_context;
  char_u *xp_pattern;
  size_t xp_pattern_len;
  char_u *xp_arg;
  sctx_T xp_script_ctx;
  int xp_backslash;

  int xp_shell;


  int xp_numfiles;
  char_u **xp_files;
  char_u *xp_line;
  int xp_col;
};
# 208 "/home/toto/.env/encours/neovim/src/nvim/ex_cmds_defs.h"
typedef struct {
  int split;
  int tab;
  
# 211 "/home/toto/.env/encours/neovim/src/nvim/ex_cmds_defs.h" 3 4
 _Bool 
# 211 "/home/toto/.env/encours/neovim/src/nvim/ex_cmds_defs.h"
      browse;
  
# 212 "/home/toto/.env/encours/neovim/src/nvim/ex_cmds_defs.h" 3 4
 _Bool 
# 212 "/home/toto/.env/encours/neovim/src/nvim/ex_cmds_defs.h"
      confirm;
  
# 213 "/home/toto/.env/encours/neovim/src/nvim/ex_cmds_defs.h" 3 4
 _Bool 
# 213 "/home/toto/.env/encours/neovim/src/nvim/ex_cmds_defs.h"
      hide;
  
# 214 "/home/toto/.env/encours/neovim/src/nvim/ex_cmds_defs.h" 3 4
 _Bool 
# 214 "/home/toto/.env/encours/neovim/src/nvim/ex_cmds_defs.h"
      keepalt;
  
# 215 "/home/toto/.env/encours/neovim/src/nvim/ex_cmds_defs.h" 3 4
 _Bool 
# 215 "/home/toto/.env/encours/neovim/src/nvim/ex_cmds_defs.h"
      keepjumps;
  
# 216 "/home/toto/.env/encours/neovim/src/nvim/ex_cmds_defs.h" 3 4
 _Bool 
# 216 "/home/toto/.env/encours/neovim/src/nvim/ex_cmds_defs.h"
      keepmarks;
  
# 217 "/home/toto/.env/encours/neovim/src/nvim/ex_cmds_defs.h" 3 4
 _Bool 
# 217 "/home/toto/.env/encours/neovim/src/nvim/ex_cmds_defs.h"
      keeppatterns;
  
# 218 "/home/toto/.env/encours/neovim/src/nvim/ex_cmds_defs.h" 3 4
 _Bool 
# 218 "/home/toto/.env/encours/neovim/src/nvim/ex_cmds_defs.h"
      lockmarks;
  
# 219 "/home/toto/.env/encours/neovim/src/nvim/ex_cmds_defs.h" 3 4
 _Bool 
# 219 "/home/toto/.env/encours/neovim/src/nvim/ex_cmds_defs.h"
      noswapfile;
  char_u *save_ei;
  regmatch_T filter_regmatch;
  
# 222 "/home/toto/.env/encours/neovim/src/nvim/ex_cmds_defs.h" 3 4
 _Bool 
# 222 "/home/toto/.env/encours/neovim/src/nvim/ex_cmds_defs.h"
      filter_force;
} cmdmod_T;
# 6 "/home/toto/.env/encours/neovim/src/nvim/ex_eval.h" 2
# 42 "/home/toto/.env/encours/neovim/src/nvim/ex_eval.h"
struct msglist {
  char_u *msg;
  char_u *throw_msg;
  struct msglist *next;
};


typedef enum
{
  ET_USER,
  ET_ERROR,
  ET_INTERRUPT,
} except_type_T;





typedef struct vim_exception except_T;
struct vim_exception {
  except_type_T type;
  char_u *value;
  struct msglist *messages;
  char_u *throw_name;
  linenr_T throw_lnum;
  except_T *caught;
};






typedef struct cleanup_stuff cleanup_T;
struct cleanup_stuff {
  int pending;
  except_T *exception;
};
# 9 "/home/toto/.env/encours/neovim/src/nvim/globals.h" 2


# 1 "/home/toto/.env/encours/neovim/src/nvim/menu.h" 1
# 12 "/home/toto/.env/encours/neovim/src/nvim/globals.h" 2


# 1 "/home/toto/.env/encours/neovim/src/nvim/event/loop.h" 1







# 1 "/home/toto/.env/encours/neovim/src/nvim/lib/klist.h" 1
# 30 "/home/toto/.env/encours/neovim/src/nvim/lib/klist.h"
# 1 "/usr/include/assert.h" 1 3 4
# 31 "/home/toto/.env/encours/neovim/src/nvim/lib/klist.h" 2


# 1 "/home/toto/.env/encours/neovim/src/nvim/func_attr.h" 1
# 34 "/home/toto/.env/encours/neovim/src/nvim/lib/klist.h" 2
# 9 "/home/toto/.env/encours/neovim/src/nvim/event/loop.h" 2

# 1 "/home/toto/.env/encours/neovim/src/nvim/event/multiqueue.h" 1





# 1 "/home/toto/.env/encours/neovim/src/nvim/event/defs.h" 1



# 1 "/usr/include/assert.h" 1 3 4
# 5 "/home/toto/.env/encours/neovim/src/nvim/event/defs.h" 2




typedef void (*argv_callback)(void **argv);
typedef struct message {
  argv_callback handler;
  void *argv[10];
} Event;
typedef void(*event_scheduler)(Event event, void *data);
# 30 "/home/toto/.env/encours/neovim/src/nvim/event/defs.h"
static inline Event event_create(argv_callback cb, int argc, ...)
{
  
# 32 "/home/toto/.env/encours/neovim/src/nvim/event/defs.h" 3 4
 ((void) sizeof ((
# 32 "/home/toto/.env/encours/neovim/src/nvim/event/defs.h"
 argc <= 10
# 32 "/home/toto/.env/encours/neovim/src/nvim/event/defs.h" 3 4
 ) ? 1 : 0), __extension__ ({ if (
# 32 "/home/toto/.env/encours/neovim/src/nvim/event/defs.h"
 argc <= 10
# 32 "/home/toto/.env/encours/neovim/src/nvim/event/defs.h" 3 4
 ) ; else __assert_fail (
# 32 "/home/toto/.env/encours/neovim/src/nvim/event/defs.h"
 "argc <= EVENT_HANDLER_MAX_ARGC"
# 32 "/home/toto/.env/encours/neovim/src/nvim/event/defs.h" 3 4
 , "/home/toto/.env/encours/neovim/src/nvim/event/defs.h", 32, __extension__ __PRETTY_FUNCTION__); }))
# 32 "/home/toto/.env/encours/neovim/src/nvim/event/defs.h"
                                       ;
  Event event;
  do { 
# 34 "/home/toto/.env/encours/neovim/src/nvim/event/defs.h" 3 4
 ((void) sizeof ((
# 34 "/home/toto/.env/encours/neovim/src/nvim/event/defs.h"
 argc <= 10
# 34 "/home/toto/.env/encours/neovim/src/nvim/event/defs.h" 3 4
 ) ? 1 : 0), __extension__ ({ if (
# 34 "/home/toto/.env/encours/neovim/src/nvim/event/defs.h"
 argc <= 10
# 34 "/home/toto/.env/encours/neovim/src/nvim/event/defs.h" 3 4
 ) ; else __assert_fail (
# 34 "/home/toto/.env/encours/neovim/src/nvim/event/defs.h"
 "argc <= EVENT_HANDLER_MAX_ARGC"
# 34 "/home/toto/.env/encours/neovim/src/nvim/event/defs.h" 3 4
 , "/home/toto/.env/encours/neovim/src/nvim/event/defs.h", 34, __extension__ __PRETTY_FUNCTION__); }))
# 34 "/home/toto/.env/encours/neovim/src/nvim/event/defs.h"
 ; (&event)->handler = cb; if (argc) { va_list args; 
# 34 "/home/toto/.env/encours/neovim/src/nvim/event/defs.h" 3 4
 __builtin_va_start(
# 34 "/home/toto/.env/encours/neovim/src/nvim/event/defs.h"
 args
# 34 "/home/toto/.env/encours/neovim/src/nvim/event/defs.h" 3 4
 ,
# 34 "/home/toto/.env/encours/neovim/src/nvim/event/defs.h"
 argc
# 34 "/home/toto/.env/encours/neovim/src/nvim/event/defs.h" 3 4
 )
# 34 "/home/toto/.env/encours/neovim/src/nvim/event/defs.h"
 ; for (int i = 0; i < argc; i++) { (&event)->argv[i] = 
# 34 "/home/toto/.env/encours/neovim/src/nvim/event/defs.h" 3 4
 __builtin_va_arg(
# 34 "/home/toto/.env/encours/neovim/src/nvim/event/defs.h"
 args
# 34 "/home/toto/.env/encours/neovim/src/nvim/event/defs.h" 3 4
 ,
# 34 "/home/toto/.env/encours/neovim/src/nvim/event/defs.h"
 void *
# 34 "/home/toto/.env/encours/neovim/src/nvim/event/defs.h" 3 4
 )
# 34 "/home/toto/.env/encours/neovim/src/nvim/event/defs.h"
 ; } 
# 34 "/home/toto/.env/encours/neovim/src/nvim/event/defs.h" 3 4
 __builtin_va_end(
# 34 "/home/toto/.env/encours/neovim/src/nvim/event/defs.h"
 args
# 34 "/home/toto/.env/encours/neovim/src/nvim/event/defs.h" 3 4
 )
# 34 "/home/toto/.env/encours/neovim/src/nvim/event/defs.h"
 ; } } while (0);
  return event;
}
# 7 "/home/toto/.env/encours/neovim/src/nvim/event/multiqueue.h" 2


typedef struct multiqueue MultiQueue;
typedef void (*put_callback)(MultiQueue *multiq, void *data);
# 11 "/home/toto/.env/encours/neovim/src/nvim/event/loop.h" 2

typedef void * WatcherPtr;


struct __kl1_WatcherPtr { WatcherPtr data; struct __kl1_WatcherPtr *next; }; typedef struct __kl1_WatcherPtr kl1_WatcherPtr; typedef struct { size_t cnt, n, max; kl1_WatcherPtr **buf; } kmp_WatcherPtr_t; static inline kmp_WatcherPtr_t *kmp_init_WatcherPtr(void) { return xcalloc(1, sizeof(kmp_WatcherPtr_t)); } static inline void kmp_destroy_WatcherPtr(kmp_WatcherPtr_t *mp) __attribute__((unused)); static inline void kmp_destroy_WatcherPtr(kmp_WatcherPtr_t *mp) { size_t k; for (k = 0; k < mp->n; k++) { ; do { void **ptr_ = (void **)&(mp->buf[k]); xfree(*ptr_); *ptr_ = 
# 15 "/home/toto/.env/encours/neovim/src/nvim/event/loop.h" 3 4
((void *)0)
# 15 "/home/toto/.env/encours/neovim/src/nvim/event/loop.h"
; (void)(*ptr_); } while (0); } do { void **ptr_ = (void **)&(mp->buf); xfree(*ptr_); *ptr_ = 
# 15 "/home/toto/.env/encours/neovim/src/nvim/event/loop.h" 3 4
((void *)0)
# 15 "/home/toto/.env/encours/neovim/src/nvim/event/loop.h"
; (void)(*ptr_); } while (0); do { void **ptr_ = (void **)&(mp); xfree(*ptr_); *ptr_ = 
# 15 "/home/toto/.env/encours/neovim/src/nvim/event/loop.h" 3 4
((void *)0)
# 15 "/home/toto/.env/encours/neovim/src/nvim/event/loop.h"
; (void)(*ptr_); } while (0); } static inline kl1_WatcherPtr *kmp_alloc_WatcherPtr(kmp_WatcherPtr_t *mp) { mp->cnt++; if (mp->n == 0) { return xcalloc(1, sizeof(kl1_WatcherPtr)); } return mp->buf[--mp->n]; } static inline void kmp_free_WatcherPtr(kmp_WatcherPtr_t *mp, kl1_WatcherPtr *p) { mp->cnt--; if (mp->n == mp->max) { mp->max = mp->max ? (mp->max << 1) : 16; mp->buf = xrealloc(mp->buf, sizeof(kl1_WatcherPtr *) * mp->max); } mp->buf[mp->n++] = p; } typedef struct { kl1_WatcherPtr *head, *tail; kmp_WatcherPtr_t *mp; size_t size; } kl_WatcherPtr_t; static inline kl_WatcherPtr_t *kl_init_WatcherPtr(void) { kl_WatcherPtr_t *kl = xcalloc(1, sizeof(kl_WatcherPtr_t)); kl->mp = kmp_init_WatcherPtr(); kl->head = kl->tail = kmp_alloc_WatcherPtr(kl->mp); kl->head->next = 0; return kl; } static inline void kl_destroy_WatcherPtr(kl_WatcherPtr_t *kl) __attribute__((unused)); static inline void kl_destroy_WatcherPtr(kl_WatcherPtr_t *kl) { kl1_WatcherPtr *p; for (p = kl->head; p != kl->tail; p = p->next) { kmp_free_WatcherPtr(kl->mp, p); } kmp_free_WatcherPtr(kl->mp, p); kmp_destroy_WatcherPtr(kl->mp); do { void **ptr_ = (void **)&(kl); xfree(*ptr_); *ptr_ = 
# 15 "/home/toto/.env/encours/neovim/src/nvim/event/loop.h" 3 4
((void *)0)
# 15 "/home/toto/.env/encours/neovim/src/nvim/event/loop.h"
; (void)(*ptr_); } while (0); } static inline void kl_push_WatcherPtr(kl_WatcherPtr_t *kl, WatcherPtr d) { kl1_WatcherPtr *q, *p = kmp_alloc_WatcherPtr(kl->mp); q = kl->tail; p->next = 0; kl->tail->next = p; kl->tail = p; kl->size++; q->data = d; } static inline WatcherPtr kl_shift_at_WatcherPtr(kl_WatcherPtr_t *kl, kl1_WatcherPtr **n) { 
# 15 "/home/toto/.env/encours/neovim/src/nvim/event/loop.h" 3 4
((void) sizeof ((
# 15 "/home/toto/.env/encours/neovim/src/nvim/event/loop.h"
(*n)->next
# 15 "/home/toto/.env/encours/neovim/src/nvim/event/loop.h" 3 4
) ? 1 : 0), __extension__ ({ if (
# 15 "/home/toto/.env/encours/neovim/src/nvim/event/loop.h"
(*n)->next
# 15 "/home/toto/.env/encours/neovim/src/nvim/event/loop.h" 3 4
) ; else __assert_fail (
# 15 "/home/toto/.env/encours/neovim/src/nvim/event/loop.h"
"(*n)->next"
# 15 "/home/toto/.env/encours/neovim/src/nvim/event/loop.h" 3 4
, "/home/toto/.env/encours/neovim/src/nvim/event/loop.h", 15, __extension__ __PRETTY_FUNCTION__); }))
# 15 "/home/toto/.env/encours/neovim/src/nvim/event/loop.h"
; kl1_WatcherPtr *p; kl->size--; p = *n; *n = (*n)->next; if (p == kl->head) { kl->head = *n; } WatcherPtr d = p->data; kmp_free_WatcherPtr(kl->mp, p); return d; }

typedef struct loop {
  uv_loop_t uv;
  MultiQueue *events;
  MultiQueue *thread_events;
# 30 "/home/toto/.env/encours/neovim/src/nvim/event/loop.h"
  MultiQueue *fast_events;


  kl_WatcherPtr_t *children;
  uv_signal_t children_watcher;
  uv_timer_t children_kill_timer;


  uv_timer_t poll_timer;

  uv_async_t async;
  uv_mutex_t mutex;
  int recursive;
} Loop;
# 15 "/home/toto/.env/encours/neovim/src/nvim/globals.h" 2
# 75 "/home/toto/.env/encours/neovim/src/nvim/globals.h"
extern struct nvim_stats_s {
  int64_t fsync;
  int64_t redraw;
} g_stats ;
# 92 "/home/toto/.env/encours/neovim/src/nvim/globals.h"
extern int Rows ;
extern int Columns ;
# 111 "/home/toto/.env/encours/neovim/src/nvim/globals.h"
typedef off_t off_T;
# 125 "/home/toto/.env/encours/neovim/src/nvim/globals.h"
extern int mod_mask ;


extern 
# 128 "/home/toto/.env/encours/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 128 "/home/toto/.env/encours/neovim/src/nvim/globals.h"
           lua_attr_active ;
# 137 "/home/toto/.env/encours/neovim/src/nvim/globals.h"
extern int cmdline_row;

extern int redraw_cmdline ;
extern int clear_cmdline ;
extern int mode_displayed ;
extern int cmdline_star ;
extern int redrawing_cmdline ;
extern int cmdline_was_last_drawn ;

extern int exec_from_reg ;





extern colnr_T dollar_vcol ;





extern int compl_length ;



extern int compl_interrupted ;



extern int compl_busy ;


extern int compl_cont_status ;
# 182 "/home/toto/.env/encours/neovim/src/nvim/globals.h"
extern int cmdmsg_rl ;
extern int msg_col;
extern int msg_row;
extern int msg_scrolled;



extern 
# 189 "/home/toto/.env/encours/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 189 "/home/toto/.env/encours/neovim/src/nvim/globals.h"
           msg_scrolled_ign ;


extern 
# 192 "/home/toto/.env/encours/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 192 "/home/toto/.env/encours/neovim/src/nvim/globals.h"
           msg_did_scroll ;


extern char_u *keep_msg ;
extern int keep_msg_attr ;
extern int keep_msg_more ;
extern int need_fileinfo ;
extern int msg_scroll ;
extern int msg_didout ;
extern int msg_didany ;
extern int msg_nowait ;
extern int emsg_off ;

extern int info_message ;
extern int msg_hist_off ;
extern int need_clr_eos ;

extern int emsg_skip ;

extern int emsg_severe ;

extern int did_endif ;
extern dict_T vimvardict;
extern dict_T globvardict;
extern int did_emsg;

extern 
# 218 "/home/toto/.env/encours/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 218 "/home/toto/.env/encours/neovim/src/nvim/globals.h"
           called_vim_beep;
extern int did_emsg_syntax;

extern int called_emsg;
extern int ex_exitval ;
extern 
# 223 "/home/toto/.env/encours/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 223 "/home/toto/.env/encours/neovim/src/nvim/globals.h"
           emsg_on_display ;
extern int rc_did_emsg ;

extern int no_wait_return ;
extern int need_wait_return ;
extern int did_wait_return ;

extern int need_maketitle ;

extern int quit_more ;
extern int ex_keep_indent ;
extern int vgetc_busy ;

extern int didset_vim ;
extern int didset_vimruntime ;



extern int lines_left ;
extern int msg_no_more ;


extern char_u *sourcing_name ;
extern linenr_T sourcing_lnum ;

extern int ex_nesting_level ;
extern int debug_break_level ;
extern int debug_did_msg ;
extern int debug_tick ;
extern int debug_backtrace_level ;





extern int do_profiling ;




extern except_T *current_exception;



extern int need_rethrow ;



extern int check_cstack ;



extern int trylevel ;







extern int force_abort ;
# 293 "/home/toto/.env/encours/neovim/src/nvim/globals.h"
extern struct msglist **msg_list ;





extern 
# 299 "/home/toto/.env/encours/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 299 "/home/toto/.env/encours/neovim/src/nvim/globals.h"
           suppress_errthrow ;





extern except_T *caught_stack ;
# 316 "/home/toto/.env/encours/neovim/src/nvim/globals.h"
extern 
# 316 "/home/toto/.env/encours/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 316 "/home/toto/.env/encours/neovim/src/nvim/globals.h"
           may_garbage_collect ;
extern int want_garbage_collect ;
extern int garbage_collect_at_exit ;
# 332 "/home/toto/.env/encours/neovim/src/nvim/globals.h"
extern sctx_T current_sctx ;

extern uint64_t current_channel_id ;

extern 
# 336 "/home/toto/.env/encours/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 336 "/home/toto/.env/encours/neovim/src/nvim/globals.h"
           did_source_packages ;



extern struct caller_scope {
  sctx_T script_ctx;
  uint8_t *sourcing_name, *autocmd_fname, *autocmd_match;
  linenr_T sourcing_lnum;
  int autocmd_bufnr;
  void *funccalp;
} provider_caller_scope;
extern int provider_call_nesting ;


extern int t_colors ;





extern int highlight_match ;
extern linenr_T search_match_lines;
extern colnr_T search_match_endcol;

extern int no_smartcase ;

extern int need_check_timestamps ;

extern int did_check_timestamps ;

extern int no_check_timestamps ;

extern int autocmd_busy ;
extern int autocmd_no_enter ;
extern int autocmd_no_leave ;
extern int modified_was_set;
extern int did_filetype ;

extern int keep_filetype ;



extern bufref_T au_new_curbuf ;





extern buf_T *au_pending_free_buf ;
extern win_T *au_pending_free_win ;


extern int mouse_grid;
extern int mouse_row;
extern int mouse_col;
extern 
# 391 "/home/toto/.env/encours/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 391 "/home/toto/.env/encours/neovim/src/nvim/globals.h"
           mouse_past_bottom ;
extern 
# 392 "/home/toto/.env/encours/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 392 "/home/toto/.env/encours/neovim/src/nvim/globals.h"
           mouse_past_eol ;
extern int mouse_dragging ;



extern vimmenu_T *root_menu ;


extern int sys_menu ;



extern int updating_screen ;




extern win_T *firstwin;
extern win_T *lastwin;
extern win_T *prevwin ;
# 427 "/home/toto/.env/encours/neovim/src/nvim/globals.h"
extern win_T *curwin;

extern win_T *aucmd_win;
extern int aucmd_win_used ;



extern frame_T *topframe;



extern tabpage_T *first_tabpage;
extern tabpage_T *lastused_tabpage;
extern tabpage_T *curtab;
extern int redraw_tabline ;






extern buf_T *firstbuf ;
extern buf_T *lastbuf ;
extern buf_T *curbuf ;
# 465 "/home/toto/.env/encours/neovim/src/nvim/globals.h"
extern alist_T global_alist;
extern int max_alist_id ;
extern 
# 467 "/home/toto/.env/encours/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 467 "/home/toto/.env/encours/neovim/src/nvim/globals.h"
           arg_had_last ;


extern int ru_col;
extern int ru_wid;
extern int sc_col;





extern int starting ;

extern 
# 480 "/home/toto/.env/encours/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 480 "/home/toto/.env/encours/neovim/src/nvim/globals.h"
           exiting ;

extern int stdin_isatty ;

extern int stdout_isatty ;


extern volatile int full_screen ;


extern int restricted ;



extern int secure ;



extern int textlock ;


extern int curbuf_lock ;



extern int allbuf_lock ;



extern int sandbox ;


extern int silent_mode ;


extern pos_T VIsual;

extern int VIsual_active ;

extern int VIsual_select ;

extern int VIsual_reselect;

extern int VIsual_mode ;

extern int redo_VIsual_busy ;



extern pos_T where_paste_started;





extern 
# 535 "/home/toto/.env/encours/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 535 "/home/toto/.env/encours/neovim/src/nvim/globals.h"
           did_ai ;



extern colnr_T ai_col ;





extern int end_comment_pending ;





extern int did_syncbind ;



extern 
# 555 "/home/toto/.env/encours/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 555 "/home/toto/.env/encours/neovim/src/nvim/globals.h"
           did_si ;



extern 
# 559 "/home/toto/.env/encours/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 559 "/home/toto/.env/encours/neovim/src/nvim/globals.h"
           can_si ;



extern 
# 563 "/home/toto/.env/encours/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 563 "/home/toto/.env/encours/neovim/src/nvim/globals.h"
           can_si_back ;


extern pos_T saved_cursor ;


extern pos_T Insstart;





extern pos_T Insstart_orig;


extern int orig_line_count ;
extern int vr_lines_changed ;


extern int inhibit_delete_count ;
# 605 "/home/toto/.env/encours/neovim/src/nvim/globals.h"
extern char_u *fenc_default ;
# 614 "/home/toto/.env/encours/neovim/src/nvim/globals.h"
extern int State ;

extern 
# 616 "/home/toto/.env/encours/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 616 "/home/toto/.env/encours/neovim/src/nvim/globals.h"
           debug_mode ;
extern 
# 617 "/home/toto/.env/encours/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 617 "/home/toto/.env/encours/neovim/src/nvim/globals.h"
           finish_op ;
extern long opcount ;
extern int motion_force ;


extern int exmode_active ;
extern int ex_no_reprint ;

extern int reg_recording ;
extern int reg_executing ;

extern int no_mapping ;
extern int no_zero_mapping ;
extern int no_u_sync ;
extern int u_sync_once ;


extern 
# 634 "/home/toto/.env/encours/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 634 "/home/toto/.env/encours/neovim/src/nvim/globals.h"
           force_restart_edit ;

extern int restart_edit ;
extern int arrow_used;



extern 
# 641 "/home/toto/.env/encours/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 641 "/home/toto/.env/encours/neovim/src/nvim/globals.h"
           ins_at_eol ;

extern char_u *edit_submode ;
extern char_u *edit_submode_pre ;
extern char_u *edit_submode_extra ;
extern hlf_T edit_submode_highl;

extern int no_abbr ;

extern int mapped_ctrl_c ;

extern cmdmod_T cmdmod;

extern int msg_silent ;
extern int emsg_silent ;
extern 
# 656 "/home/toto/.env/encours/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 656 "/home/toto/.env/encours/neovim/src/nvim/globals.h"
           emsg_noredir ;
extern 
# 657 "/home/toto/.env/encours/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 657 "/home/toto/.env/encours/neovim/src/nvim/globals.h"
           cmd_silent ;







extern int swap_exists_action ;


extern int swap_exists_did_quit ;


extern char_u IObuff[(1024+1)];
extern char_u NameBuff[
# 672 "/home/toto/.env/encours/neovim/src/nvim/globals.h" 3 4
                      4096
# 672 "/home/toto/.env/encours/neovim/src/nvim/globals.h"
                              ];
extern char_u msg_buf[480];
extern char os_buf[


# 676 "/home/toto/.env/encours/neovim/src/nvim/globals.h" 3 4
4096




# 680 "/home/toto/.env/encours/neovim/src/nvim/globals.h"
];


extern int RedrawingDisabled ;

extern int readonlymode ;
extern int recoverymode ;


extern typebuf_T typebuf ;

extern int ex_normal_busy ;
extern int ex_normal_lock ;
extern int ignore_script ;
extern int stop_insert_mode;
extern 
# 695 "/home/toto/.env/encours/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 695 "/home/toto/.env/encours/neovim/src/nvim/globals.h"
           KeyTyped;
extern int KeyStuffed;
extern int maptick ;

extern int must_redraw ;
extern 
# 700 "/home/toto/.env/encours/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 700 "/home/toto/.env/encours/neovim/src/nvim/globals.h"
           skip_redraw ;
extern 
# 701 "/home/toto/.env/encours/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 701 "/home/toto/.env/encours/neovim/src/nvim/globals.h"
           do_redraw ;
extern 
# 702 "/home/toto/.env/encours/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 702 "/home/toto/.env/encours/neovim/src/nvim/globals.h"
           must_redraw_pum ;


extern int need_highlight_changed ;

extern FILE *scriptout ;


extern volatile int got_int ;

extern int bangredo ;
extern int searchcmdlen;
extern int reg_do_extmatch ;



extern reg_extmatch_T *re_extmatch_in ;

extern reg_extmatch_T *re_extmatch_out ;

extern int did_outofmem_msg ;

extern int did_swapwrite_msg ;

extern int global_busy ;
extern int listcmd_busy ;

extern int need_start_insertmode ;

extern char_u *last_cmdline ;
extern char_u *repeat_cmdline ;
extern char_u *new_last_cmdline ;
extern char_u *autocmd_fname ;
extern int autocmd_bufnr ;
extern char_u *autocmd_match ;
extern int did_cursorhold ;

extern int postponed_split ;
extern int postponed_split_flags ;
extern int postponed_split_tab ;
extern int g_do_tagpreview ;

extern int g_tag_at_cursor ;



extern int replace_offset ;

extern char_u *escape_chars ;


extern int keep_help_flag ;




extern char_u *empty_option ;

extern int redir_off ;
extern FILE *redir_fd ;
extern int redir_reg ;
extern int redir_vname ;
extern garray_T *capture_ga ;

extern char_u langmap_mapchar[256];

extern int save_p_ls ;
extern int save_p_wmh ;
extern int wild_menu_showing ;
enum {
  WM_SHOWN = 1,
  WM_SCROLLED = 2,
  WM_LIST = 3,
};





extern char *default_vim_dir;
extern char *default_vimruntime_dir;
extern char *default_lib_dir;
extern char_u *compiled_user;
extern char_u *compiled_sys;





extern char_u *globaldir ;


extern int km_stopsel ;
extern int km_startsel ;

extern int cedit_key ;
extern int cmdwin_type ;
extern int cmdwin_result ;
extern int cmdwin_level ;

extern char_u no_lines_msg[] ;




extern long sub_nsubs;
extern linenr_T sub_nlines;


extern char_u wim_flags[4];




extern int stl_syntax ;


extern 
# 819 "/home/toto/.env/encours/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 819 "/home/toto/.env/encours/neovim/src/nvim/globals.h"
           no_hlsearch ;


extern linenr_T printer_page_num;


extern 
# 825 "/home/toto/.env/encours/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 825 "/home/toto/.env/encours/neovim/src/nvim/globals.h"
           typebuf_was_filled ;
# 837 "/home/toto/.env/encours/neovim/src/nvim/globals.h"
extern TriState virtual_op ;


extern disptick_T display_tick ;



extern linenr_T spell_redraw_lnum ;




extern char_u e_abort[] ;
extern char_u e_afterinit[]
                                                      ;
extern char_u e_api_spawn_failed[] ;
extern char_u e_argreq[] ;
extern char_u e_backslash[] ;
extern char_u e_cmdwin[]
                                                                            ;
extern char_u e_curdir[]
                                                                                 ;
extern char_u e_endif[] ;
extern char_u e_endtry[] ;
extern char_u e_endwhile[] ;
extern char_u e_endfor[] ;
extern char_u e_while[] ;
extern char_u e_for[] ;
extern char_u e_exists[] ;
extern char_u e_failed[] ;
extern char_u e_internal[] ;
extern char_u e_intern2[] ;
extern char_u e_interr[] ;
extern char_u e_invaddr[] ;
extern char_u e_invarg[] ;
extern char_u e_invarg2[] ;
extern char_u e_invargval[] ;
extern char_u e_invargNval[]
                                               ;
extern char_u e_duparg2[] ;
extern char_u e_invexpr2[] ;
extern char_u e_invrange[] ;
extern char_u e_invcmd[] ;
extern char_u e_isadir2[] ;
extern char_u e_invchan[] ;
extern char_u e_invchanjob[] ;
extern char_u e_jobtblfull[] ;
extern char_u e_jobspawn[]
                                                 ;
extern char_u e_channotpty[] ;
extern char_u e_stdiochan2[]
                                             ;
extern char_u e_invstream[] ;
extern char_u e_invstreamrpc[]
                                                       ;
extern char_u e_streamkey[]

            ;
extern char_u e_libcall[] ;
extern char e_fsync[] ;
extern char_u e_mkdir[] ;
extern char_u e_markinval[] ;
extern char_u e_marknotset[] ;
extern char_u e_modifiable[]
                                                         ;
extern char_u e_nesting[] ;
extern char_u e_noalt[] ;
extern char_u e_noabbr[] ;
extern char_u e_nobang[] ;
extern char_u e_nogroup[] ;
extern char_u e_noinstext[] ;
extern char_u e_nolastcmd[] ;
extern char_u e_nomap[] ;
extern char_u e_nomatch[] ;
extern char_u e_nomatch2[] ;
extern char_u e_noname[] ;
extern char_u e_nopresub[]
                                                          ;
extern char_u e_noprev[] ;
extern char_u e_noprevre[] ;
extern char_u e_norange[] ;
extern char_u e_noroom[] ;
extern char_u e_notmp[] ;
extern char_u e_notopen[] ;
extern char_u e_notopen_2[] ;
extern char_u e_notread[] ;
extern char_u e_null[] ;
extern char_u e_number_exp[] ;
extern char_u e_openerrf[] ;
extern char_u e_outofmem[] ;
extern char_u e_patnotf[] ;
extern char_u e_patnotf2[] ;
extern char_u e_positive[] ;
extern char_u e_prev_dir[]
                                                      ;

extern char_u e_quickfix[] ;
extern char_u e_loclist[] ;
extern char_u e_re_damg[] ;
extern char_u e_re_corr[] ;
extern char_u e_readonly[]
                                                         ;
extern char_u e_readonlyvar[]
                                                      ;
extern char_u e_dictreq[] ;
extern char_u e_toomanyarg[] ;
extern char_u e_dictkey[] ;
extern char_u e_listreq[] ;
extern char_u e_listdictarg[]
                                                         ;
extern char_u e_readerrf[] ;
extern char_u e_sandbox[] ;
extern char_u e_secure[] ;
extern char_u e_screenmode[]
                                                   ;
extern char_u e_scroll[] ;
extern char_u e_shellempty[] ;
extern char_u e_signdata[] ;
extern char_u e_swapclose[] ;
extern char_u e_tagstack[] ;
extern char_u e_toocompl[] ;
extern char_u e_longname[] ;
extern char_u e_toomsbra[] ;
extern char_u e_toomany[] ;
extern char_u e_trailing[] ;
extern char_u e_trailing2[] ;
extern char_u e_umark[] ;
extern char_u e_wildexpand[] ;
extern char_u e_winheight[]
                                                                   ;
extern char_u e_winwidth[]
                                                                 ;
extern char_u e_write[] ;
extern char_u e_zerocount[] ;
extern char_u e_usingsid[]
                                                ;
extern char_u e_maxmempat[]
                                                               ;
extern char_u e_emptybuf[] ;
extern char_u e_nobufnr[] ;

extern char_u e_invalpat[]
                                                     ;
extern char_u e_bufloaded[] ;
extern char_u e_notset[] ;
extern char_u e_invalidreg[] ;
extern char_u e_dirnotf[]
                                                 ;
extern char_u e_au_recursive[]
                                                   ;
extern char_u e_unsupportedoption[] ;
extern char_u e_fnametoolong[] ;
extern char_u e_float_as_string[] ;

extern char_u e_autocmd_err[]
                                                  ;
extern char_u e_cmdmap_err[]
                                               ;
extern char_u e_cmdmap_repeated[]
                                                                   ;
extern char_u e_cmdmap_key[]
                                                    ;

extern char_u e_api_error[]
                           ;

extern char e_luv_api_disabled[]
                                                           ;

extern char_u e_floatonly[]
                                                                     ;
extern char_u e_floatexchange[]
                                              ;


extern char top_bot_msg[] ;
extern char bot_top_msg[] ;

extern char line_msg[] ;


extern time_t starttime;

extern FILE *time_fd ;




extern int vim_ignored;


extern 
# 1028 "/home/toto/.env/encours/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 1028 "/home/toto/.env/encours/neovim/src/nvim/globals.h"
           embedded_mode ;

extern 
# 1030 "/home/toto/.env/encours/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 1030 "/home/toto/.env/encours/neovim/src/nvim/globals.h"
           headless_mode ;



typedef enum {
  kUnknown,
  kWorking,
  kBroken
} WorkingStatus;







typedef enum {
  kCdScopeInvalid = -1,
  kCdScopeWindow,
  kCdScopeTab,
  kCdScopeGlobal,
} CdScope;
# 301 "/home/toto/.env/encours/neovim/src/nvim/vim.h" 2
# 70 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 2
# 1 "/home/toto/.env/encours/neovim/src/nvim/ascii.h" 1






# 1 "/home/toto/.env/encours/neovim/src/nvim/func_attr.h" 1
# 8 "/home/toto/.env/encours/neovim/src/nvim/ascii.h" 2
# 90 "/home/toto/.env/encours/neovim/src/nvim/ascii.h"
static inline 
# 90 "/home/toto/.env/encours/neovim/src/nvim/ascii.h" 3 4
             _Bool 
# 90 "/home/toto/.env/encours/neovim/src/nvim/ascii.h"
                  ascii_iswhite(int)
  __attribute__((const))
  __attribute__((always_inline));

static inline 
# 94 "/home/toto/.env/encours/neovim/src/nvim/ascii.h" 3 4
             _Bool 
# 94 "/home/toto/.env/encours/neovim/src/nvim/ascii.h"
                  ascii_isdigit(int)
  __attribute__((const))
  __attribute__((always_inline));

static inline 
# 98 "/home/toto/.env/encours/neovim/src/nvim/ascii.h" 3 4
             _Bool 
# 98 "/home/toto/.env/encours/neovim/src/nvim/ascii.h"
                  ascii_isxdigit(int)
  __attribute__((const))
  __attribute__((always_inline));

static inline 
# 102 "/home/toto/.env/encours/neovim/src/nvim/ascii.h" 3 4
             _Bool 
# 102 "/home/toto/.env/encours/neovim/src/nvim/ascii.h"
                  ascii_isident(int)
  __attribute__((const))
  __attribute__((always_inline));

static inline 
# 106 "/home/toto/.env/encours/neovim/src/nvim/ascii.h" 3 4
             _Bool 
# 106 "/home/toto/.env/encours/neovim/src/nvim/ascii.h"
                  ascii_isbdigit(int)
  __attribute__((const))
  __attribute__((always_inline));

static inline 
# 110 "/home/toto/.env/encours/neovim/src/nvim/ascii.h" 3 4
             _Bool 
# 110 "/home/toto/.env/encours/neovim/src/nvim/ascii.h"
                  ascii_isspace(int)
  __attribute__((const))
  __attribute__((always_inline));




static inline 
# 117 "/home/toto/.env/encours/neovim/src/nvim/ascii.h" 3 4
             _Bool 
# 117 "/home/toto/.env/encours/neovim/src/nvim/ascii.h"
                  ascii_iswhite(int c)
{
  return c == ' ' || c == '\t';
}
# 131 "/home/toto/.env/encours/neovim/src/nvim/ascii.h"
static inline 
# 131 "/home/toto/.env/encours/neovim/src/nvim/ascii.h" 3 4
             _Bool 
# 131 "/home/toto/.env/encours/neovim/src/nvim/ascii.h"
                  ascii_isdigit(int c)
{
  return c >= '0' && c <= '9';
}




static inline 
# 139 "/home/toto/.env/encours/neovim/src/nvim/ascii.h" 3 4
             _Bool 
# 139 "/home/toto/.env/encours/neovim/src/nvim/ascii.h"
                  ascii_isxdigit(int c)
{
  return (c >= '0' && c <= '9')
         || (c >= 'a' && c <= 'f')
         || (c >= 'A' && c <= 'F');
}




static inline 
# 149 "/home/toto/.env/encours/neovim/src/nvim/ascii.h" 3 4
             _Bool 
# 149 "/home/toto/.env/encours/neovim/src/nvim/ascii.h"
                  ascii_isident(int c)
{
  return ((((unsigned)(c) >= 'A' && (unsigned)(c) <= 'Z') || ((unsigned)(c) >= 'a' && (unsigned)(c) <= 'z')) || ascii_isdigit(c)) || c == '_';
}




static inline 
# 157 "/home/toto/.env/encours/neovim/src/nvim/ascii.h" 3 4
             _Bool 
# 157 "/home/toto/.env/encours/neovim/src/nvim/ascii.h"
                  ascii_isbdigit(int c)
{
  return (c == '0' || c == '1');
}





static inline 
# 166 "/home/toto/.env/encours/neovim/src/nvim/ascii.h" 3 4
             _Bool 
# 166 "/home/toto/.env/encours/neovim/src/nvim/ascii.h"
                  ascii_isspace(int c)
{
  return (c >= 9 && c <= 13) || c == ' ';
}
# 71 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 2
# 1 "/home/toto/.env/encours/neovim/src/nvim/arabic.h" 1






static inline 
# 7 "/home/toto/.env/encours/neovim/src/nvim/arabic.h" 3 4
             _Bool 
# 7 "/home/toto/.env/encours/neovim/src/nvim/arabic.h"
                  arabic_char(int c)
{

    return c >= 0x0621 && c <= 0x0670;
}
# 72 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 2
# 1 "/home/toto/.env/encours/neovim/src/nvim/screen.h" 1
# 31 "/home/toto/.env/encours/neovim/src/nvim/screen.h"
extern ScreenGrid default_grid ;




typedef struct {
  enum {
    kStlClickDisabled = 0,
    kStlClickTabSwitch,
    kStlClickTabClose,
    kStlClickFuncRun,
  } type;
  int tabnr;
  char *func;
} StlClickDefinition;


typedef struct {
  StlClickDefinition def;
  const char *start;
} StlClickRecord;


extern StlClickDefinition *tab_page_click_defs;


extern long tab_page_click_defs_size;
# 73 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 2
# 1 "/home/toto/.env/encours/neovim/src/nvim/buffer.h" 1




# 1 "/home/toto/.env/encours/neovim/src/nvim/window.h" 1
# 6 "/home/toto/.env/encours/neovim/src/nvim/buffer.h" 2



# 1 "/home/toto/.env/encours/neovim/src/nvim/func_attr.h" 1
# 10 "/home/toto/.env/encours/neovim/src/nvim/buffer.h" 2
# 1 "/home/toto/.env/encours/neovim/src/nvim/eval.h" 1




# 1 "/home/toto/.env/encours/neovim/src/nvim/channel.h" 1



# 1 "/home/toto/.env/encours/neovim/src/nvim/main.h" 1






extern Loop main_loop;
# 5 "/home/toto/.env/encours/neovim/src/nvim/channel.h" 2
# 1 "/home/toto/.env/encours/neovim/src/nvim/event/socket.h" 1






# 1 "/home/toto/.env/encours/neovim/src/nvim/event/rstream.h" 1




# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 6 "/home/toto/.env/encours/neovim/src/nvim/event/rstream.h" 2




# 1 "/home/toto/.env/encours/neovim/src/nvim/event/stream.h" 1




# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 6 "/home/toto/.env/encours/neovim/src/nvim/event/stream.h" 2




# 1 "/home/toto/.env/encours/neovim/src/nvim/rbuffer.h" 1
# 17 "/home/toto/.env/encours/neovim/src/nvim/rbuffer.h"
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 18 "/home/toto/.env/encours/neovim/src/nvim/rbuffer.h" 2
# 71 "/home/toto/.env/encours/neovim/src/nvim/rbuffer.h"
typedef struct rbuffer RBuffer;



typedef void(*rbuffer_callback)(RBuffer *buf, void *data);

struct rbuffer {
  rbuffer_callback full_cb, nonfull_cb;
  void *data;
  size_t size;

  char *temp;
  char *end_ptr, *read_ptr, *write_ptr;
  char start_ptr[];
};
# 11 "/home/toto/.env/encours/neovim/src/nvim/event/stream.h" 2

typedef struct stream Stream;







typedef void (*stream_read_cb)(Stream *stream, RBuffer *buf, size_t count,
    void *data, 
# 21 "/home/toto/.env/encours/neovim/src/nvim/event/stream.h" 3 4
               _Bool 
# 21 "/home/toto/.env/encours/neovim/src/nvim/event/stream.h"
                    eof);







typedef void (*stream_write_cb)(Stream *stream, void *data, int status);
typedef void (*stream_close_cb)(Stream *stream, void *data);

struct stream {
  
# 33 "/home/toto/.env/encours/neovim/src/nvim/event/stream.h" 3 4
 _Bool 
# 33 "/home/toto/.env/encours/neovim/src/nvim/event/stream.h"
      closed;
  
# 34 "/home/toto/.env/encours/neovim/src/nvim/event/stream.h" 3 4
 _Bool 
# 34 "/home/toto/.env/encours/neovim/src/nvim/event/stream.h"
      did_eof;
  union {
    uv_pipe_t pipe;
    uv_tcp_t tcp;
    uv_idle_t idle;



  } uv;
  uv_stream_t *uvstream;
  uv_buf_t uvbuf;
  RBuffer *buffer;
  uv_file fd;
  stream_read_cb read_cb;
  stream_write_cb write_cb;
  void *cb_data;
  stream_close_cb close_cb, internal_close_cb;
  void *close_cb_data, *internal_data;
  size_t fpos;
  size_t curmem;
  size_t maxmem;
  size_t pending_reqs;
  size_t num_bytes;
  MultiQueue *events;
};
# 11 "/home/toto/.env/encours/neovim/src/nvim/event/rstream.h" 2
# 8 "/home/toto/.env/encours/neovim/src/nvim/event/socket.h" 2
# 1 "/home/toto/.env/encours/neovim/src/nvim/event/wstream.h" 1
# 12 "/home/toto/.env/encours/neovim/src/nvim/event/wstream.h"
typedef struct wbuffer WBuffer;
typedef void (*wbuffer_data_finalizer)(void *data);

struct wbuffer {
  size_t size, refcount;
  char *data;
  wbuffer_data_finalizer cb;
};
# 9 "/home/toto/.env/encours/neovim/src/nvim/event/socket.h" 2



typedef struct socket_watcher SocketWatcher;
typedef void (*socket_cb)(SocketWatcher *watcher, int result, void *data);
typedef void (*socket_close_cb)(SocketWatcher *watcher, void *data);

struct socket_watcher {

  char addr[256];

  union {
    struct {
      uv_tcp_t handle;
      struct addrinfo *addrinfo;
    } tcp;
    struct {
      uv_pipe_t handle;
    } pipe;
  } uv;
  uv_stream_t *stream;
  void *data;
  socket_cb cb;
  socket_close_cb close_cb;
  MultiQueue *events;
};
# 6 "/home/toto/.env/encours/neovim/src/nvim/channel.h" 2
# 1 "/home/toto/.env/encours/neovim/src/nvim/event/process.h" 1







typedef enum {
  kProcessTypeUv,
  kProcessTypePty
} ProcessType;

typedef struct process Process;
typedef void (*process_exit_cb)(Process *proc, int status, void *data);
typedef void (*internal_process_cb)(Process *proc);

struct process {
  ProcessType type;
  Loop *loop;
  void *data;
  int pid, status, refcount;
  uint8_t exit_signal;
  uint64_t stopped_time;
  const char *cwd;
  char **argv;
  char **env;
  Stream in, out, err;
  process_exit_cb cb;
  internal_process_cb internal_exit_cb, internal_close_cb;
  
# 30 "/home/toto/.env/encours/neovim/src/nvim/event/process.h" 3 4
 _Bool 
# 30 "/home/toto/.env/encours/neovim/src/nvim/event/process.h"
      closed, detach;
  MultiQueue *events;
};


static inline Process process_init(Loop *loop, ProcessType type, void *data)
{
  return (Process) {
    .type = type,
    .data = data,
    .loop = loop,
    .events = 
# 41 "/home/toto/.env/encours/neovim/src/nvim/event/process.h" 3 4
             ((void *)0)
# 41 "/home/toto/.env/encours/neovim/src/nvim/event/process.h"
                 ,
    .pid = 0,
    .status = -1,
    .refcount = 0,
    .stopped_time = 0,
    .cwd = 
# 46 "/home/toto/.env/encours/neovim/src/nvim/event/process.h" 3 4
          ((void *)0)
# 46 "/home/toto/.env/encours/neovim/src/nvim/event/process.h"
              ,
    .argv = 
# 47 "/home/toto/.env/encours/neovim/src/nvim/event/process.h" 3 4
           ((void *)0)
# 47 "/home/toto/.env/encours/neovim/src/nvim/event/process.h"
               ,
    .in = { .closed = 
# 48 "/home/toto/.env/encours/neovim/src/nvim/event/process.h" 3 4
                     0 
# 48 "/home/toto/.env/encours/neovim/src/nvim/event/process.h"
                           },
    .out = { .closed = 
# 49 "/home/toto/.env/encours/neovim/src/nvim/event/process.h" 3 4
                      0 
# 49 "/home/toto/.env/encours/neovim/src/nvim/event/process.h"
                            },
    .err = { .closed = 
# 50 "/home/toto/.env/encours/neovim/src/nvim/event/process.h" 3 4
                      0 
# 50 "/home/toto/.env/encours/neovim/src/nvim/event/process.h"
                            },
    .cb = 
# 51 "/home/toto/.env/encours/neovim/src/nvim/event/process.h" 3 4
         ((void *)0)
# 51 "/home/toto/.env/encours/neovim/src/nvim/event/process.h"
             ,
    .closed = 
# 52 "/home/toto/.env/encours/neovim/src/nvim/event/process.h" 3 4
             0
# 52 "/home/toto/.env/encours/neovim/src/nvim/event/process.h"
                  ,
    .internal_close_cb = 
# 53 "/home/toto/.env/encours/neovim/src/nvim/event/process.h" 3 4
                        ((void *)0)
# 53 "/home/toto/.env/encours/neovim/src/nvim/event/process.h"
                            ,
    .internal_exit_cb = 
# 54 "/home/toto/.env/encours/neovim/src/nvim/event/process.h" 3 4
                       ((void *)0)
# 54 "/home/toto/.env/encours/neovim/src/nvim/event/process.h"
                           ,
    .detach = 
# 55 "/home/toto/.env/encours/neovim/src/nvim/event/process.h" 3 4
             0
  
# 56 "/home/toto/.env/encours/neovim/src/nvim/event/process.h"
 };
}

static inline 
# 59 "/home/toto/.env/encours/neovim/src/nvim/event/process.h" 3 4
             _Bool 
# 59 "/home/toto/.env/encours/neovim/src/nvim/event/process.h"
                  process_is_stopped(Process *proc)
{
  
# 61 "/home/toto/.env/encours/neovim/src/nvim/event/process.h" 3 4
 _Bool 
# 61 "/home/toto/.env/encours/neovim/src/nvim/event/process.h"
      exited = (proc->status >= 0);
  return exited || (proc->stopped_time != 0);
}
# 7 "/home/toto/.env/encours/neovim/src/nvim/channel.h" 2
# 1 "/home/toto/.env/encours/neovim/src/nvim/os/pty_process.h" 1






# 1 "/home/toto/.env/encours/neovim/src/nvim/os/pty_process_unix.h" 1



# 1 "/usr/include/x86_64-linux-gnu/sys/ioctl.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/sys/ioctl.h" 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/ioctls.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/ioctls.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/ioctls.h" 1 3 4
# 1 "/usr/include/asm-generic/ioctls.h" 1 3 4




# 1 "/usr/include/linux/ioctl.h" 1 3 4




# 1 "/usr/include/x86_64-linux-gnu/asm/ioctl.h" 1 3 4
# 1 "/usr/include/asm-generic/ioctl.h" 1 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/ioctl.h" 2 3 4
# 6 "/usr/include/linux/ioctl.h" 2 3 4
# 6 "/usr/include/asm-generic/ioctls.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/ioctls.h" 2 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/ioctls.h" 2 3 4
# 27 "/usr/include/x86_64-linux-gnu/sys/ioctl.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/ioctl-types.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/ioctl-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/ioctls.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/ioctl-types.h" 2 3 4



# 27 "/usr/include/x86_64-linux-gnu/bits/ioctl-types.h" 3 4
struct winsize
  {
    unsigned short int ws_row;
    unsigned short int ws_col;
    unsigned short int ws_xpixel;
    unsigned short int ws_ypixel;
  };


struct termio
  {
    unsigned short int c_iflag;
    unsigned short int c_oflag;
    unsigned short int c_cflag;
    unsigned short int c_lflag;
    unsigned char c_line;
    unsigned char c_cc[8];
};
# 30 "/usr/include/x86_64-linux-gnu/sys/ioctl.h" 2 3 4






# 1 "/usr/include/x86_64-linux-gnu/sys/ttydefaults.h" 1 3 4
# 37 "/usr/include/x86_64-linux-gnu/sys/ioctl.h" 2 3 4




extern int ioctl (int __fd, unsigned long int __request, ...) __attribute__ ((__nothrow__ , __leaf__));


# 5 "/home/toto/.env/encours/neovim/src/nvim/os/pty_process_unix.h" 2




# 8 "/home/toto/.env/encours/neovim/src/nvim/os/pty_process_unix.h"
typedef struct pty_process {
  Process process;
  char *term_name;
  uint16_t width, height;
  struct winsize winsize;
  int tty_fd;
} PtyProcess;

static inline PtyProcess pty_process_init(Loop *loop, void *data)
{
  PtyProcess rv;
  rv.process = process_init(loop, kProcessTypePty, data);
  rv.term_name = 
# 20 "/home/toto/.env/encours/neovim/src/nvim/os/pty_process_unix.h" 3 4
                ((void *)0)
# 20 "/home/toto/.env/encours/neovim/src/nvim/os/pty_process_unix.h"
                    ;
  rv.width = 80;
  rv.height = 24;
  rv.tty_fd = -1;
  return rv;
}
# 8 "/home/toto/.env/encours/neovim/src/nvim/os/pty_process.h" 2
# 8 "/home/toto/.env/encours/neovim/src/nvim/channel.h" 2
# 1 "/home/toto/.env/encours/neovim/src/nvim/event/libuv_process.h" 1







typedef struct libuv_process {
  Process process;
  uv_process_t uv;
  uv_process_options_t uvopts;
  uv_stdio_container_t uvstdio[3];
} LibuvProcess;

static inline LibuvProcess libuv_process_init(Loop *loop, void *data)
{
  LibuvProcess rv = {
    .process = process_init(loop, kProcessTypeUv, data)
  };
  return rv;
}
# 9 "/home/toto/.env/encours/neovim/src/nvim/channel.h" 2

# 1 "/home/toto/.env/encours/neovim/src/nvim/msgpack_rpc/channel_defs.h" 1





# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack.h" 1
# 16 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/util.h" 1
# 17 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/object.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/object.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/zone.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/zone.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/sysdep.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/sysdep.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/language.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/language.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/language/stdc.h" 1
# 11 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/language/stdc.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/version_number.h" 1
# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/language/stdc.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1






# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/detail/test.h" 1
# 8 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 2
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/language/stdc.h" 2
# 53 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/language/stdc.h"

# 14 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/language.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/language/stdcpp.h" 1
# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/language/stdcpp.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/language/stdcpp.h" 2
# 115 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/language/stdcpp.h"







# 15 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/language.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/language/objc.h" 1
# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/language/objc.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/language/objc.h" 2
# 42 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/language/objc.h"

# 16 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/language.h" 2
# 14 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/alpha.h" 1
# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/alpha.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/alpha.h" 2
# 59 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/alpha.h"

# 14 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/arm.h" 1
# 14 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/arm.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 15 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/arm.h" 2
# 70 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/arm.h"

# 15 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/blackfin.h" 1
# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/blackfin.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/blackfin.h" 2
# 46 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/blackfin.h"

# 16 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/convex.h" 1
# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/convex.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/convex.h" 2
# 65 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/convex.h"

# 17 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/ia64.h" 1
# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/ia64.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/ia64.h" 2
# 49 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/ia64.h"

# 18 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/m68k.h" 1
# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/m68k.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/m68k.h" 2
# 82 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/m68k.h"

# 19 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/mips.h" 1
# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/mips.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/mips.h" 2
# 73 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/mips.h"

# 20 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/parisc.h" 1
# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/parisc.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/parisc.h" 2
# 64 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/parisc.h"

# 21 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/ppc.h" 1
# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/ppc.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/ppc.h" 2
# 72 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/ppc.h"

# 22 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/pyramid.h" 1
# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/pyramid.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/pyramid.h" 2
# 42 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/pyramid.h"

# 23 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/rs6k.h" 1
# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/rs6k.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/rs6k.h" 2
# 56 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/rs6k.h"

# 24 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/sparc.h" 1
# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/sparc.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/sparc.h" 2
# 54 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/sparc.h"

# 25 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/superh.h" 1
# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/superh.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/superh.h" 2
# 67 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/superh.h"

# 26 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/sys370.h" 1
# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/sys370.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/sys370.h" 2
# 43 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/sys370.h"

# 27 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/sys390.h" 1
# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/sys390.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/sys390.h" 2
# 43 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/sys390.h"

# 28 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/x86.h" 1







# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/x86/32.h" 1
# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/x86/32.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/x86/32.h" 2
# 82 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/x86/32.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/x86.h" 1







# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/x86/32.h" 1
# 87 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/x86/32.h"

# 9 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/x86.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/x86/64.h" 1
# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/x86/64.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/x86/64.h" 2
# 45 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/x86/64.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/x86.h" 1







# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/x86/32.h" 1
# 87 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/x86/32.h"

# 9 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/x86.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/x86/64.h" 1
# 50 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/x86/64.h"

# 10 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/x86.h" 2
# 38 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/x86.h"

# 46 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/x86/64.h" 2





# 10 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/x86.h" 2
# 38 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/x86.h"

# 83 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/x86/32.h" 2





# 9 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/x86.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/x86/64.h" 1
# 50 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/x86/64.h"

# 10 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/x86.h" 2
# 38 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/x86.h"

# 29 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/z.h" 1
# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/z.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/z.h" 2
# 42 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture/z.h"

# 30 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/architecture.h" 2
# 15 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/borland.h" 1
# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/borland.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/borland.h" 2
# 58 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/borland.h"

# 14 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/clang.h" 1
# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/clang.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/clang.h" 2
# 51 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/clang.h"

# 15 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/comeau.h" 1
# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/comeau.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/comeau.h" 2
# 56 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/comeau.h"

# 16 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/compaq.h" 1
# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/compaq.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/compaq.h" 2
# 61 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/compaq.h"

# 17 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/diab.h" 1
# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/diab.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/diab.h" 2
# 51 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/diab.h"

# 18 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/digitalmars.h" 1
# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/digitalmars.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/digitalmars.h" 2
# 51 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/digitalmars.h"

# 19 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/dignus.h" 1
# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/dignus.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/dignus.h" 2
# 51 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/dignus.h"

# 20 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/edg.h" 1
# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/edg.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/edg.h" 2
# 51 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/edg.h"

# 21 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/ekopath.h" 1
# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/ekopath.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/ekopath.h" 2
# 52 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/ekopath.h"

# 22 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/gcc_xml.h" 1
# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/gcc_xml.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/gcc_xml.h" 2
# 48 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/gcc_xml.h"

# 23 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/gcc.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/gcc.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/clang.h" 1
# 51 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/clang.h"

# 14 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/gcc.h" 2


# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 17 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/gcc.h" 2
# 55 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/gcc.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/detail/comp_detected.h" 1
# 56 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/gcc.h" 2








# 24 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/greenhills.h" 1
# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/greenhills.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/greenhills.h" 2
# 61 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/greenhills.h"

# 25 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/hp_acc.h" 1
# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/hp_acc.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/hp_acc.h" 2
# 56 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/hp_acc.h"

# 26 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/iar.h" 1
# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/iar.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/iar.h" 2
# 51 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/iar.h"

# 27 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/ibm.h" 1
# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/ibm.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/ibm.h" 2
# 67 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/ibm.h"

# 28 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/intel.h" 1
# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/intel.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/intel.h" 2
# 60 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/intel.h"

# 29 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/kai.h" 1
# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/kai.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/kai.h" 2
# 51 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/kai.h"

# 30 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/llvm.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/llvm.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/clang.h" 1
# 51 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/clang.h"

# 14 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/llvm.h" 2


# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 17 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/llvm.h" 2
# 52 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/llvm.h"

# 31 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/metaware.h" 1
# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/metaware.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/metaware.h" 2
# 48 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/metaware.h"

# 32 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/metrowerks.h" 1
# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/metrowerks.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/metrowerks.h" 2
# 72 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/metrowerks.h"

# 33 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/microtec.h" 1
# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/microtec.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/microtec.h" 2
# 48 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/microtec.h"

# 34 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/mpw.h" 1
# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/mpw.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/mpw.h" 2
# 58 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/mpw.h"

# 35 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/palm.h" 1
# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/palm.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/palm.h" 2
# 51 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/palm.h"

# 36 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/pgi.h" 1
# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/pgi.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/pgi.h" 2
# 55 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/pgi.h"

# 37 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/sgi_mipspro.h" 1
# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/sgi_mipspro.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/sgi_mipspro.h" 2
# 61 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/sgi_mipspro.h"

# 38 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/sunpro.h" 1
# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/sunpro.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/sunpro.h" 2
# 71 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/sunpro.h"

# 39 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/tendra.h" 1
# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/tendra.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/tendra.h" 2
# 48 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/tendra.h"

# 40 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/visualc.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/visualc.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/clang.h" 1
# 51 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/clang.h"

# 14 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/visualc.h" 2


# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 17 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/visualc.h" 2
# 86 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/visualc.h"

# 41 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/watcom.h" 1
# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/watcom.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/watcom.h" 2
# 51 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler/watcom.h"

# 42 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/compiler.h" 2
# 16 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/c.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/c.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/c/_prefix.h" 1
# 11 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/c/_prefix.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/detail/_cassert.h" 1
# 14 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/detail/_cassert.h"
# 1 "/usr/include/assert.h" 1 3 4
# 15 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/detail/_cassert.h" 2
# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/c/_prefix.h" 2
# 14 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/c.h" 2

# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/c/gnu.h" 1
# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/c/gnu.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/c/gnu.h" 2




# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 18 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/c/gnu.h" 2
# 61 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/c/gnu.h"

# 16 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/c.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/c/uc.h" 1
# 14 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/c/uc.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 15 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/c/uc.h" 2
# 47 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/c/uc.h"

# 17 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/c.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/c/vms.h" 1
# 14 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/c/vms.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 15 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/c/vms.h" 2
# 47 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/c/vms.h"

# 18 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/c.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/c/zos.h" 1
# 14 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/c/zos.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 15 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/c/zos.h" 2
# 56 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/c/zos.h"

# 19 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/c.h" 2
# 14 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/std.h" 1
# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/std.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/std/_prefix.h" 1
# 21 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/std/_prefix.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/detail/_exception.h" 1
# 22 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/std/_prefix.h" 2
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/std.h" 2

# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/std/cxx.h" 1
# 14 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/std/cxx.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 15 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/std/cxx.h" 2
# 46 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/std/cxx.h"

# 15 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/std.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/std/dinkumware.h" 1
# 14 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/std/dinkumware.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 15 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/std/dinkumware.h" 2
# 52 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/std/dinkumware.h"

# 16 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/std.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/std/libcomo.h" 1
# 14 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/std/libcomo.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 15 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/std/libcomo.h" 2
# 47 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/std/libcomo.h"

# 17 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/std.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/std/modena.h" 1
# 14 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/std/modena.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 15 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/std/modena.h" 2
# 45 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/std/modena.h"

# 18 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/std.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/std/msl.h" 1
# 14 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/std/msl.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 15 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/std/msl.h" 2
# 53 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/std/msl.h"

# 19 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/std.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/std/roguewave.h" 1
# 14 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/std/roguewave.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 15 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/std/roguewave.h" 2
# 56 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/std/roguewave.h"

# 20 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/std.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/std/sgi.h" 1
# 14 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/std/sgi.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 15 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/std/sgi.h" 2
# 51 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/std/sgi.h"

# 21 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/std.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/std/stdcpp3.h" 1
# 14 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/std/stdcpp3.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 15 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/std/stdcpp3.h" 2
# 53 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/std/stdcpp3.h"

# 22 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/std.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/std/stlport.h" 1
# 14 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/std/stlport.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 15 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/std/stlport.h" 2
# 59 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/std/stlport.h"

# 23 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/std.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/std/vacpp.h" 1
# 14 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/std/vacpp.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 15 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/std/vacpp.h" 2
# 44 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/std/vacpp.h"

# 24 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/std.h" 2
# 15 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library.h" 2
# 17 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os.h" 1
# 14 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/aix.h" 1
# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/aix.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/aix.h" 2
# 66 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/aix.h"

# 15 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/amigaos.h" 1
# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/amigaos.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/amigaos.h" 2
# 46 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/amigaos.h"

# 16 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/android.h" 1
# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/android.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/android.h" 2
# 45 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/android.h"

# 17 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/beos.h" 1
# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/beos.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/beos.h" 2
# 45 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/beos.h"

# 18 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 1
# 16 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/macos.h" 1
# 17 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/macos.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/ios.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/ios.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 14 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/ios.h" 2
# 51 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/ios.h"

# 18 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/macos.h" 2


# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 21 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/macos.h" 2
# 65 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/macos.h"

# 17 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2


# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 20 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2
# 52 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/bsdi.h" 1
# 11 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/bsdi.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 1
# 94 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/bsdi.h" 1
# 48 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/bsdi.h"

# 95 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/dragonfly.h" 1
# 11 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/dragonfly.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 1
# 94 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/bsdi.h" 1
# 48 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/bsdi.h"

# 95 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/dragonfly.h" 1
# 50 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/dragonfly.h"

# 96 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/free.h" 1
# 11 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/free.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 1
# 94 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/bsdi.h" 1
# 48 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/bsdi.h"

# 95 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/dragonfly.h" 1
# 50 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/dragonfly.h"

# 96 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/free.h" 1
# 60 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/free.h"

# 97 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/open.h" 1
# 11 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/open.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 1
# 94 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/bsdi.h" 1
# 48 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/bsdi.h"

# 95 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/dragonfly.h" 1
# 50 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/dragonfly.h"

# 96 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/free.h" 1
# 60 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/free.h"

# 97 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/open.h" 1
# 171 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/open.h"

# 98 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/net.h" 1
# 11 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/net.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 1
# 94 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/bsdi.h" 1
# 48 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/bsdi.h"

# 95 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/dragonfly.h" 1
# 50 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/dragonfly.h"

# 96 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/free.h" 1
# 60 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/free.h"

# 97 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/open.h" 1
# 171 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/open.h"

# 98 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/net.h" 1
# 84 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/net.h"

# 99 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2





# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/net.h" 2
# 84 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/net.h"

# 99 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2





# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/open.h" 2
# 171 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/open.h"

# 98 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/net.h" 1
# 84 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/net.h"

# 99 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2





# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/free.h" 2
# 60 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/free.h"

# 97 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/open.h" 1
# 171 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/open.h"

# 98 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/net.h" 1
# 84 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/net.h"

# 99 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2





# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/dragonfly.h" 2
# 50 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/dragonfly.h"

# 96 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/free.h" 1
# 60 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/free.h"

# 97 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/open.h" 1
# 171 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/open.h"

# 98 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/net.h" 1
# 84 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/net.h"

# 99 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2





# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/bsdi.h" 2
# 48 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/bsdi.h"

# 53 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/dragonfly.h" 1
# 50 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/dragonfly.h"

# 54 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/free.h" 1
# 60 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/free.h"

# 55 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/open.h" 1
# 171 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/open.h"

# 56 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/net.h" 1
# 84 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/net.h"

# 57 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2
# 103 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd.h"

# 19 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/cygwin.h" 1
# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/cygwin.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/cygwin.h" 2
# 45 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/cygwin.h"

# 20 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/haiku.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/haiku.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 14 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/haiku.h" 2
# 46 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/haiku.h"

# 21 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/hpux.h" 1
# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/hpux.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/hpux.h" 2
# 47 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/hpux.h"

# 22 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/irix.h" 1
# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/irix.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/irix.h" 2
# 46 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/irix.h"

# 23 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/ios.h" 1
# 51 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/ios.h"

# 24 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/linux.h" 1
# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/linux.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/linux.h" 2
# 38 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/linux.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/detail/os_detected.h" 1
# 39 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/linux.h" 2








# 25 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/macos.h" 1
# 65 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/macos.h"

# 26 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/os400.h" 1
# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/os400.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/os400.h" 2
# 45 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/os400.h"

# 27 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/qnxnto.h" 1
# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/qnxnto.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/qnxnto.h" 2
# 59 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/qnxnto.h"

# 28 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/solaris.h" 1
# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/solaris.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/solaris.h" 2
# 46 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/solaris.h"

# 29 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/unix.h" 1
# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/unix.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/unix.h" 2
# 75 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/unix.h"


# 30 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/vms.h" 1
# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/vms.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/vms.h" 2
# 52 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/vms.h"

# 31 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/windows.h" 1
# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/windows.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/windows.h" 2
# 51 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/windows.h"

# 32 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os.h" 2
# 18 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/other.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/other.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/other/endian.h" 1
# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/other/endian.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/other/endian.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/c/gnu.h" 1
# 61 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/library/c/gnu.h"

# 14 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/other/endian.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/macos.h" 1
# 65 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/macos.h"

# 15 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/other/endian.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 1
# 94 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/bsdi.h" 1
# 48 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/bsdi.h"

# 95 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/dragonfly.h" 1
# 50 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/dragonfly.h"

# 96 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/free.h" 1
# 60 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/free.h"

# 97 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/open.h" 1
# 171 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/open.h"

# 98 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/net.h" 1
# 84 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd/net.h"

# 99 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2





# 16 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/other/endian.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/android.h" 1
# 45 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/android.h"

# 17 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/other/endian.h" 2
# 195 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/other/endian.h"










# 14 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/other.h" 2
# 19 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/platform.h" 1
# 14 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/platform.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/platform/mingw.h" 1
# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/platform/mingw.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/platform/mingw.h" 2
# 64 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/platform/mingw.h"

# 15 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/platform.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/platform/windows_desktop.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/platform/windows_desktop.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 14 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/platform/windows_desktop.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/windows.h" 1
# 51 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/windows.h"

# 15 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/platform/windows_desktop.h" 2
# 45 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/platform/windows_desktop.h"

# 16 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/platform.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/platform/windows_store.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/platform/windows_store.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 14 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/platform/windows_store.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/windows.h" 1
# 51 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/windows.h"

# 15 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/platform/windows_store.h" 2
# 43 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/platform/windows_store.h"

# 17 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/platform.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/platform/windows_phone.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/platform/windows_phone.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 14 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/platform/windows_phone.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/windows.h" 1
# 51 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/windows.h"

# 15 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/platform/windows_phone.h" 2
# 43 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/platform/windows_phone.h"

# 18 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/platform.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/platform/windows_runtime.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/platform/windows_runtime.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 14 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/platform/windows_runtime.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/windows.h" 1
# 51 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/os/windows.h"

# 15 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/platform/windows_runtime.h" 2
# 45 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/platform/windows_runtime.h"

# 19 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/platform.h" 2
# 20 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/hardware.h" 1
# 14 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/hardware.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/hardware/simd.h" 1
# 9 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/hardware/simd.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/hardware/simd/x86.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/hardware/simd/x86.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/hardware/simd/x86/versions.h" 1
# 14 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/hardware/simd/x86.h" 2
# 123 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/hardware/simd/x86.h"

# 10 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/hardware/simd.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/hardware/simd/x86_amd.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/hardware/simd/x86_amd.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/hardware/simd/x86_amd/versions.h" 1
# 14 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/hardware/simd/x86_amd.h" 2
# 87 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/hardware/simd/x86_amd.h"

# 11 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/hardware/simd.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/hardware/simd/arm.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/hardware/simd/arm.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/hardware/simd/arm/versions.h" 1
# 14 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/hardware/simd/arm.h" 2
# 57 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/hardware/simd/arm.h"

# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/hardware/simd.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/hardware/simd/ppc.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/hardware/simd/ppc.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/hardware/simd/ppc/versions.h" 1
# 14 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/hardware/simd/ppc.h" 2
# 69 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/hardware/simd/ppc.h"

# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/hardware/simd.h" 2
# 119 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/hardware/simd.h"

# 15 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/hardware.h" 2
# 21 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef.h" 2

# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef/version.h" 1
# 23 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/predef.h" 2
# 14 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/sysdep.h" 2


# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 17 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/sysdep.h" 2
# 63 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/sysdep.h"
    typedef unsigned int _msgpack_atomic_counter_t;
# 84 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/sysdep.h"
# 1 "/usr/include/byteswap.h" 1 3 4
# 24 "/usr/include/byteswap.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 1 3 4
# 25 "/usr/include/byteswap.h" 2 3 4
# 85 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/sysdep.h" 2
# 14 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/zone.h" 2
# 26 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/zone.h"
typedef struct msgpack_zone_finalizer {
    void (*func)(void* data);
    void* data;
} msgpack_zone_finalizer;

typedef struct msgpack_zone_finalizer_array {
    msgpack_zone_finalizer* tail;
    msgpack_zone_finalizer* end;
    msgpack_zone_finalizer* array;
} msgpack_zone_finalizer_array;

struct msgpack_zone_chunk;
typedef struct msgpack_zone_chunk msgpack_zone_chunk;

typedef struct msgpack_zone_chunk_list {
    size_t free;
    char* ptr;
    msgpack_zone_chunk* head;
} msgpack_zone_chunk_list;

typedef struct msgpack_zone {
    msgpack_zone_chunk_list chunk_list;
    msgpack_zone_finalizer_array finalizer_array;
    size_t chunk_size;
} msgpack_zone;







# 57 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/zone.h" 3 4
_Bool 
# 57 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/zone.h"
    msgpack_zone_init(msgpack_zone* zone, size_t chunk_size);

void msgpack_zone_destroy(msgpack_zone* zone);


msgpack_zone* msgpack_zone_new(size_t chunk_size);

void msgpack_zone_free(msgpack_zone* zone);

static inline void* msgpack_zone_malloc(msgpack_zone* zone, size_t size);
static inline void* msgpack_zone_malloc_no_align(msgpack_zone* zone, size_t size);

static inline 
# 69 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/zone.h" 3 4
             _Bool 
# 69 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/zone.h"
                  msgpack_zone_push_finalizer(msgpack_zone* zone,
        void (*func)(void* data), void* data);

static inline void msgpack_zone_swap(msgpack_zone* a, msgpack_zone* b);



# 75 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/zone.h" 3 4
_Bool 
# 75 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/zone.h"
    msgpack_zone_is_empty(msgpack_zone* zone);


void msgpack_zone_clear(msgpack_zone* zone);
# 87 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/zone.h"

void* msgpack_zone_malloc_expand(msgpack_zone* zone, size_t size);

static inline void* msgpack_zone_malloc_no_align(msgpack_zone* zone, size_t size)
{
    char* ptr;
    msgpack_zone_chunk_list* cl = &zone->chunk_list;

    if(zone->chunk_list.free < size) {
        return msgpack_zone_malloc_expand(zone, size);
    }

    ptr = cl->ptr;
    cl->free -= size;
    cl->ptr += size;

    return ptr;
}

static inline void* msgpack_zone_malloc(msgpack_zone* zone, size_t size)
{
    char* aligned =
        (char*)(
            (size_t)(
                zone->chunk_list.ptr + (sizeof(void*) - 1)
            ) / sizeof(void*) * sizeof(void*)
        );
    size_t adjusted_size = size + (aligned - zone->chunk_list.ptr);
    if(zone->chunk_list.free >= adjusted_size) {
        zone->chunk_list.free -= adjusted_size;
        zone->chunk_list.ptr += adjusted_size;
        return aligned;
    }
    {
        void* ptr = msgpack_zone_malloc_expand(zone, size + (sizeof(void*) - 1));
        if (ptr) {
            return (char*)((size_t)(ptr) / sizeof(void*) * sizeof(void*));
        }
    }
    return 
# 126 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/zone.h" 3 4
          ((void *)0)
# 126 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/zone.h"
              ;
}



# 130 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/zone.h" 3 4
_Bool 
# 130 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/zone.h"
    msgpack_zone_push_finalizer_expand(msgpack_zone* zone,
        void (*func)(void* data), void* data);

static inline 
# 133 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/zone.h" 3 4
             _Bool 
# 133 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/zone.h"
                  msgpack_zone_push_finalizer(msgpack_zone* zone,
        void (*func)(void* data), void* data)
{
    msgpack_zone_finalizer_array* const fa = &zone->finalizer_array;
    msgpack_zone_finalizer* fin = fa->tail;

    if(fin == fa->end) {
        return msgpack_zone_push_finalizer_expand(zone, func, data);
    }

    fin->func = func;
    fin->data = data;

    ++fa->tail;

    return 
# 148 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/zone.h" 3 4
          1
# 148 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/zone.h"
              ;
}

static inline void msgpack_zone_swap(msgpack_zone* a, msgpack_zone* b)
{
    msgpack_zone tmp = *a;
    *a = *b;
    *b = tmp;
}
# 14 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/object.h" 2
# 27 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/object.h"
typedef enum {
    MSGPACK_OBJECT_NIL = 0x00,
    MSGPACK_OBJECT_BOOLEAN = 0x01,
    MSGPACK_OBJECT_POSITIVE_INTEGER = 0x02,
    MSGPACK_OBJECT_NEGATIVE_INTEGER = 0x03,
    MSGPACK_OBJECT_FLOAT32 = 0x0a,
    MSGPACK_OBJECT_FLOAT64 = 0x04,
    MSGPACK_OBJECT_FLOAT = 0x04,



    MSGPACK_OBJECT_STR = 0x05,
    MSGPACK_OBJECT_ARRAY = 0x06,
    MSGPACK_OBJECT_MAP = 0x07,
    MSGPACK_OBJECT_BIN = 0x08,
    MSGPACK_OBJECT_EXT = 0x09
} msgpack_object_type;


struct msgpack_object;
struct msgpack_object_kv;

typedef struct {
    uint32_t size;
    struct msgpack_object* ptr;
} msgpack_object_array;

typedef struct {
    uint32_t size;
    struct msgpack_object_kv* ptr;
} msgpack_object_map;

typedef struct {
    uint32_t size;
    const char* ptr;
} msgpack_object_str;

typedef struct {
    uint32_t size;
    const char* ptr;
} msgpack_object_bin;

typedef struct {
    int8_t type;
    uint32_t size;
    const char* ptr;
} msgpack_object_ext;

typedef union {
    
# 76 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/object.h" 3 4
   _Bool 
# 76 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/object.h"
        boolean;
    uint64_t u64;
    int64_t i64;



    double f64;
    msgpack_object_array array;
    msgpack_object_map map;
    msgpack_object_str str;
    msgpack_object_bin bin;
    msgpack_object_ext ext;
} msgpack_object_union;

typedef struct msgpack_object {
    msgpack_object_type type;
    msgpack_object_union via;
} msgpack_object;

typedef struct msgpack_object_kv {
    msgpack_object key;
    msgpack_object val;
} msgpack_object_kv;


void msgpack_object_print(FILE* out, msgpack_object o);


int msgpack_object_print_buffer(char *buffer, size_t buffer_size, msgpack_object o);



# 107 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/object.h" 3 4
_Bool 
# 107 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/object.h"
    msgpack_object_equal(const msgpack_object x, const msgpack_object y);
# 18 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/zone.h" 1
# 19 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack_define.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack_define.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/sysdep.h" 1
# 14 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack_define.h" 2
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include-fixed/limits.h" 1 3 4
# 15 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack_define.h" 2
# 14 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/object.h" 1
# 15 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack.h" 2
# 35 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack.h"
typedef int (*msgpack_packer_write)(void* data, const char* buf, size_t len);

typedef struct msgpack_packer {
    void* data;
    msgpack_packer_write callback;
} msgpack_packer;

static void msgpack_packer_init(msgpack_packer* pk, void* data, msgpack_packer_write callback);

static msgpack_packer* msgpack_packer_new(void* data, msgpack_packer_write callback);
static void msgpack_packer_free(msgpack_packer* pk);

static int msgpack_pack_char(msgpack_packer* pk, char d);

static int msgpack_pack_signed_char(msgpack_packer* pk, signed char d);
static int msgpack_pack_short(msgpack_packer* pk, short d);
static int msgpack_pack_int(msgpack_packer* pk, int d);
static int msgpack_pack_long(msgpack_packer* pk, long d);
static int msgpack_pack_long_long(msgpack_packer* pk, long long d);
static int msgpack_pack_unsigned_char(msgpack_packer* pk, unsigned char d);
static int msgpack_pack_unsigned_short(msgpack_packer* pk, unsigned short d);
static int msgpack_pack_unsigned_int(msgpack_packer* pk, unsigned int d);
static int msgpack_pack_unsigned_long(msgpack_packer* pk, unsigned long d);
static int msgpack_pack_unsigned_long_long(msgpack_packer* pk, unsigned long long d);

static int msgpack_pack_uint8(msgpack_packer* pk, uint8_t d);
static int msgpack_pack_uint16(msgpack_packer* pk, uint16_t d);
static int msgpack_pack_uint32(msgpack_packer* pk, uint32_t d);
static int msgpack_pack_uint64(msgpack_packer* pk, uint64_t d);
static int msgpack_pack_int8(msgpack_packer* pk, int8_t d);
static int msgpack_pack_int16(msgpack_packer* pk, int16_t d);
static int msgpack_pack_int32(msgpack_packer* pk, int32_t d);
static int msgpack_pack_int64(msgpack_packer* pk, int64_t d);

static int msgpack_pack_fix_uint8(msgpack_packer* pk, uint8_t d);
static int msgpack_pack_fix_uint16(msgpack_packer* pk, uint16_t d);
static int msgpack_pack_fix_uint32(msgpack_packer* pk, uint32_t d);
static int msgpack_pack_fix_uint64(msgpack_packer* pk, uint64_t d);
static int msgpack_pack_fix_int8(msgpack_packer* pk, int8_t d);
static int msgpack_pack_fix_int16(msgpack_packer* pk, int16_t d);
static int msgpack_pack_fix_int32(msgpack_packer* pk, int32_t d);
static int msgpack_pack_fix_int64(msgpack_packer* pk, int64_t d);

static int msgpack_pack_float(msgpack_packer* pk, float d);
static int msgpack_pack_double(msgpack_packer* pk, double d);

static int msgpack_pack_nil(msgpack_packer* pk);
static int msgpack_pack_true(msgpack_packer* pk);
static int msgpack_pack_false(msgpack_packer* pk);

static int msgpack_pack_array(msgpack_packer* pk, size_t n);

static int msgpack_pack_map(msgpack_packer* pk, size_t n);

static int msgpack_pack_str(msgpack_packer* pk, size_t l);
static int msgpack_pack_str_body(msgpack_packer* pk, const void* b, size_t l);

static int msgpack_pack_v4raw(msgpack_packer* pk, size_t l);
static int msgpack_pack_v4raw_body(msgpack_packer* pk, const void* b, size_t l);

static int msgpack_pack_bin(msgpack_packer* pk, size_t l);
static int msgpack_pack_bin_body(msgpack_packer* pk, const void* b, size_t l);

static int msgpack_pack_ext(msgpack_packer* pk, size_t l, int8_t type);
static int msgpack_pack_ext_body(msgpack_packer* pk, const void* b, size_t l);


int msgpack_pack_object(msgpack_packer* pk, msgpack_object d);
# 122 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack.h"
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack_template.h" 1
# 271 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack_template.h"
inline int msgpack_pack_fix_uint8(msgpack_packer* x, uint8_t d)
{
    unsigned char buf[2] = {0xcc, ((uint8_t*)&d)[0]};
    return (*(x)->callback)((x)->data, (const char*)buf, 2);
}

inline int msgpack_pack_fix_uint16(msgpack_packer* x, uint16_t d)
{
    unsigned char buf[3];
    buf[0] = 0xcd; do { uint16_t val = ntohs(d); memcpy(&buf[1], &val, 2); } while(0);
    return (*(x)->callback)((x)->data, (const char*)buf, 3);
}

inline int msgpack_pack_fix_uint32(msgpack_packer* x, uint32_t d)
{
    unsigned char buf[5];
    buf[0] = 0xce; do { uint32_t val = ntohl(d); memcpy(&buf[1], &val, 4); } while(0);
    return (*(x)->callback)((x)->data, (const char*)buf, 5);
}

inline int msgpack_pack_fix_uint64(msgpack_packer* x, uint64_t d)
{
    unsigned char buf[9];
    buf[0] = 0xcf; do { uint64_t val = 
# 294 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
                  __bswap_64 (
# 294 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack_template.h"
                  d
# 294 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
                  )
# 294 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack_template.h"
                  ; memcpy(&buf[1], &val, 8); } while(0);
    return (*(x)->callback)((x)->data, (const char*)buf, 9);
}

inline int msgpack_pack_fix_int8(msgpack_packer* x, int8_t d)
{
    unsigned char buf[2] = {0xd0, ((uint8_t*)&d)[0]};
    return (*(x)->callback)((x)->data, (const char*)buf, 2);
}

inline int msgpack_pack_fix_int16(msgpack_packer* x, int16_t d)
{
    unsigned char buf[3];
    buf[0] = 0xd1; do { uint16_t val = ntohs(d); memcpy(&buf[1], &val, 2); } while(0);
    return (*(x)->callback)((x)->data, (const char*)buf, 3);
}

inline int msgpack_pack_fix_int32(msgpack_packer* x, int32_t d)
{
    unsigned char buf[5];
    buf[0] = 0xd2; do { uint32_t val = ntohl(d); memcpy(&buf[1], &val, 4); } while(0);
    return (*(x)->callback)((x)->data, (const char*)buf, 5);
}

inline int msgpack_pack_fix_int64(msgpack_packer* x, int64_t d)
{
    unsigned char buf[9];
    buf[0] = 0xd3; do { uint64_t val = 
# 321 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
                  __bswap_64 (
# 321 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack_template.h"
                  d
# 321 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
                  )
# 321 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack_template.h"
                  ; memcpy(&buf[1], &val, 8); } while(0);
    return (*(x)->callback)((x)->data, (const char*)buf, 9);
}





inline int msgpack_pack_uint8(msgpack_packer* x, uint8_t d)
{
    do { if(d < (1<<7)) { return (*(x)->callback)((x)->data, (const char*)&((uint8_t*)&d)[0], 1); } else { unsigned char buf[2] = {0xcc, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } } while(0);
}

inline int msgpack_pack_uint16(msgpack_packer* x, uint16_t d)
{
    do { if(d < (1<<7)) { return (*(x)->callback)((x)->data, (const char*)&((uint8_t*)&d)[0], 1); } else if(d < (1<<8)) { unsigned char buf[2] = {0xcc, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } else { unsigned char buf[3]; buf[0] = 0xcd; do { uint16_t val = ntohs((uint16_t)d); memcpy(&buf[1], &val, 2); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 3); } } while(0);
}

inline int msgpack_pack_uint32(msgpack_packer* x, uint32_t d)
{
    do { if(d < (1<<8)) { if(d < (1<<7)) { return (*(x)->callback)((x)->data, (const char*)&((uint8_t*)&d)[0], 1); } else { unsigned char buf[2] = {0xcc, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } } else { if(d < (1<<16)) { unsigned char buf[3]; buf[0] = 0xcd; do { uint16_t val = ntohs((uint16_t)d); memcpy(&buf[1], &val, 2); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 3); } else { unsigned char buf[5]; buf[0] = 0xce; do { uint32_t val = ntohl((uint32_t)d); memcpy(&buf[1], &val, 4); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 5); } } } while(0);
}

inline int msgpack_pack_uint64(msgpack_packer* x, uint64_t d)
{
    do { if(d < (1ULL<<8)) { if(d < (1ULL<<7)) { return (*(x)->callback)((x)->data, (const char*)&((uint8_t*)&d)[0], 1); } else { unsigned char buf[2] = {0xcc, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } } else { if(d < (1ULL<<16)) { unsigned char buf[3]; buf[0] = 0xcd; do { uint16_t val = ntohs((uint16_t)d); memcpy(&buf[1], &val, 2); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 3); } else if(d < (1ULL<<32)) { unsigned char buf[5]; buf[0] = 0xce; do { uint32_t val = ntohl((uint32_t)d); memcpy(&buf[1], &val, 4); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 5); } else { unsigned char buf[9]; buf[0] = 0xcf; do { uint64_t val = 
# 346 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   __bswap_64 (
# 346 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack_template.h"
   d
# 346 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   )
# 346 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack_template.h"
   ; memcpy(&buf[1], &val, 8); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 9); } } } while(0);
}

inline int msgpack_pack_int8(msgpack_packer* x, int8_t d)
{
    do { if(d < -(1<<5)) { unsigned char buf[2] = {0xd0, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } else { return (*(x)->callback)((x)->data, (const char*)&((uint8_t*)&d)[0], 1); } } while(0);
}

inline int msgpack_pack_int16(msgpack_packer* x, int16_t d)
{
    do { if(d < -(1<<5)) { if(d < -(1<<7)) { unsigned char buf[3]; buf[0] = 0xd1; do { uint16_t val = ntohs((int16_t)d); memcpy(&buf[1], &val, 2); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 3); } else { unsigned char buf[2] = {0xd0, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } } else if(d < (1<<7)) { return (*(x)->callback)((x)->data, (const char*)&((uint8_t*)&d)[0], 1); } else { if(d < (1<<8)) { unsigned char buf[2] = {0xcc, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } else { unsigned char buf[3]; buf[0] = 0xcd; do { uint16_t val = ntohs((uint16_t)d); memcpy(&buf[1], &val, 2); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 3); } } } while(0);
}

inline int msgpack_pack_int32(msgpack_packer* x, int32_t d)
{
    do { if(d < -(1<<5)) { if(d < -(1<<15)) { unsigned char buf[5]; buf[0] = 0xd2; do { uint32_t val = ntohl((int32_t)d); memcpy(&buf[1], &val, 4); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 5); } else if(d < -(1<<7)) { unsigned char buf[3]; buf[0] = 0xd1; do { uint16_t val = ntohs((int16_t)d); memcpy(&buf[1], &val, 2); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 3); } else { unsigned char buf[2] = {0xd0, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } } else if(d < (1<<7)) { return (*(x)->callback)((x)->data, (const char*)&((uint8_t*)&d)[0], 1); } else { if(d < (1<<8)) { unsigned char buf[2] = {0xcc, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } else if(d < (1<<16)) { unsigned char buf[3]; buf[0] = 0xcd; do { uint16_t val = ntohs((uint16_t)d); memcpy(&buf[1], &val, 2); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 3); } else { unsigned char buf[5]; buf[0] = 0xce; do { uint32_t val = ntohl((uint32_t)d); memcpy(&buf[1], &val, 4); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 5); } } } while(0);
}

inline int msgpack_pack_int64(msgpack_packer* x, int64_t d)
{
    do { if(d < -(1LL<<5)) { if(d < -(1LL<<15)) { if(d < -(1LL<<31)) { unsigned char buf[9]; buf[0] = 0xd3; do { uint64_t val = 
# 366 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   __bswap_64 (
# 366 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack_template.h"
   d
# 366 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   )
# 366 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack_template.h"
   ; memcpy(&buf[1], &val, 8); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 9); } else { unsigned char buf[5]; buf[0] = 0xd2; do { uint32_t val = ntohl((int32_t)d); memcpy(&buf[1], &val, 4); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 5); } } else { if(d < -(1<<7)) { unsigned char buf[3]; buf[0] = 0xd1; do { uint16_t val = ntohs((int16_t)d); memcpy(&buf[1], &val, 2); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 3); } else { unsigned char buf[2] = {0xd0, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } } } else if(d < (1<<7)) { return (*(x)->callback)((x)->data, (const char*)&((uint8_t*)&d)[0], 1); } else { if(d < (1LL<<16)) { if(d < (1<<8)) { unsigned char buf[2] = {0xcc, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } else { unsigned char buf[3]; buf[0] = 0xcd; do { uint16_t val = ntohs((uint16_t)d); memcpy(&buf[1], &val, 2); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 3); } } else { if(d < (1LL<<32)) { unsigned char buf[5]; buf[0] = 0xce; do { uint32_t val = ntohl((uint32_t)d); memcpy(&buf[1], &val, 4); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 5); } else { unsigned char buf[9]; buf[0] = 0xcf; do { uint64_t val = 
# 366 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   __bswap_64 (
# 366 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack_template.h"
   d
# 366 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   )
# 366 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack_template.h"
   ; memcpy(&buf[1], &val, 8); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 9); } } } } while(0);
}

inline int msgpack_pack_char(msgpack_packer* x, char d)
{


        do { if(d < -(1<<5)) { unsigned char buf[2] = {0xd0, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } else { return (*(x)->callback)((x)->data, (const char*)&((uint8_t*)&d)[0], 1); } } while(0);






}

inline int msgpack_pack_signed_char(msgpack_packer* x, signed char d)
{
    do { if(d < -(1<<5)) { unsigned char buf[2] = {0xd0, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } else { return (*(x)->callback)((x)->data, (const char*)&((uint8_t*)&d)[0], 1); } } while(0);
}

inline int msgpack_pack_unsigned_char(msgpack_packer* x, unsigned char d)
{
    do { if(d < (1<<7)) { return (*(x)->callback)((x)->data, (const char*)&((uint8_t*)&d)[0], 1); } else { unsigned char buf[2] = {0xcc, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } } while(0);
}



inline int msgpack_pack_short(msgpack_packer* x, short d)
{
# 407 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack_template.h"
    do { if(d < -(1<<5)) { if(d < -(1<<7)) { unsigned char buf[3]; buf[0] = 0xd1; do { uint16_t val = ntohs((int16_t)d); memcpy(&buf[1], &val, 2); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 3); } else { unsigned char buf[2] = {0xd0, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } } else if(d < (1<<7)) { return (*(x)->callback)((x)->data, (const char*)&((uint8_t*)&d)[0], 1); } else { if(d < (1<<8)) { unsigned char buf[2] = {0xcc, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } else { unsigned char buf[3]; buf[0] = 0xcd; do { uint16_t val = ntohs((uint16_t)d); memcpy(&buf[1], &val, 2); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 3); } } } while(0);
# 423 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack_template.h"
}

inline int msgpack_pack_int(msgpack_packer* x, int d)
{




    do { if(d < -(1<<5)) { if(d < -(1<<15)) { unsigned char buf[5]; buf[0] = 0xd2; do { uint32_t val = ntohl((int32_t)d); memcpy(&buf[1], &val, 4); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 5); } else if(d < -(1<<7)) { unsigned char buf[3]; buf[0] = 0xd1; do { uint16_t val = ntohs((int16_t)d); memcpy(&buf[1], &val, 2); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 3); } else { unsigned char buf[2] = {0xd0, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } } else if(d < (1<<7)) { return (*(x)->callback)((x)->data, (const char*)&((uint8_t*)&d)[0], 1); } else { if(d < (1<<8)) { unsigned char buf[2] = {0xcc, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } else if(d < (1<<16)) { unsigned char buf[3]; buf[0] = 0xcd; do { uint16_t val = ntohs((uint16_t)d); memcpy(&buf[1], &val, 2); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 3); } else { unsigned char buf[5]; buf[0] = 0xce; do { uint32_t val = ntohl((uint32_t)d); memcpy(&buf[1], &val, 4); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 5); } } } while(0);
# 454 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack_template.h"
}

inline int msgpack_pack_long(msgpack_packer* x, long d)
{






    do { if(d < -(1LL<<5)) { if(d < -(1LL<<15)) { if(d < -(1LL<<31)) { unsigned char buf[9]; buf[0] = 0xd3; do { uint64_t val = 
# 464 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   __bswap_64 (
# 464 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack_template.h"
   d
# 464 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   )
# 464 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack_template.h"
   ; memcpy(&buf[1], &val, 8); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 9); } else { unsigned char buf[5]; buf[0] = 0xd2; do { uint32_t val = ntohl((int32_t)d); memcpy(&buf[1], &val, 4); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 5); } } else { if(d < -(1<<7)) { unsigned char buf[3]; buf[0] = 0xd1; do { uint16_t val = ntohs((int16_t)d); memcpy(&buf[1], &val, 2); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 3); } else { unsigned char buf[2] = {0xd0, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } } } else if(d < (1<<7)) { return (*(x)->callback)((x)->data, (const char*)&((uint8_t*)&d)[0], 1); } else { if(d < (1LL<<16)) { if(d < (1<<8)) { unsigned char buf[2] = {0xcc, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } else { unsigned char buf[3]; buf[0] = 0xcd; do { uint16_t val = ntohs((uint16_t)d); memcpy(&buf[1], &val, 2); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 3); } } else { if(d < (1LL<<32)) { unsigned char buf[5]; buf[0] = 0xce; do { uint32_t val = ntohl((uint32_t)d); memcpy(&buf[1], &val, 4); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 5); } else { unsigned char buf[9]; buf[0] = 0xcf; do { uint64_t val = 
# 464 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   __bswap_64 (
# 464 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack_template.h"
   d
# 464 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   )
# 464 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack_template.h"
   ; memcpy(&buf[1], &val, 8); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 9); } } } } while(0);
# 485 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack_template.h"
}

inline int msgpack_pack_long_long(msgpack_packer* x, long long d)
{
# 504 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack_template.h"
    do { if(d < -(1LL<<5)) { if(d < -(1LL<<15)) { if(d < -(1LL<<31)) { unsigned char buf[9]; buf[0] = 0xd3; do { uint64_t val = 
# 504 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   __bswap_64 (
# 504 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack_template.h"
   d
# 504 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   )
# 504 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack_template.h"
   ; memcpy(&buf[1], &val, 8); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 9); } else { unsigned char buf[5]; buf[0] = 0xd2; do { uint32_t val = ntohl((int32_t)d); memcpy(&buf[1], &val, 4); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 5); } } else { if(d < -(1<<7)) { unsigned char buf[3]; buf[0] = 0xd1; do { uint16_t val = ntohs((int16_t)d); memcpy(&buf[1], &val, 2); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 3); } else { unsigned char buf[2] = {0xd0, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } } } else if(d < (1<<7)) { return (*(x)->callback)((x)->data, (const char*)&((uint8_t*)&d)[0], 1); } else { if(d < (1LL<<16)) { if(d < (1<<8)) { unsigned char buf[2] = {0xcc, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } else { unsigned char buf[3]; buf[0] = 0xcd; do { uint16_t val = ntohs((uint16_t)d); memcpy(&buf[1], &val, 2); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 3); } } else { if(d < (1LL<<32)) { unsigned char buf[5]; buf[0] = 0xce; do { uint32_t val = ntohl((uint32_t)d); memcpy(&buf[1], &val, 4); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 5); } else { unsigned char buf[9]; buf[0] = 0xcf; do { uint64_t val = 
# 504 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   __bswap_64 (
# 504 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack_template.h"
   d
# 504 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   )
# 504 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack_template.h"
   ; memcpy(&buf[1], &val, 8); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 9); } } } } while(0);
# 516 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack_template.h"
}

inline int msgpack_pack_unsigned_short(msgpack_packer* x, unsigned short d)
{
# 531 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack_template.h"
    do { if(d < (1<<7)) { return (*(x)->callback)((x)->data, (const char*)&((uint8_t*)&d)[0], 1); } else if(d < (1<<8)) { unsigned char buf[2] = {0xcc, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } else { unsigned char buf[3]; buf[0] = 0xcd; do { uint16_t val = ntohs((uint16_t)d); memcpy(&buf[1], &val, 2); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 3); } } while(0);
# 547 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack_template.h"
}

inline int msgpack_pack_unsigned_int(msgpack_packer* x, unsigned int d)
{




    do { if(d < (1<<8)) { if(d < (1<<7)) { return (*(x)->callback)((x)->data, (const char*)&((uint8_t*)&d)[0], 1); } else { unsigned char buf[2] = {0xcc, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } } else { if(d < (1<<16)) { unsigned char buf[3]; buf[0] = 0xcd; do { uint16_t val = ntohs((uint16_t)d); memcpy(&buf[1], &val, 2); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 3); } else { unsigned char buf[5]; buf[0] = 0xce; do { uint32_t val = ntohl((uint32_t)d); memcpy(&buf[1], &val, 4); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 5); } } } while(0);
# 578 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack_template.h"
}

inline int msgpack_pack_unsigned_long(msgpack_packer* x, unsigned long d)
{






    do { if(d < (1ULL<<8)) { if(d < (1ULL<<7)) { return (*(x)->callback)((x)->data, (const char*)&((uint8_t*)&d)[0], 1); } else { unsigned char buf[2] = {0xcc, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } } else { if(d < (1ULL<<16)) { unsigned char buf[3]; buf[0] = 0xcd; do { uint16_t val = ntohs((uint16_t)d); memcpy(&buf[1], &val, 2); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 3); } else if(d < (1ULL<<32)) { unsigned char buf[5]; buf[0] = 0xce; do { uint32_t val = ntohl((uint32_t)d); memcpy(&buf[1], &val, 4); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 5); } else { unsigned char buf[9]; buf[0] = 0xcf; do { uint64_t val = 
# 588 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   __bswap_64 (
# 588 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack_template.h"
   d
# 588 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   )
# 588 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack_template.h"
   ; memcpy(&buf[1], &val, 8); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 9); } } } while(0);
# 609 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack_template.h"
}

inline int msgpack_pack_unsigned_long_long(msgpack_packer* x, unsigned long long d)
{
# 628 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack_template.h"
    do { if(d < (1ULL<<8)) { if(d < (1ULL<<7)) { return (*(x)->callback)((x)->data, (const char*)&((uint8_t*)&d)[0], 1); } else { unsigned char buf[2] = {0xcc, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } } else { if(d < (1ULL<<16)) { unsigned char buf[3]; buf[0] = 0xcd; do { uint16_t val = ntohs((uint16_t)d); memcpy(&buf[1], &val, 2); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 3); } else if(d < (1ULL<<32)) { unsigned char buf[5]; buf[0] = 0xce; do { uint32_t val = ntohl((uint32_t)d); memcpy(&buf[1], &val, 4); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 5); } else { unsigned char buf[9]; buf[0] = 0xcf; do { uint64_t val = 
# 628 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   __bswap_64 (
# 628 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack_template.h"
   d
# 628 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   )
# 628 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack_template.h"
   ; memcpy(&buf[1], &val, 8); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 9); } } } while(0);
# 640 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack_template.h"
}
# 651 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack_template.h"
inline int msgpack_pack_float(msgpack_packer* x, float d)
{
    unsigned char buf[5];
    union { float f; uint32_t i; } mem;
    mem.f = d;
    buf[0] = 0xca; do { uint32_t val = ntohl(mem.i); memcpy(&buf[1], &val, 4); } while(0);
    return (*(x)->callback)((x)->data, (const char*)buf, 5);
}

inline int msgpack_pack_double(msgpack_packer* x, double d)
{
    unsigned char buf[9];
    union { double f; uint64_t i; } mem;
    mem.f = d;
    buf[0] = 0xcb;






    do { uint64_t val = 
# 672 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   __bswap_64 (
# 672 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack_template.h"
   mem.i
# 672 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   )
# 672 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack_template.h"
   ; memcpy(&buf[1], &val, 8); } while(0);
    return (*(x)->callback)((x)->data, (const char*)buf, 9);
}






inline int msgpack_pack_nil(msgpack_packer* x)
{
    static const unsigned char d = 0xc0;
    return (*(x)->callback)((x)->data, (const char*)&d, 1);
}






inline int msgpack_pack_true(msgpack_packer* x)
{
    static const unsigned char d = 0xc3;
    return (*(x)->callback)((x)->data, (const char*)&d, 1);
}

inline int msgpack_pack_false(msgpack_packer* x)
{
    static const unsigned char d = 0xc2;
    return (*(x)->callback)((x)->data, (const char*)&d, 1);
}






inline int msgpack_pack_array(msgpack_packer* x, size_t n)
{
    if(n < 16) {
        unsigned char d = 0x90 | (uint8_t)n;
        return (*(x)->callback)((x)->data, (const char*)&d, 1);
    } else if(n < 65536) {
        unsigned char buf[3];
        buf[0] = 0xdc; do { uint16_t val = ntohs((uint16_t)n); memcpy(&buf[1], &val, 2); } while(0);
        return (*(x)->callback)((x)->data, (const char*)buf, 3);
    } else {
        unsigned char buf[5];
        buf[0] = 0xdd; do { uint32_t val = ntohl((uint32_t)n); memcpy(&buf[1], &val, 4); } while(0);
        return (*(x)->callback)((x)->data, (const char*)buf, 5);
    }
}






inline int msgpack_pack_map(msgpack_packer* x, size_t n)
{
    if(n < 16) {
        unsigned char d = 0x80 | (uint8_t)n;
        return (*(x)->callback)((x)->data, (const char*)&((uint8_t*)&d)[0], 1);
    } else if(n < 65536) {
        unsigned char buf[3];
        buf[0] = 0xde; do { uint16_t val = ntohs((uint16_t)n); memcpy(&buf[1], &val, 2); } while(0);
        return (*(x)->callback)((x)->data, (const char*)buf, 3);
    } else {
        unsigned char buf[5];
        buf[0] = 0xdf; do { uint32_t val = ntohl((uint32_t)n); memcpy(&buf[1], &val, 4); } while(0);
        return (*(x)->callback)((x)->data, (const char*)buf, 5);
    }
}






inline int msgpack_pack_str(msgpack_packer* x, size_t l)
{
    if(l < 32) {
        unsigned char d = 0xa0 | (uint8_t)l;
        return (*(x)->callback)((x)->data, (const char*)&((uint8_t*)&d)[0], 1);
    } else if(l < 256) {
        unsigned char buf[2];
        buf[0] = 0xd9; buf[1] = (uint8_t)l;
        return (*(x)->callback)((x)->data, (const char*)buf, 2);
    } else if(l < 65536) {
        unsigned char buf[3];
        buf[0] = 0xda; do { uint16_t val = ntohs((uint16_t)l); memcpy(&buf[1], &val, 2); } while(0);
        return (*(x)->callback)((x)->data, (const char*)buf, 3);
    } else {
        unsigned char buf[5];
        buf[0] = 0xdb; do { uint32_t val = ntohl((uint32_t)l); memcpy(&buf[1], &val, 4); } while(0);
        return (*(x)->callback)((x)->data, (const char*)buf, 5);
    }
}

inline int msgpack_pack_str_body(msgpack_packer* x, const void* b, size_t l)
{
    return (*(x)->callback)((x)->data, (const char*)(const unsigned char*)b, l);
}





inline int msgpack_pack_v4raw(msgpack_packer* x, size_t l)
{
    if(l < 32) {
        unsigned char d = 0xa0 | (uint8_t)l;
        return (*(x)->callback)((x)->data, (const char*)&((uint8_t*)&d)[0], 1);
    } else if(l < 65536) {
        unsigned char buf[3];
        buf[0] = 0xda; do { uint16_t val = ntohs((uint16_t)l); memcpy(&buf[1], &val, 2); } while(0);
        return (*(x)->callback)((x)->data, (const char*)buf, 3);
    } else {
        unsigned char buf[5];
        buf[0] = 0xdb; do { uint32_t val = ntohl((uint32_t)l); memcpy(&buf[1], &val, 4); } while(0);
        return (*(x)->callback)((x)->data, (const char*)buf, 5);
    }
}

inline int msgpack_pack_v4raw_body(msgpack_packer* x, const void* b, size_t l)
{
    return (*(x)->callback)((x)->data, (const char*)(const unsigned char*)b, l);
}





inline int msgpack_pack_bin(msgpack_packer* x, size_t l)
{
    if(l < 256) {
        unsigned char buf[2];
        buf[0] = 0xc4; buf[1] = (uint8_t)l;
        return (*(x)->callback)((x)->data, (const char*)buf, 2);
    } else if(l < 65536) {
        unsigned char buf[3];
        buf[0] = 0xc5; do { uint16_t val = ntohs((uint16_t)l); memcpy(&buf[1], &val, 2); } while(0);
        return (*(x)->callback)((x)->data, (const char*)buf, 3);
    } else {
        unsigned char buf[5];
        buf[0] = 0xc6; do { uint32_t val = ntohl((uint32_t)l); memcpy(&buf[1], &val, 4); } while(0);
        return (*(x)->callback)((x)->data, (const char*)buf, 5);
    }
}

inline int msgpack_pack_bin_body(msgpack_packer* x, const void* b, size_t l)
{
    return (*(x)->callback)((x)->data, (const char*)(const unsigned char*)b, l);
}





inline int msgpack_pack_ext(msgpack_packer* x, size_t l, int8_t type)
{
    switch(l) {
    case 1: {
        unsigned char buf[2];
        buf[0] = 0xd4;
        buf[1] = type;
        return (*(x)->callback)((x)->data, (const char*)buf, 2);
    } break;
    case 2: {
        unsigned char buf[2];
        buf[0] = 0xd5;
        buf[1] = type;
        return (*(x)->callback)((x)->data, (const char*)buf, 2);
    } break;
    case 4: {
        unsigned char buf[2];
        buf[0] = 0xd6;
        buf[1] = type;
        return (*(x)->callback)((x)->data, (const char*)buf, 2);
    } break;
    case 8: {
        unsigned char buf[2];
        buf[0] = 0xd7;
        buf[1] = type;
        return (*(x)->callback)((x)->data, (const char*)buf, 2);
    } break;
    case 16: {
        unsigned char buf[2];
        buf[0] = 0xd8;
        buf[1] = type;
        return (*(x)->callback)((x)->data, (const char*)buf, 2);
    } break;
    default:
        if(l < 256) {
            unsigned char buf[3];
            buf[0] = 0xc7;
            buf[1] = (unsigned char)l;
            buf[2] = type;
            return (*(x)->callback)((x)->data, (const char*)buf, 3);
        } else if(l < 65536) {
            unsigned char buf[4];
            buf[0] = 0xc8;
            do { uint16_t val = ntohs(l); memcpy(&buf[1], &val, 2); } while(0);
            buf[3] = type;
            return (*(x)->callback)((x)->data, (const char*)buf, 4);
        } else {
            unsigned char buf[6];
            buf[0] = 0xc9;
            do { uint32_t val = ntohl(l); memcpy(&buf[1], &val, 4); } while(0);
            buf[5] = type;
            return (*(x)->callback)((x)->data, (const char*)buf, 6);
        }
        break;
    }
}

inline int msgpack_pack_ext_body(msgpack_packer* x, const void* b, size_t l)
{
    return (*(x)->callback)((x)->data, (const char*)(const unsigned char*)b, l);
}
# 123 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack.h" 2

inline void msgpack_packer_init(msgpack_packer* pk, void* data, msgpack_packer_write callback)
{
    pk->data = data;
    pk->callback = callback;
}

inline msgpack_packer* msgpack_packer_new(void* data, msgpack_packer_write callback)
{
    msgpack_packer* pk = (msgpack_packer*)calloc(1, sizeof(msgpack_packer));
    if(!pk) { return 
# 133 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack.h" 3 4
                    ((void *)0)
# 133 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/pack.h"
                        ; }
    msgpack_packer_init(pk, data, callback);
    return pk;
}

inline void msgpack_packer_free(msgpack_packer* pk)
{
    free(pk);
}
# 20 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/unpack.h" 1
# 28 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/unpack.h"
typedef struct msgpack_unpacked {
    msgpack_zone* zone;
    msgpack_object data;
} msgpack_unpacked;

typedef enum {
    MSGPACK_UNPACK_SUCCESS = 2,
    MSGPACK_UNPACK_EXTRA_BYTES = 1,
    MSGPACK_UNPACK_CONTINUE = 0,
    MSGPACK_UNPACK_PARSE_ERROR = -1,
    MSGPACK_UNPACK_NOMEM_ERROR = -2
} msgpack_unpack_return;



msgpack_unpack_return
msgpack_unpack_next(msgpack_unpacked* result,
        const char* data, size_t len, size_t* off);
# 56 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/unpack.h"
typedef struct msgpack_unpacker {
    char* buffer;
    size_t used;
    size_t free;
    size_t off;
    size_t parsed;
    msgpack_zone* z;
    size_t initial_buffer_size;
    void* ctx;
} msgpack_unpacker;
# 76 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/unpack.h"


# 77 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/unpack.h" 3 4
_Bool 
# 77 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/unpack.h"
    msgpack_unpacker_init(msgpack_unpacker* mpac, size_t initial_buffer_size);





void msgpack_unpacker_destroy(msgpack_unpacker* mpac);







msgpack_unpacker* msgpack_unpacker_new(size_t initial_buffer_size);





void msgpack_unpacker_free(msgpack_unpacker* mpac);
# 111 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/unpack.h"
static inline 
# 111 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/unpack.h" 3 4
             _Bool 
# 111 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/unpack.h"
                    msgpack_unpacker_reserve_buffer(msgpack_unpacker* mpac, size_t size);
# 120 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/unpack.h"
static inline char* msgpack_unpacker_buffer(msgpack_unpacker* mpac);
# 129 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/unpack.h"
static inline size_t msgpack_unpacker_buffer_capacity(const msgpack_unpacker* mpac);
# 138 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/unpack.h"
static inline void msgpack_unpacker_buffer_consumed(msgpack_unpacker* mpac, size_t size);








msgpack_unpack_return msgpack_unpacker_next(msgpack_unpacker* mpac, msgpack_unpacked* pac);
# 156 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/unpack.h"

msgpack_unpack_return msgpack_unpacker_next_with_size(msgpack_unpacker* mpac,
                                                      msgpack_unpacked* result,
                                                      size_t *p_bytes);







static inline void msgpack_unpacked_init(msgpack_unpacked* result);




static inline void msgpack_unpacked_destroy(msgpack_unpacked* result);





static inline msgpack_zone* msgpack_unpacked_release_zone(msgpack_unpacked* result);



int msgpack_unpacker_execute(msgpack_unpacker* mpac);


msgpack_object msgpack_unpacker_data(msgpack_unpacker* mpac);


msgpack_zone* msgpack_unpacker_release_zone(msgpack_unpacker* mpac);


void msgpack_unpacker_reset_zone(msgpack_unpacker* mpac);


void msgpack_unpacker_reset(msgpack_unpacker* mpac);

static inline size_t msgpack_unpacker_message_size(const msgpack_unpacker* mpac);







msgpack_unpack_return
msgpack_unpack(const char* data, size_t len, size_t* off,
        msgpack_zone* result_zone, msgpack_object* result);




static inline size_t msgpack_unpacker_parsed_size(const msgpack_unpacker* mpac);



# 214 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/unpack.h" 3 4
_Bool 
# 214 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/unpack.h"
    msgpack_unpacker_flush_zone(msgpack_unpacker* mpac);



# 217 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/unpack.h" 3 4
_Bool 
# 217 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/unpack.h"
    msgpack_unpacker_expand_buffer(msgpack_unpacker* mpac, size_t size);

static inline 
# 219 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/unpack.h" 3 4
             _Bool 
# 219 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/unpack.h"
                  msgpack_unpacker_reserve_buffer(msgpack_unpacker* mpac, size_t size)
{
    if(mpac->free >= size) { return 
# 221 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/unpack.h" 3 4
                                   1
# 221 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/unpack.h"
                                       ; }
    return msgpack_unpacker_expand_buffer(mpac, size);
}

static inline char* msgpack_unpacker_buffer(msgpack_unpacker* mpac)
{
    return mpac->buffer + mpac->used;
}

static inline size_t msgpack_unpacker_buffer_capacity(const msgpack_unpacker* mpac)
{
    return mpac->free;
}

static inline void msgpack_unpacker_buffer_consumed(msgpack_unpacker* mpac, size_t size)
{
    mpac->used += size;
    mpac->free -= size;
}

static inline size_t msgpack_unpacker_message_size(const msgpack_unpacker* mpac)
{
    return mpac->parsed - mpac->off + mpac->used;
}

static inline size_t msgpack_unpacker_parsed_size(const msgpack_unpacker* mpac)
{
    return mpac->parsed;
}


static inline void msgpack_unpacked_init(msgpack_unpacked* result)
{
    memset(result, 0, sizeof(msgpack_unpacked));
}

static inline void msgpack_unpacked_destroy(msgpack_unpacked* result)
{
    if(result->zone != 
# 259 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/unpack.h" 3 4
                      ((void *)0)
# 259 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/unpack.h"
                          ) {
        msgpack_zone_free(result->zone);
        result->zone = 
# 261 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/unpack.h" 3 4
                      ((void *)0)
# 261 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/unpack.h"
                          ;
        memset(&result->data, 0, sizeof(msgpack_object));
    }
}

static inline msgpack_zone* msgpack_unpacked_release_zone(msgpack_unpacked* result)
{
    if(result->zone != 
# 268 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/unpack.h" 3 4
                      ((void *)0)
# 268 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/unpack.h"
                          ) {
        msgpack_zone* z = result->zone;
        result->zone = 
# 270 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/unpack.h" 3 4
                      ((void *)0)
# 270 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/unpack.h"
                          ;
        return z;
    }
    return 
# 273 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/unpack.h" 3 4
          ((void *)0)
# 273 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/unpack.h"
              ;
}
# 21 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/sbuffer.h" 1
# 27 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/sbuffer.h"
typedef struct msgpack_sbuffer {
    size_t size;
    char* data;
    size_t alloc;
} msgpack_sbuffer;

static inline void msgpack_sbuffer_init(msgpack_sbuffer* sbuf)
{
    memset(sbuf, 0, sizeof(msgpack_sbuffer));
}

static inline void msgpack_sbuffer_destroy(msgpack_sbuffer* sbuf)
{
    free(sbuf->data);
}

static inline msgpack_sbuffer* msgpack_sbuffer_new(void)
{
    return (msgpack_sbuffer*)calloc(1, sizeof(msgpack_sbuffer));
}

static inline void msgpack_sbuffer_free(msgpack_sbuffer* sbuf)
{
    if(sbuf == 
# 50 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/sbuffer.h" 3 4
              ((void *)0)
# 50 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/sbuffer.h"
                  ) { return; }
    msgpack_sbuffer_destroy(sbuf);
    free(sbuf);
}





static inline int msgpack_sbuffer_write(void* data, const char* buf, size_t len)
{
    msgpack_sbuffer* sbuf = (msgpack_sbuffer*)data;

    if(sbuf->alloc - sbuf->size < len) {
        void* tmp;
        size_t nsize = (sbuf->alloc) ?
                sbuf->alloc * 2 : 8192;

        while(nsize < sbuf->size + len) {
            size_t tmp_nsize = nsize * 2;
            if (tmp_nsize <= nsize) {
                nsize = sbuf->size + len;
                break;
            }
            nsize = tmp_nsize;
        }

        tmp = realloc(sbuf->data, nsize);
        if(!tmp) { return -1; }

        sbuf->data = (char*)tmp;
        sbuf->alloc = nsize;
    }

    memcpy(sbuf->data + sbuf->size, buf, len);
    sbuf->size += len;
    return 0;
}

static inline char* msgpack_sbuffer_release(msgpack_sbuffer* sbuf)
{
    char* tmp = sbuf->data;
    sbuf->size = 0;
    sbuf->data = 
# 93 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/sbuffer.h" 3 4
                ((void *)0)
# 93 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/sbuffer.h"
                    ;
    sbuf->alloc = 0;
    return tmp;
}

static inline void msgpack_sbuffer_clear(msgpack_sbuffer* sbuf)
{
    sbuf->size = 0;
}
# 22 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/vrefbuffer.h" 1
# 17 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/vrefbuffer.h"
# 1 "/usr/include/x86_64-linux-gnu/sys/uio.h" 1 3 4
# 31 "/usr/include/x86_64-linux-gnu/sys/uio.h" 3 4

# 41 "/usr/include/x86_64-linux-gnu/sys/uio.h" 3 4

# 41 "/usr/include/x86_64-linux-gnu/sys/uio.h" 3 4
extern ssize_t readv (int __fd, const struct iovec *__iovec, int __count)
  ;
# 52 "/usr/include/x86_64-linux-gnu/sys/uio.h" 3 4
extern ssize_t writev (int __fd, const struct iovec *__iovec, int __count)
  ;
# 67 "/usr/include/x86_64-linux-gnu/sys/uio.h" 3 4
extern ssize_t preadv (int __fd, const struct iovec *__iovec, int __count,
         __off_t __offset) ;
# 79 "/usr/include/x86_64-linux-gnu/sys/uio.h" 3 4
extern ssize_t pwritev (int __fd, const struct iovec *__iovec, int __count,
   __off_t __offset) ;
# 106 "/usr/include/x86_64-linux-gnu/sys/uio.h" 3 4
extern ssize_t preadv64 (int __fd, const struct iovec *__iovec, int __count,
    __off64_t __offset) ;
# 118 "/usr/include/x86_64-linux-gnu/sys/uio.h" 3 4
extern ssize_t pwritev64 (int __fd, const struct iovec *__iovec, int __count,
     __off64_t __offset) ;







extern ssize_t preadv2 (int __fp, const struct iovec *__iovec, int __count,
   __off_t __offset, int ___flags) ;


extern ssize_t pwritev2 (int __fd, const struct iovec *__iodev, int __count,
    __off_t __offset, int __flags) ;
# 152 "/usr/include/x86_64-linux-gnu/sys/uio.h" 3 4
extern ssize_t preadv64v2 (int __fp, const struct iovec *__iovec,
      int __count, __off64_t __offset,
      int ___flags) ;


extern ssize_t pwritev64v2 (int __fd, const struct iovec *__iodev,
       int __count, __off64_t __offset,
       int __flags) ;








# 1 "/usr/include/x86_64-linux-gnu/bits/uio-ext.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/uio-ext.h" 3 4



extern ssize_t process_vm_readv (pid_t __pid, const struct iovec *__lvec,
     unsigned long int __liovcnt,
     const struct iovec *__rvec,
     unsigned long int __riovcnt,
     unsigned long int __flags)
  __attribute__ ((__nothrow__ , __leaf__));


extern ssize_t process_vm_writev (pid_t __pid, const struct iovec *__lvec,
      unsigned long int __liovcnt,
      const struct iovec *__rvec,
      unsigned long int __riovcnt,
      unsigned long int __flags)
  __attribute__ ((__nothrow__ , __leaf__));








# 169 "/usr/include/x86_64-linux-gnu/sys/uio.h" 2 3 4
# 18 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/vrefbuffer.h" 2
# 36 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/vrefbuffer.h"

# 36 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/vrefbuffer.h"
struct msgpack_vrefbuffer_chunk;
typedef struct msgpack_vrefbuffer_chunk msgpack_vrefbuffer_chunk;

typedef struct msgpack_vrefbuffer_inner_buffer {
    size_t free;
    char* ptr;
    msgpack_vrefbuffer_chunk* head;
} msgpack_vrefbuffer_inner_buffer;

typedef struct msgpack_vrefbuffer {
    struct iovec* tail;
    struct iovec* end;
    struct iovec* array;

    size_t chunk_size;
    size_t ref_size;

    msgpack_vrefbuffer_inner_buffer inner_buffer;
} msgpack_vrefbuffer;
# 65 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/vrefbuffer.h"


# 66 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/vrefbuffer.h" 3 4
_Bool 
# 66 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/vrefbuffer.h"
    msgpack_vrefbuffer_init(msgpack_vrefbuffer* vbuf,
        size_t ref_size, size_t chunk_size);

void msgpack_vrefbuffer_destroy(msgpack_vrefbuffer* vbuf);

static inline msgpack_vrefbuffer* msgpack_vrefbuffer_new(size_t ref_size, size_t chunk_size);
static inline void msgpack_vrefbuffer_free(msgpack_vrefbuffer* vbuf);

static inline int msgpack_vrefbuffer_write(void* data, const char* buf, size_t len);

static inline const struct iovec* msgpack_vrefbuffer_vec(const msgpack_vrefbuffer* vref);
static inline size_t msgpack_vrefbuffer_veclen(const msgpack_vrefbuffer* vref);


int msgpack_vrefbuffer_append_copy(msgpack_vrefbuffer* vbuf,
        const char* buf, size_t len);


int msgpack_vrefbuffer_append_ref(msgpack_vrefbuffer* vbuf,
        const char* buf, size_t len);


int msgpack_vrefbuffer_migrate(msgpack_vrefbuffer* vbuf, msgpack_vrefbuffer* to);


void msgpack_vrefbuffer_clear(msgpack_vrefbuffer* vref);




static inline msgpack_vrefbuffer* msgpack_vrefbuffer_new(size_t ref_size, size_t chunk_size)
{
    msgpack_vrefbuffer* vbuf = (msgpack_vrefbuffer*)malloc(sizeof(msgpack_vrefbuffer));
    if (vbuf == 
# 99 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/vrefbuffer.h" 3 4
               ((void *)0)
# 99 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/vrefbuffer.h"
                   ) return 
# 99 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/vrefbuffer.h" 3 4
                            ((void *)0)
# 99 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/vrefbuffer.h"
                                ;
    if(!msgpack_vrefbuffer_init(vbuf, ref_size, chunk_size)) {
        free(vbuf);
        return 
# 102 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/vrefbuffer.h" 3 4
              ((void *)0)
# 102 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/vrefbuffer.h"
                  ;
    }
    return vbuf;
}

static inline void msgpack_vrefbuffer_free(msgpack_vrefbuffer* vbuf)
{
    if(vbuf == 
# 109 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/vrefbuffer.h" 3 4
              ((void *)0)
# 109 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/vrefbuffer.h"
                  ) { return; }
    msgpack_vrefbuffer_destroy(vbuf);
    free(vbuf);
}

static inline int msgpack_vrefbuffer_write(void* data, const char* buf, size_t len)
{
    msgpack_vrefbuffer* vbuf = (msgpack_vrefbuffer*)data;

    if(len < vbuf->ref_size) {
        return msgpack_vrefbuffer_append_copy(vbuf, buf, len);
    } else {
        return msgpack_vrefbuffer_append_ref(vbuf, buf, len);
    }
}

static inline const struct iovec* msgpack_vrefbuffer_vec(const msgpack_vrefbuffer* vref)
{
    return vref->array;
}

static inline size_t msgpack_vrefbuffer_veclen(const msgpack_vrefbuffer* vref)
{
    return (size_t)(vref->tail - vref->array);
}
# 23 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/version.h" 1
# 17 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/version.h"

const char* msgpack_version(void);

int msgpack_version_major(void);

int msgpack_version_minor(void);

int msgpack_version_revision(void);

# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/version_master.h" 1
# 27 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack/version.h" 2
# 24 "/home/toto/.env/encours/neovim/.deps/usr/include/msgpack.h" 2
# 7 "/home/toto/.env/encours/neovim/src/nvim/msgpack_rpc/channel_defs.h" 2






typedef struct Channel Channel;

typedef struct {
  uint32_t request_id;
  
# 17 "/home/toto/.env/encours/neovim/src/nvim/msgpack_rpc/channel_defs.h" 3 4
 _Bool 
# 17 "/home/toto/.env/encours/neovim/src/nvim/msgpack_rpc/channel_defs.h"
      returned, errored;
  Object result;
} ChannelCallFrame;

typedef struct {
  MessageType type;
  Channel *channel;
  MsgpackRpcRequestHandler handler;
  Array args;
  uint32_t request_id;
} RequestEvent;

typedef struct {
  Map_cstr_t_ptr_t *subscribed_events;
  
# 31 "/home/toto/.env/encours/neovim/src/nvim/msgpack_rpc/channel_defs.h" 3 4
 _Bool 
# 31 "/home/toto/.env/encours/neovim/src/nvim/msgpack_rpc/channel_defs.h"
      closed;
  msgpack_unpacker *unpacker;
  uint32_t next_request_id;
  struct { size_t size; size_t capacity; ChannelCallFrame * *items; } call_stack;
  Dictionary info;
} RpcState;
# 11 "/home/toto/.env/encours/neovim/src/nvim/channel.h" 2




typedef enum {
  kChannelStreamProc,
  kChannelStreamSocket,
  kChannelStreamStdio,
  kChannelStreamStderr,
  kChannelStreamInternal
} ChannelStreamType;

typedef enum {
  kChannelPartStdin,
  kChannelPartStdout,
  kChannelPartStderr,
  kChannelPartRpc,
  kChannelPartAll
} ChannelPart;


typedef struct {
  Stream in;
  Stream out;
} StdioPair;

typedef struct {
  
# 38 "/home/toto/.env/encours/neovim/src/nvim/channel.h" 3 4
 _Bool 
# 38 "/home/toto/.env/encours/neovim/src/nvim/channel.h"
      closed;
} StderrState;

typedef struct {
  Callback cb;
  dict_T *self;
  garray_T buffer;
  
# 45 "/home/toto/.env/encours/neovim/src/nvim/channel.h" 3 4
 _Bool 
# 45 "/home/toto/.env/encours/neovim/src/nvim/channel.h"
      eof;
  
# 46 "/home/toto/.env/encours/neovim/src/nvim/channel.h" 3 4
 _Bool 
# 46 "/home/toto/.env/encours/neovim/src/nvim/channel.h"
      buffered;
  const char *type;
} CallbackReader;






static inline 
# 55 "/home/toto/.env/encours/neovim/src/nvim/channel.h" 3 4
             _Bool 
# 55 "/home/toto/.env/encours/neovim/src/nvim/channel.h"
                  callback_reader_set(CallbackReader reader)
{
  return reader.cb.type != kCallbackNone || reader.self;
}

struct Channel {
  uint64_t id;
  size_t refcount;
  MultiQueue *events;

  ChannelStreamType streamtype;
  union {
    Process proc;
    LibuvProcess uv;
    PtyProcess pty;
    Stream socket;
    StdioPair stdio;
    StderrState err;
  } stream;

  
# 75 "/home/toto/.env/encours/neovim/src/nvim/channel.h" 3 4
 _Bool 
# 75 "/home/toto/.env/encours/neovim/src/nvim/channel.h"
      is_rpc;
  RpcState rpc;
  Terminal *term;

  CallbackReader on_data;
  CallbackReader on_stderr;
  Callback on_exit;
  int exit_status;

  
# 84 "/home/toto/.env/encours/neovim/src/nvim/channel.h" 3 4
 _Bool 
# 84 "/home/toto/.env/encours/neovim/src/nvim/channel.h"
      callback_busy;
  
# 85 "/home/toto/.env/encours/neovim/src/nvim/channel.h" 3 4
 _Bool 
# 85 "/home/toto/.env/encours/neovim/src/nvim/channel.h"
      callback_scheduled;
};

extern Map_uint64_t_ptr_t *channels ;






static inline Channel *find_channel(uint64_t id)
{
  return map_uint64_t_ptr_t_get(channels, id);
}

static inline Stream *channel_instream(Channel *chan)
  FUNC_ATTR_NONNULL_ALL
{
  switch (chan->streamtype) {
    case kChannelStreamProc:
      return &chan->stream.proc.in;

    case kChannelStreamSocket:
      return &chan->stream.socket;

    case kChannelStreamStdio:
      return &chan->stream.stdio.out;

    case kChannelStreamInternal:
    case kChannelStreamStderr:
      abort();
  }
  abort();
}

static inline Stream *channel_outstream(Channel *chan)
  FUNC_ATTR_NONNULL_ALL
{
  switch (chan->streamtype) {
    case kChannelStreamProc:
      return &chan->stream.proc.out;

    case kChannelStreamSocket:
      return &chan->stream.socket;

    case kChannelStreamStdio:
      return &chan->stream.stdio.in;

    case kChannelStreamInternal:
    case kChannelStreamStderr:
      abort();
  }
  abort();
}
# 6 "/home/toto/.env/encours/neovim/src/nvim/eval.h" 2
# 1 "/home/toto/.env/encours/neovim/src/nvim/eval/funcs.h" 1






typedef void (*FunPtr)(void);


typedef void (*VimLFunc)(typval_T *args, typval_T *rvar, FunPtr data);


typedef struct fst {
  char *name;
  uint8_t min_argc;
  uint8_t max_argc;
  VimLFunc func;
  FunPtr data;
} VimLFuncDef;
# 7 "/home/toto/.env/encours/neovim/src/nvim/eval.h" 2
# 1 "/home/toto/.env/encours/neovim/src/nvim/event/time.h" 1







typedef struct time_watcher TimeWatcher;
typedef void (*time_cb)(TimeWatcher *watcher, void *data);

struct time_watcher {
  uv_timer_t uv;
  void *data;
  time_cb cb, close_cb;
  MultiQueue *events;
  
# 16 "/home/toto/.env/encours/neovim/src/nvim/event/time.h" 3 4
 _Bool 
# 16 "/home/toto/.env/encours/neovim/src/nvim/event/time.h"
      blockable;
};
# 8 "/home/toto/.env/encours/neovim/src/nvim/eval.h" 2

# 1 "/home/toto/.env/encours/neovim/src/nvim/os/fileio.h" 1




# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 6 "/home/toto/.env/encours/neovim/src/nvim/os/fileio.h" 2

# 1 "/home/toto/.env/encours/neovim/src/nvim/func_attr.h" 1
# 8 "/home/toto/.env/encours/neovim/src/nvim/os/fileio.h" 2



typedef struct {
  int fd;
  int _error;
  RBuffer *rv;
  
# 15 "/home/toto/.env/encours/neovim/src/nvim/os/fileio.h" 3 4
 _Bool 
# 15 "/home/toto/.env/encours/neovim/src/nvim/os/fileio.h"
      wr;
  
# 16 "/home/toto/.env/encours/neovim/src/nvim/os/fileio.h" 3 4
 _Bool 
# 16 "/home/toto/.env/encours/neovim/src/nvim/os/fileio.h"
      eof;
  
# 17 "/home/toto/.env/encours/neovim/src/nvim/os/fileio.h" 3 4
 _Bool 
# 17 "/home/toto/.env/encours/neovim/src/nvim/os/fileio.h"
      non_blocking;
} FileDescriptor;


typedef enum {
  kFileReadOnly = 1,
  kFileCreate = 2,

  kFileWriteOnly = 4,

  kFileNoSymlink = 8,
  kFileCreateOnly = 16,


  kFileTruncate = 32,


  kFileAppend = 64,

  kFileNonBlocking = 128,

} FileOpenFlags;

static inline 
# 40 "/home/toto/.env/encours/neovim/src/nvim/os/fileio.h" 3 4
             _Bool 
# 40 "/home/toto/.env/encours/neovim/src/nvim/os/fileio.h"
                  file_eof(const FileDescriptor *const fp)
  __attribute__ ((pure)) __attribute__((warn_unused_result)) __attribute__((nonnull));







static inline 
# 49 "/home/toto/.env/encours/neovim/src/nvim/os/fileio.h" 3 4
             _Bool 
# 49 "/home/toto/.env/encours/neovim/src/nvim/os/fileio.h"
                  file_eof(const FileDescriptor *const fp)
{
  return fp->eof && rbuffer_size(fp->rv) == 0;
}

static inline int file_fd(const FileDescriptor *const fp)
  __attribute__ ((pure)) __attribute__((warn_unused_result)) __attribute__((nonnull));






static inline int file_fd(const FileDescriptor *const fp)
{
  return fp->fd;
}

enum {



  kRWBufferSize = 1024
};
# 10 "/home/toto/.env/encours/neovim/src/nvim/eval.h" 2
# 1 "/home/toto/.env/encours/neovim/src/nvim/os/stdpaths_defs.h" 1




typedef enum {
  kXDGNone = -1,
  kXDGConfigHome,
  kXDGDataHome,
  kXDGCacheHome,
  kXDGRuntimeDir,
  kXDGConfigDirs,
  kXDGDataDirs,
} XDGVarType;
# 11 "/home/toto/.env/encours/neovim/src/nvim/eval.h" 2





extern hashtab_T func_hashtab;


extern ufunc_T dumuf;
# 51 "/home/toto/.env/encours/neovim/src/nvim/eval.h"
typedef struct lval_S {
    const char *ll_name;
    size_t ll_name_len;
    char *ll_exp_name;
    typval_T *ll_tv;

    listitem_T *ll_li;
    list_T *ll_list;
    int ll_range;
    long ll_n1;
    long ll_n2;
    int ll_empty2;
    dict_T *ll_dict;
    dictitem_T *ll_di;
    char_u *ll_newkey;
} lval_T;


typedef enum {
  VAR_FLAVOUR_DEFAULT = 1,
  VAR_FLAVOUR_SESSION = 2,
  VAR_FLAVOUR_SHADA = 4
} var_flavour_T;


typedef enum {
    VV_COUNT,
    VV_COUNT1,
    VV_PREVCOUNT,
    VV_ERRMSG,
    VV_WARNINGMSG,
    VV_STATUSMSG,
    VV_SHELL_ERROR,
    VV_THIS_SESSION,
    VV_VERSION,
    VV_LNUM,
    VV_TERMRESPONSE,
    VV_FNAME,
    VV_LANG,
    VV_LC_TIME,
    VV_CTYPE,
    VV_CC_FROM,
    VV_CC_TO,
    VV_FNAME_IN,
    VV_FNAME_OUT,
    VV_FNAME_NEW,
    VV_FNAME_DIFF,
    VV_CMDARG,
    VV_FOLDSTART,
    VV_FOLDEND,
    VV_FOLDDASHES,
    VV_FOLDLEVEL,
    VV_PROGNAME,
    VV_SEND_SERVER,
    VV_DYING,
    VV_EXCEPTION,
    VV_THROWPOINT,
    VV_STDERR,
    VV_REG,
    VV_CMDBANG,
    VV_INSERTMODE,
    VV_VAL,
    VV_KEY,
    VV_PROFILING,
    VV_FCS_REASON,
    VV_FCS_CHOICE,
    VV_BEVAL_BUFNR,
    VV_BEVAL_WINNR,
    VV_BEVAL_WINID,
    VV_BEVAL_LNUM,
    VV_BEVAL_COL,
    VV_BEVAL_TEXT,
    VV_SCROLLSTART,
    VV_SWAPNAME,
    VV_SWAPCHOICE,
    VV_SWAPCOMMAND,
    VV_CHAR,
    VV_MOUSE_WIN,
    VV_MOUSE_WINID,
    VV_MOUSE_LNUM,
    VV_MOUSE_COL,
    VV_OP,
    VV_SEARCHFORWARD,
    VV_HLSEARCH,
    VV_OLDFILES,
    VV_WINDOWID,
    VV_PROGPATH,
    VV_COMPLETED_ITEM,
    VV_OPTION_NEW,
    VV_OPTION_OLD,
    VV_OPTION_TYPE,
    VV_ERRORS,
    VV_MSGPACK_TYPES,
    VV_EVENT,
    VV_FALSE,
    VV_TRUE,
    VV_NULL,
    VV__NULL_LIST,
    VV__NULL_DICT,
    VV_VIM_DID_ENTER,
    VV_TESTING,
    VV_TYPE_NUMBER,
    VV_TYPE_STRING,
    VV_TYPE_FUNC,
    VV_TYPE_LIST,
    VV_TYPE_DICT,
    VV_TYPE_FLOAT,
    VV_TYPE_BOOL,
    VV_ECHOSPACE,
    VV_EXITING,
    VV_LUA,
    VV_ARGV,
} VimVarIndex;


typedef enum {
  kMPNil,
  kMPBoolean,
  kMPInteger,
  kMPFloat,
  kMPString,
  kMPBinary,
  kMPArray,
  kMPMap,
  kMPExt,

} MessagePackType;


extern const list_T *eval_msgpack_type_lists[kMPExt + 1];




typedef enum {
  TFN_INT = 1,
  TFN_QUIET = 2,
  TFN_NO_AUTOLOAD = 4,
  TFN_NO_DEREF = 8,
  TFN_READ_ONLY = 16,
} TransFunctionNameFlags;


typedef enum {
  GLV_QUIET = TFN_QUIET,
  GLV_NO_AUTOLOAD = TFN_NO_AUTOLOAD,
  GLV_READ_ONLY = TFN_READ_ONLY,

} GetLvalFlags;






typedef struct {
  TimeWatcher tw;
  int timer_id;
  int repeat_count;
  int refcount;
  int emsg_count;
  long timeout;
  
# 213 "/home/toto/.env/encours/neovim/src/nvim/eval.h" 3 4
 _Bool 
# 213 "/home/toto/.env/encours/neovim/src/nvim/eval.h"
      stopped;
  
# 214 "/home/toto/.env/encours/neovim/src/nvim/eval.h" 3 4
 _Bool 
# 214 "/home/toto/.env/encours/neovim/src/nvim/eval.h"
      paused;
  Callback callback;
} timer_T;


typedef enum
{
  ASSERT_EQUAL,
  ASSERT_NOTEQUAL,
  ASSERT_MATCH,
  ASSERT_NOTMATCH,
  ASSERT_INRANGE,
  ASSERT_OTHER,
} assert_type_T;


typedef enum {
  kDictListKeys,
  kDictListValues,
  kDictListItems,
} DictListType;


extern 
# 237 "/home/toto/.env/encours/neovim/src/nvim/eval.h" 3 4
      _Bool 
# 237 "/home/toto/.env/encours/neovim/src/nvim/eval.h"
           *eval_lavars_used;
# 11 "/home/toto/.env/encours/neovim/src/nvim/buffer.h" 2



enum getf_values {
  GETF_SETMARK = 0x01,
  GETF_ALT = 0x02,
  GETF_SWITCH = 0x04,
};


enum getf_retvalues {
  GETFILE_ERROR = 1,
  GETFILE_NOT_WRITTEN = 2,
  GETFILE_SAME_FILE = 0,
  GETFILE_OPEN_OTHER = -1,
  GETFILE_UNUSED = 8
};


enum bln_values {
  BLN_CURBUF = 1,
  BLN_LISTED = 2,
  BLN_DUMMY = 4,
  BLN_NEW = 8,
  BLN_NOOPT = 16,
};


enum dobuf_action_values {
  DOBUF_GOTO = 0,
  DOBUF_SPLIT = 1,
  DOBUF_UNLOAD = 2,
  DOBUF_DEL = 3,
  DOBUF_WIPE = 4,
};


enum dobuf_start_values {
  DOBUF_CURRENT = 0,
  DOBUF_FIRST = 1,
  DOBUF_LAST = 2,
  DOBUF_MOD = 3,
};


enum bfa_values {
  BFA_DEL = 1,
  BFA_WIPE = 2,
  BFA_KEEP_UNDO = 4,
};





static inline void buf_set_changedtick(buf_T *const buf,
                                       const varnumber_T changedtick)
  __attribute__((nonnull)) __attribute__((always_inline));





static inline void buf_set_changedtick(buf_T *const buf,
                                       const varnumber_T changedtick)
{
  typval_T old_val = buf->changedtick_di.di_tv;


  dictitem_T *const changedtick_di = tv_dict_find(
      buf->b_vars, ("changedtick"), (sizeof("changedtick") - 1));
  
# 82 "/home/toto/.env/encours/neovim/src/nvim/buffer.h" 3 4
 ((void) sizeof ((
# 82 "/home/toto/.env/encours/neovim/src/nvim/buffer.h"
 changedtick_di != 
# 82 "/home/toto/.env/encours/neovim/src/nvim/buffer.h" 3 4
 ((void *)0)) ? 1 : 0), __extension__ ({ if (
# 82 "/home/toto/.env/encours/neovim/src/nvim/buffer.h"
 changedtick_di != 
# 82 "/home/toto/.env/encours/neovim/src/nvim/buffer.h" 3 4
 ((void *)0)) ; else __assert_fail (
# 82 "/home/toto/.env/encours/neovim/src/nvim/buffer.h"
 "changedtick_di != NULL"
# 82 "/home/toto/.env/encours/neovim/src/nvim/buffer.h" 3 4
 , "/home/toto/.env/encours/neovim/src/nvim/buffer.h", 82, __extension__ __PRETTY_FUNCTION__); }))
# 82 "/home/toto/.env/encours/neovim/src/nvim/buffer.h"
                               ;
  
# 83 "/home/toto/.env/encours/neovim/src/nvim/buffer.h" 3 4
 ((void) sizeof ((
# 83 "/home/toto/.env/encours/neovim/src/nvim/buffer.h"
 changedtick_di->di_tv.v_type == VAR_NUMBER
# 83 "/home/toto/.env/encours/neovim/src/nvim/buffer.h" 3 4
 ) ? 1 : 0), __extension__ ({ if (
# 83 "/home/toto/.env/encours/neovim/src/nvim/buffer.h"
 changedtick_di->di_tv.v_type == VAR_NUMBER
# 83 "/home/toto/.env/encours/neovim/src/nvim/buffer.h" 3 4
 ) ; else __assert_fail (
# 83 "/home/toto/.env/encours/neovim/src/nvim/buffer.h"
 "changedtick_di->di_tv.v_type == VAR_NUMBER"
# 83 "/home/toto/.env/encours/neovim/src/nvim/buffer.h" 3 4
 , "/home/toto/.env/encours/neovim/src/nvim/buffer.h", 83, __extension__ __PRETTY_FUNCTION__); }))
# 83 "/home/toto/.env/encours/neovim/src/nvim/buffer.h"
                                                   ;
  
# 84 "/home/toto/.env/encours/neovim/src/nvim/buffer.h" 3 4
 ((void) sizeof ((
# 84 "/home/toto/.env/encours/neovim/src/nvim/buffer.h"
 changedtick_di->di_tv.v_lock == VAR_FIXED
# 84 "/home/toto/.env/encours/neovim/src/nvim/buffer.h" 3 4
 ) ? 1 : 0), __extension__ ({ if (
# 84 "/home/toto/.env/encours/neovim/src/nvim/buffer.h"
 changedtick_di->di_tv.v_lock == VAR_FIXED
# 84 "/home/toto/.env/encours/neovim/src/nvim/buffer.h" 3 4
 ) ; else __assert_fail (
# 84 "/home/toto/.env/encours/neovim/src/nvim/buffer.h"
 "changedtick_di->di_tv.v_lock == VAR_FIXED"
# 84 "/home/toto/.env/encours/neovim/src/nvim/buffer.h" 3 4
 , "/home/toto/.env/encours/neovim/src/nvim/buffer.h", 84, __extension__ __PRETTY_FUNCTION__); }))
# 84 "/home/toto/.env/encours/neovim/src/nvim/buffer.h"
                                                  ;


  
# 87 "/home/toto/.env/encours/neovim/src/nvim/buffer.h" 3 4
 ((void) sizeof ((
# 87 "/home/toto/.env/encours/neovim/src/nvim/buffer.h"
 changedtick_di->di_flags == (DI_FLAGS_RO|DI_FLAGS_FIX)
# 87 "/home/toto/.env/encours/neovim/src/nvim/buffer.h" 3 4
 ) ? 1 : 0), __extension__ ({ if (
# 87 "/home/toto/.env/encours/neovim/src/nvim/buffer.h"
 changedtick_di->di_flags == (DI_FLAGS_RO|DI_FLAGS_FIX)
# 87 "/home/toto/.env/encours/neovim/src/nvim/buffer.h" 3 4
 ) ; else __assert_fail (
# 87 "/home/toto/.env/encours/neovim/src/nvim/buffer.h"
 "changedtick_di->di_flags == (DI_FLAGS_RO|DI_FLAGS_FIX)"
# 87 "/home/toto/.env/encours/neovim/src/nvim/buffer.h" 3 4
 , "/home/toto/.env/encours/neovim/src/nvim/buffer.h", 87, __extension__ __PRETTY_FUNCTION__); }))
# 87 "/home/toto/.env/encours/neovim/src/nvim/buffer.h"
                                                               ;

  
# 89 "/home/toto/.env/encours/neovim/src/nvim/buffer.h" 3 4
 ((void) sizeof ((
# 89 "/home/toto/.env/encours/neovim/src/nvim/buffer.h"
 changedtick_di == (dictitem_T *)&buf->changedtick_di
# 89 "/home/toto/.env/encours/neovim/src/nvim/buffer.h" 3 4
 ) ? 1 : 0), __extension__ ({ if (
# 89 "/home/toto/.env/encours/neovim/src/nvim/buffer.h"
 changedtick_di == (dictitem_T *)&buf->changedtick_di
# 89 "/home/toto/.env/encours/neovim/src/nvim/buffer.h" 3 4
 ) ; else __assert_fail (
# 89 "/home/toto/.env/encours/neovim/src/nvim/buffer.h"
 "changedtick_di == (dictitem_T *)&buf->changedtick_di"
# 89 "/home/toto/.env/encours/neovim/src/nvim/buffer.h" 3 4
 , "/home/toto/.env/encours/neovim/src/nvim/buffer.h", 89, __extension__ __PRETTY_FUNCTION__); }))
# 89 "/home/toto/.env/encours/neovim/src/nvim/buffer.h"
                                                             ;

  buf->changedtick_di.di_tv.vval.v_number = changedtick;

  if (tv_dict_is_watched(buf->b_vars)) {
    tv_dict_watcher_notify(buf->b_vars,
                           (char *)buf->changedtick_di.di_key,
                           &buf->changedtick_di.di_tv,
                           &old_val);
  }
}

static inline varnumber_T buf_get_changedtick(const buf_T *const buf)
  __attribute__((nonnull)) __attribute__((always_inline)) __attribute__ ((pure))
  __attribute__((warn_unused_result));






static inline varnumber_T buf_get_changedtick(const buf_T *const buf)
{
  return buf->changedtick_di.di_tv.vval.v_number;
}

static inline void buf_inc_changedtick(buf_T *const buf)
  __attribute__((nonnull)) __attribute__((always_inline));






static inline void buf_inc_changedtick(buf_T *const buf)
{
  buf_set_changedtick(buf, buf_get_changedtick(buf) + 1);
}
# 74 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 2
# 1 "/home/toto/.env/encours/neovim/src/nvim/charset.h" 1
# 21 "/home/toto/.env/encours/neovim/src/nvim/charset.h"
typedef enum {
  STR2NR_DEC = 0,
  STR2NR_BIN = (1 << 0),
  STR2NR_OCT = (1 << 1),
  STR2NR_HEX = (1 << 2),




  STR2NR_FORCE = (1 << 3),

  STR2NR_ALL = STR2NR_BIN | STR2NR_OCT | STR2NR_HEX,
} ChStr2NrFlags;





static inline 
# 39 "/home/toto/.env/encours/neovim/src/nvim/charset.h" 3 4
             _Bool 
# 39 "/home/toto/.env/encours/neovim/src/nvim/charset.h"
                  vim_isbreak(int c)
  __attribute__((const))
  __attribute__((always_inline));



static inline 
# 45 "/home/toto/.env/encours/neovim/src/nvim/charset.h" 3 4
             _Bool 
# 45 "/home/toto/.env/encours/neovim/src/nvim/charset.h"
                  vim_isbreak(int c)
{
  return breakat_flags[(char_u)c];
}
# 75 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 2
# 1 "/home/toto/.env/encours/neovim/src/nvim/cursor.h" 1
# 76 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 2
# 1 "/home/toto/.env/encours/neovim/src/nvim/cursor_shape.h" 1
# 9 "/home/toto/.env/encours/neovim/src/nvim/cursor_shape.h"
typedef enum {
SHAPE_IDX_N = 0,
SHAPE_IDX_V = 1,
SHAPE_IDX_I = 2,
SHAPE_IDX_R = 3,
SHAPE_IDX_C = 4,
SHAPE_IDX_CI = 5,
SHAPE_IDX_CR = 6,
SHAPE_IDX_O = 7,
SHAPE_IDX_VE = 8,
SHAPE_IDX_CLINE = 9,
SHAPE_IDX_STATUS = 10,
SHAPE_IDX_SDRAG = 11,
SHAPE_IDX_VSEP = 12,
SHAPE_IDX_VDRAG = 13,
SHAPE_IDX_MORE = 14,
SHAPE_IDX_MOREL = 15,
SHAPE_IDX_SM = 16,
SHAPE_IDX_COUNT = 17
} ModeShape;

typedef enum {
SHAPE_BLOCK = 0,
SHAPE_HOR = 1,
SHAPE_VER = 2
} CursorShape;







typedef struct cursor_entry {
  char *full_name;
  CursorShape shape;
  int mshape;
  int percentage;
  long blinkwait;
  long blinkon;
  long blinkoff;
  int id;
  int id_lm;
  char *name;
  char used_for;
} cursorentry_T;

extern cursorentry_T shape_table[SHAPE_IDX_COUNT];
# 77 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 2
# 1 "/home/toto/.env/encours/neovim/src/nvim/diff.h" 1







extern int diff_context ;
extern int diff_foldcolumn ;
extern 
# 10 "/home/toto/.env/encours/neovim/src/nvim/diff.h" 3 4
      _Bool 
# 10 "/home/toto/.env/encours/neovim/src/nvim/diff.h"
           diff_need_scrollbind ;

extern 
# 12 "/home/toto/.env/encours/neovim/src/nvim/diff.h" 3 4
      _Bool 
# 12 "/home/toto/.env/encours/neovim/src/nvim/diff.h"
           need_diff_redraw ;
# 78 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 2

# 1 "/home/toto/.env/encours/neovim/src/nvim/ex_cmds.h" 1
# 27 "/home/toto/.env/encours/neovim/src/nvim/ex_cmds.h"
typedef struct {
  char *sub;
  Timestamp timestamp;
  list_T *additional_elements;
} SubReplacementString;
# 80 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 2
# 1 "/home/toto/.env/encours/neovim/src/nvim/ex_cmds2.h" 1





# 1 "/home/toto/.env/encours/neovim/src/nvim/ex_docmd.h" 1
# 25 "/home/toto/.env/encours/neovim/src/nvim/ex_docmd.h"
typedef struct {
  int save_msg_scroll;
  int save_restart_edit;
  int save_msg_didout;
  int save_State;
  int save_insertmode;
  
# 31 "/home/toto/.env/encours/neovim/src/nvim/ex_docmd.h" 3 4
 _Bool 
# 31 "/home/toto/.env/encours/neovim/src/nvim/ex_docmd.h"
      save_finish_op;
  long save_opcount;
  int save_reg_executing;
  tasave_T tabuf;
} save_state_T;
# 7 "/home/toto/.env/encours/neovim/src/nvim/ex_cmds2.h" 2

typedef void (*DoInRuntimepathCB)(char_u *, void *);
# 81 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 2
# 1 "/home/toto/.env/encours/neovim/src/nvim/ex_getln.h" 1
# 37 "/home/toto/.env/encours/neovim/src/nvim/ex_getln.h"
typedef enum {
  HIST_DEFAULT = -2,
  HIST_INVALID = -1,
  HIST_CMD = 0,
  HIST_SEARCH,
  HIST_EXPR,
  HIST_INPUT,
  HIST_DEBUG,
} HistoryType;




typedef char_u *(*CompleteListItemGetter)(expand_T *, int);


typedef struct hist_entry {
  int hisnum;
  char_u *hisstr;
  Timestamp timestamp;
  list_T *additional_elements;
} histentry_T;
# 82 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 2
# 1 "/home/toto/.env/encours/neovim/src/nvim/edit.h" 1
# 16 "/home/toto/.env/encours/neovim/src/nvim/edit.h"
typedef enum {
  CP_ORIGINAL_TEXT = 1,
  CP_FREE_FNAME = 2,
  CP_CONT_S_IPOS = 4,
  CP_EQUAL = 8,
  CP_ICASE = 16,
} cp_flags_T;

typedef int (*IndentGetter)(void);
# 83 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 2
# 1 "/home/toto/.env/encours/neovim/src/nvim/fileio.h" 1




# 1 "/home/toto/.env/encours/neovim/src/nvim/os/os.h" 1
# 6 "/home/toto/.env/encours/neovim/src/nvim/fileio.h" 2
# 22 "/home/toto/.env/encours/neovim/src/nvim/fileio.h"
typedef struct {
  buf_T *save_curbuf;
  int use_aucmd_win;
  win_T *save_curwin;
  win_T *save_prevwin;
  win_T *new_curwin;
  bufref_T new_curbuf;
  char_u *globaldir;
} aco_save_T;
# 84 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 2
# 1 "/home/toto/.env/encours/neovim/src/nvim/fold.h" 1
# 15 "/home/toto/.env/encours/neovim/src/nvim/fold.h"
typedef struct foldinfo {
  linenr_T fi_lnum;
  int fi_level;

  int fi_low_level;

} foldinfo_T;
# 85 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 2
# 1 "/home/toto/.env/encours/neovim/src/nvim/indent.h" 1
# 86 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 2
# 1 "/home/toto/.env/encours/neovim/src/nvim/getchar.h" 1
# 13 "/home/toto/.env/encours/neovim/src/nvim/getchar.h"
enum RemapValues {
  REMAP_YES = 0,
  REMAP_NONE = -1,
  REMAP_SCRIPT = -2,
  REMAP_SKIP = -3,
};


typedef enum {
  FLUSH_MINIMAL,
  FLUSH_TYPEAHEAD,
  FLUSH_INPUT
} flush_buffers_T;
# 34 "/home/toto/.env/encours/neovim/src/nvim/getchar.h"
struct map_arguments {
  
# 35 "/home/toto/.env/encours/neovim/src/nvim/getchar.h" 3 4
 _Bool 
# 35 "/home/toto/.env/encours/neovim/src/nvim/getchar.h"
      buffer;
  
# 36 "/home/toto/.env/encours/neovim/src/nvim/getchar.h" 3 4
 _Bool 
# 36 "/home/toto/.env/encours/neovim/src/nvim/getchar.h"
      expr;
  
# 37 "/home/toto/.env/encours/neovim/src/nvim/getchar.h" 3 4
 _Bool 
# 37 "/home/toto/.env/encours/neovim/src/nvim/getchar.h"
      noremap;
  
# 38 "/home/toto/.env/encours/neovim/src/nvim/getchar.h" 3 4
 _Bool 
# 38 "/home/toto/.env/encours/neovim/src/nvim/getchar.h"
      nowait;
  
# 39 "/home/toto/.env/encours/neovim/src/nvim/getchar.h" 3 4
 _Bool 
# 39 "/home/toto/.env/encours/neovim/src/nvim/getchar.h"
      script;
  
# 40 "/home/toto/.env/encours/neovim/src/nvim/getchar.h" 3 4
 _Bool 
# 40 "/home/toto/.env/encours/neovim/src/nvim/getchar.h"
      silent;
  
# 41 "/home/toto/.env/encours/neovim/src/nvim/getchar.h" 3 4
 _Bool 
# 41 "/home/toto/.env/encours/neovim/src/nvim/getchar.h"
      unique;






  char_u lhs[50 + 1];
  size_t lhs_len;

  char_u *rhs;
  size_t rhs_len;
  
# 53 "/home/toto/.env/encours/neovim/src/nvim/getchar.h" 3 4
 _Bool 
# 53 "/home/toto/.env/encours/neovim/src/nvim/getchar.h"
      rhs_is_noop;

  char_u *orig_rhs;
  size_t orig_rhs_len;
};
typedef struct map_arguments MapArguments;





enum { NSCRIPT = 15 };


extern FileDescriptor *scriptin[NSCRIPT];
# 87 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 2
# 1 "/home/toto/.env/encours/neovim/src/nvim/highlight.h" 1






# 1 "/home/toto/.env/encours/neovim/src/nvim/ui.h" 1



# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 5 "/home/toto/.env/encours/neovim/src/nvim/ui.h" 2







typedef enum {
  kUICmdline = 0,
  kUIPopupmenu,
  kUITabline,
  kUIWildmenu,
  kUIMessages,

  kUILinegrid,
  kUIMultigrid,
  kUIHlState,
  kUITermColors,
  kUIFloatDebug,
  kUIExtCount,
} UIExtension;

extern const char *ui_ext_names[]
# 38 "/home/toto/.env/encours/neovim/src/nvim/ui.h"
  ;

typedef struct ui_t UI;

enum {
  kLineFlagWrap = 1,
  kLineFlagInvalid = 2,
};

typedef int LineFlags;

struct ui_t {
  
# 50 "/home/toto/.env/encours/neovim/src/nvim/ui.h" 3 4
 _Bool 
# 50 "/home/toto/.env/encours/neovim/src/nvim/ui.h"
      rgb;
  
# 51 "/home/toto/.env/encours/neovim/src/nvim/ui.h" 3 4
 _Bool 
# 51 "/home/toto/.env/encours/neovim/src/nvim/ui.h"
      override;
  
# 52 "/home/toto/.env/encours/neovim/src/nvim/ui.h" 3 4
 _Bool 
# 52 "/home/toto/.env/encours/neovim/src/nvim/ui.h"
      composed;
  
# 53 "/home/toto/.env/encours/neovim/src/nvim/ui.h" 3 4
 _Bool 
# 53 "/home/toto/.env/encours/neovim/src/nvim/ui.h"
      ui_ext[kUIExtCount];
  int width;
  int height;
  int pum_nlines;
  
# 57 "/home/toto/.env/encours/neovim/src/nvim/ui.h" 3 4
 _Bool 
# 57 "/home/toto/.env/encours/neovim/src/nvim/ui.h"
      pum_pos;
  double pum_row;
  double pum_col;
  double pum_height;
  double pum_width;
  void *data;





  void (*inspect)(UI *ui, Dictionary *info);
};







extern MultiQueue *resize_events;
# 8 "/home/toto/.env/encours/neovim/src/nvim/highlight.h" 2
# 88 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 2

# 1 "/home/toto/.env/encours/neovim/src/nvim/mark.h" 1






# 1 "/home/toto/.env/encours/neovim/src/nvim/func_attr.h" 1
# 8 "/home/toto/.env/encours/neovim/src/nvim/mark.h" 2
# 55 "/home/toto/.env/encours/neovim/src/nvim/mark.h"
static inline int mark_global_index(const char name)
  FUNC_ATTR_CONST
{
  return (((unsigned)(name) >= 'A' && (unsigned)(name) <= 'Z')
          ? (name - 'A')
          : (ascii_isdigit(name)
             ? (('z' - 'a' + 1) + (name - '0'))
             : -1));
}


static inline int mark_local_index(const char name)
  FUNC_ATTR_CONST
{
  return (((unsigned)(name) >= 'a' && (unsigned)(name) <= 'z')
          ? (name - 'a')
          : (name == '"'
             ? ('z' - 'a' + 1)
             : (name == '^'
                ? ('z' - 'a' + 1) + 1
                : (name == '.'
                   ? ('z' - 'a' + 1) + 2
                   : -1))));
}

static inline 
# 80 "/home/toto/.env/encours/neovim/src/nvim/mark.h" 3 4
             _Bool 
# 80 "/home/toto/.env/encours/neovim/src/nvim/mark.h"
                  lt(pos_T, pos_T) __attribute__((const)) __attribute__((always_inline));
static inline 
# 81 "/home/toto/.env/encours/neovim/src/nvim/mark.h" 3 4
             _Bool 
# 81 "/home/toto/.env/encours/neovim/src/nvim/mark.h"
                  equalpos(pos_T, pos_T)
  __attribute__((const)) __attribute__((always_inline));
static inline 
# 83 "/home/toto/.env/encours/neovim/src/nvim/mark.h" 3 4
             _Bool 
# 83 "/home/toto/.env/encours/neovim/src/nvim/mark.h"
                  ltoreq(pos_T, pos_T)
  __attribute__((const)) __attribute__((always_inline));
static inline void clearpos(pos_T *)
  __attribute__((always_inline));


static inline 
# 89 "/home/toto/.env/encours/neovim/src/nvim/mark.h" 3 4
             _Bool 
# 89 "/home/toto/.env/encours/neovim/src/nvim/mark.h"
                  lt(pos_T a, pos_T b)
{
  if (a.lnum != b.lnum) {
    return a.lnum < b.lnum;
  } else if (a.col != b.col) {
    return a.col < b.col;
  } else {
    return a.coladd < b.coladd;
  }
}


static inline 
# 101 "/home/toto/.env/encours/neovim/src/nvim/mark.h" 3 4
             _Bool 
# 101 "/home/toto/.env/encours/neovim/src/nvim/mark.h"
                  equalpos(pos_T a, pos_T b)
{
  return (a.lnum == b.lnum) && (a.col == b.col) && (a.coladd == b.coladd);
}


static inline 
# 107 "/home/toto/.env/encours/neovim/src/nvim/mark.h" 3 4
             _Bool 
# 107 "/home/toto/.env/encours/neovim/src/nvim/mark.h"
                  ltoreq(pos_T a, pos_T b)
{
  return lt(a, b) || equalpos(a, b);
}


static inline void clearpos(pos_T *a)
{
  a->lnum = 0;
  a->col = 0;
  a->coladd = 0;
}
# 90 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 2
# 1 "/home/toto/.env/encours/neovim/src/nvim/extmark.h" 1







extern int extmark_splice_pending ;

typedef struct
{
  uint64_t ns_id;
  uint64_t mark_id;
  int row;
  colnr_T col;
} ExtmarkInfo;

typedef struct { size_t size; size_t capacity; ExtmarkInfo *items; } ExtmarkArray;



typedef struct {
  int start_row;
  colnr_T start_col;
  int oldextent_row;
  colnr_T oldextent_col;
  int newextent_row;
  colnr_T newextent_col;
} ExtmarkSplice;


typedef struct {
  int start_row;
  int start_col;
  int extent_row;
  int extent_col;
  int new_row;
  int new_col;
} ExtmarkMove;


typedef struct {
  uint64_t mark;
  int old_row;
  colnr_T old_col;
  int row;
  colnr_T col;
} ExtmarkSavePos;

typedef enum {
  kExtmarkSplice,
  kExtmarkMove,
  kExtmarkUpdate,
  kExtmarkSavePos,
  kExtmarkClear,
} UndoObjectType;


struct undo_object {
  UndoObjectType type;
  union {
    ExtmarkSplice splice;
    ExtmarkMove move;
    ExtmarkSavePos savepos;
  } data;
};


typedef struct {
  int start_row;
  int start_col;
  int end_row;
  int end_col;
  int attr_id;
  VirtText *virt_text;
} HlRange;

typedef struct {
  MarkTreeIter itr[1];
  struct { size_t size; size_t capacity; HlRange *items; } active;
  int top_row;
  int row;
  int col_until;
  int current;
  VirtText *virt_text;
} DecorationRedrawState;
# 91 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 2

# 1 "/home/toto/.env/encours/neovim/src/nvim/memline.h" 1
# 93 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 2



# 1 "/home/toto/.env/encours/neovim/src/nvim/misc1.h" 1




# 1 "/home/toto/.env/encours/neovim/src/nvim/os/shell.h" 1
# 9 "/home/toto/.env/encours/neovim/src/nvim/os/shell.h"
typedef enum {
  kShellOptFilter = 1,
  kShellOptExpand = 2,
  kShellOptDoOut = 4,
  kShellOptSilent = 8,
  kShellOptRead = 16,
  kShellOptWrite = 32,
  kShellOptHideMess = 64,
} ShellOpts;
# 6 "/home/toto/.env/encours/neovim/src/nvim/misc1.h" 2
# 97 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 2

# 1 "/home/toto/.env/encours/neovim/src/nvim/move.h" 1
# 99 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 2

# 1 "/home/toto/.env/encours/neovim/src/nvim/option.h" 1
# 15 "/home/toto/.env/encours/neovim/src/nvim/option.h"
typedef enum {
  OPT_FREE = 1,
  OPT_GLOBAL = 2,
  OPT_LOCAL = 4,
  OPT_MODELINE = 8,
  OPT_WINONLY = 16,
  OPT_NOWIN = 32,
} OptionFlags;
# 101 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 2
# 1 "/home/toto/.env/encours/neovim/src/nvim/os_unix.h" 1
# 102 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 2

# 1 "/home/toto/.env/encours/neovim/src/nvim/popupmnu.h" 1
# 10 "/home/toto/.env/encours/neovim/src/nvim/popupmnu.h"
typedef struct {
  char_u *pum_text;
  char_u *pum_kind;
  char_u *pum_extra;
  char_u *pum_info;
} pumitem_T;

extern ScreenGrid pum_grid ;
# 104 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 2
# 1 "/home/toto/.env/encours/neovim/src/nvim/quickfix.h" 1
# 105 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 2
# 1 "/home/toto/.env/encours/neovim/src/nvim/regexp.h" 1
# 106 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 2
# 1 "/home/toto/.env/encours/neovim/src/nvim/search.h" 1
# 56 "/home/toto/.env/encours/neovim/src/nvim/search.h"
typedef struct soffset {
  char dir;
  
# 58 "/home/toto/.env/encours/neovim/src/nvim/search.h" 3 4
 _Bool 
# 58 "/home/toto/.env/encours/neovim/src/nvim/search.h"
      line;
  
# 59 "/home/toto/.env/encours/neovim/src/nvim/search.h" 3 4
 _Bool 
# 59 "/home/toto/.env/encours/neovim/src/nvim/search.h"
      end;
  int64_t off;
} SearchOffset;


typedef struct spat {
  char_u *pat;
  
# 66 "/home/toto/.env/encours/neovim/src/nvim/search.h" 3 4
 _Bool 
# 66 "/home/toto/.env/encours/neovim/src/nvim/search.h"
      magic;
  
# 67 "/home/toto/.env/encours/neovim/src/nvim/search.h" 3 4
 _Bool 
# 67 "/home/toto/.env/encours/neovim/src/nvim/search.h"
      no_scs;
  Timestamp timestamp;
  SearchOffset off;
  dict_T *additional_data;
} SearchPattern;


typedef struct {
    linenr_T sa_stop_lnum;
    proftime_T *sa_tm;
    int sa_timed_out;
    int sa_wrapped;
} searchit_arg_T;
# 107 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 2
# 1 "/home/toto/.env/encours/neovim/src/nvim/sign.h" 1
# 108 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 2
# 1 "/home/toto/.env/encours/neovim/src/nvim/spell.h" 1





# 1 "/home/toto/.env/encours/neovim/src/nvim/spell_defs.h" 1
# 21 "/home/toto/.env/encours/neovim/src/nvim/spell_defs.h"
typedef int idx_T;
# 73 "/home/toto/.env/encours/neovim/src/nvim/spell_defs.h"
typedef struct fromto_S {
  char_u *ft_from;
  char_u *ft_to;
} fromto_T;




typedef struct salitem_S {
  char_u *sm_lead;
  int sm_leadlen;
  char_u *sm_oneof;
  char_u *sm_rules;
  char_u *sm_to;
  int *sm_lead_w;
  int *sm_oneof_w;
  int *sm_to_w;
} salitem_T;

typedef int salfirst_T;
# 113 "/home/toto/.env/encours/neovim/src/nvim/spell_defs.h"
typedef struct slang_S slang_T;

struct slang_S {
  slang_T *sl_next;
  char_u *sl_name;
  char_u *sl_fname;
  
# 119 "/home/toto/.env/encours/neovim/src/nvim/spell_defs.h" 3 4
 _Bool 
# 119 "/home/toto/.env/encours/neovim/src/nvim/spell_defs.h"
      sl_add;

  char_u *sl_fbyts;
  idx_T *sl_fidxs;
  char_u *sl_kbyts;
  idx_T *sl_kidxs;
  char_u *sl_pbyts;
  idx_T *sl_pidxs;

  char_u *sl_info;

  char_u sl_regions[8 * 2 + 1];


  char_u *sl_midword;

  hashtab_T sl_wordcount;

  int sl_compmax;
  int sl_compminlen;
  int sl_compsylmax;
  int sl_compoptions;
  garray_T sl_comppat;
  regprog_T *sl_compprog;

  char_u *sl_comprules;
  char_u *sl_compstartflags;
  char_u *sl_compallflags;
  
# 147 "/home/toto/.env/encours/neovim/src/nvim/spell_defs.h" 3 4
 _Bool 
# 147 "/home/toto/.env/encours/neovim/src/nvim/spell_defs.h"
      sl_nobreak;
  char_u *sl_syllable;
  garray_T sl_syl_items;

  int sl_prefixcnt;
  regprog_T **sl_prefprog;

  garray_T sl_rep;
  int16_t sl_rep_first[256];

  garray_T sl_sal;
  salfirst_T sl_sal_first[256];

  
# 160 "/home/toto/.env/encours/neovim/src/nvim/spell_defs.h" 3 4
 _Bool 
# 160 "/home/toto/.env/encours/neovim/src/nvim/spell_defs.h"
      sl_followup;
  
# 161 "/home/toto/.env/encours/neovim/src/nvim/spell_defs.h" 3 4
 _Bool 
# 161 "/home/toto/.env/encours/neovim/src/nvim/spell_defs.h"
      sl_collapse;
  
# 162 "/home/toto/.env/encours/neovim/src/nvim/spell_defs.h" 3 4
 _Bool 
# 162 "/home/toto/.env/encours/neovim/src/nvim/spell_defs.h"
      sl_rem_accents;
  
# 163 "/home/toto/.env/encours/neovim/src/nvim/spell_defs.h" 3 4
 _Bool 
# 163 "/home/toto/.env/encours/neovim/src/nvim/spell_defs.h"
      sl_sofo;


  garray_T sl_repsal;
  int16_t sl_repsal_first[256];
  
# 168 "/home/toto/.env/encours/neovim/src/nvim/spell_defs.h" 3 4
 _Bool 
# 168 "/home/toto/.env/encours/neovim/src/nvim/spell_defs.h"
      sl_nosplitsugs;
  
# 169 "/home/toto/.env/encours/neovim/src/nvim/spell_defs.h" 3 4
 _Bool 
# 169 "/home/toto/.env/encours/neovim/src/nvim/spell_defs.h"
      sl_nocompoundsugs;


  time_t sl_sugtime;
  char_u *sl_sbyts;
  idx_T *sl_sidxs;
  buf_T *sl_sugbuf;
  
# 176 "/home/toto/.env/encours/neovim/src/nvim/spell_defs.h" 3 4
 _Bool 
# 176 "/home/toto/.env/encours/neovim/src/nvim/spell_defs.h"
      sl_sugloaded;


  
# 179 "/home/toto/.env/encours/neovim/src/nvim/spell_defs.h" 3 4
 _Bool 
# 179 "/home/toto/.env/encours/neovim/src/nvim/spell_defs.h"
      sl_has_map;
  hashtab_T sl_map_hash;
  int sl_map_array[256];
  hashtab_T sl_sounddone;

};


typedef struct langp_S {
  slang_T *lp_slang;
  slang_T *lp_sallang;
  slang_T *lp_replang;
  int lp_region;
} langp_T;
# 204 "/home/toto/.env/encours/neovim/src/nvim/spell_defs.h"
typedef struct {
  
# 205 "/home/toto/.env/encours/neovim/src/nvim/spell_defs.h" 3 4
 _Bool 
# 205 "/home/toto/.env/encours/neovim/src/nvim/spell_defs.h"
      st_isw[256];
  
# 206 "/home/toto/.env/encours/neovim/src/nvim/spell_defs.h" 3 4
 _Bool 
# 206 "/home/toto/.env/encours/neovim/src/nvim/spell_defs.h"
      st_isu[256];
  char_u st_fold[256];
  char_u st_upper[256];
} spelltab_T;


typedef enum {
  STATE_START = 0,


  STATE_NOPREFIX,
  STATE_SPLITUNDO,
  STATE_ENDNUL,
  STATE_PLAIN,
  STATE_DEL,
  STATE_INS_PREP,
  STATE_INS,
  STATE_SWAP,
  STATE_UNSWAP,
  STATE_SWAP3,
  STATE_UNSWAP3,
  STATE_UNROT3L,
  STATE_UNROT3R,
  STATE_REP_INI,
  STATE_REP,
  STATE_REP_UNDO,
  STATE_FINAL
} state_T;


typedef struct trystate_S {
  state_T ts_state;
  int ts_score;
  idx_T ts_arridx;
  short ts_curi;
  char_u ts_fidx;
  char_u ts_fidxtry;
  char_u ts_twordlen;
  char_u ts_prefixdepth;

  char_u ts_flags;
  char_u ts_tcharlen;
  char_u ts_tcharidx;
  char_u ts_isdiff;
  char_u ts_fcharstart;
  char_u ts_prewordlen;
  char_u ts_splitoff;
  char_u ts_splitfidx;
  char_u ts_complen;
  char_u ts_compsplit;
  char_u ts_save_badflags;
  char_u ts_delidx;

} trystate_T;
# 276 "/home/toto/.env/encours/neovim/src/nvim/spell_defs.h"
extern slang_T *first_lang;


extern char_u *int_wordlist;

extern spelltab_T spelltab;
extern int did_set_spelltab;

extern char *e_format;
# 7 "/home/toto/.env/encours/neovim/src/nvim/spell.h" 2
# 109 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 2
# 1 "/home/toto/.env/encours/neovim/src/nvim/state.h" 1



# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 5 "/home/toto/.env/encours/neovim/src/nvim/state.h" 2

typedef struct vim_state VimState;

typedef int(*state_check_callback)(VimState *state);
typedef int(*state_execute_callback)(VimState *state, int key);

struct vim_state {
  state_check_callback check;
  state_execute_callback execute;
};
# 110 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 2

# 1 "/home/toto/.env/encours/neovim/src/nvim/syntax.h" 1
# 30 "/home/toto/.env/encours/neovim/src/nvim/syntax.h"
typedef struct {
  char *name;
  RgbValue color;
} color_name_table_T;
extern color_name_table_T color_name_table[];


extern const char *const highlight_init_cmdline[];
# 112 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 2


# 1 "/home/toto/.env/encours/neovim/src/nvim/ui_compositor.h" 1
# 115 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 2
# 1 "/home/toto/.env/encours/neovim/src/nvim/undo.h" 1
# 116 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 2
# 1 "/home/toto/.env/encours/neovim/src/nvim/version.h" 1






extern char* Version;
extern char* longVersion;
# 117 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 2


# 1 "/home/toto/.env/encours/neovim/src/nvim/api/private/helpers.h" 1
# 101 "/home/toto/.env/encours/neovim/src/nvim/api/private/helpers.h"
typedef struct {
  except_T *current_exception;
  struct msglist *private_msg_list;
  const struct msglist *const *msg_list;
  int trylevel;
  int got_int;
  int need_rethrow;
  int did_emsg;
} TryState;
# 120 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 2
# 1 "/home/toto/.env/encours/neovim/src/nvim/api/vim.h" 1
# 9 "/home/toto/.env/encours/neovim/src/nvim/api/vim.h"
extern Map_String_handle_T *namespace_ids ;
extern handle_T next_namespace_id ;
# 121 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 2
# 1 "/home/toto/.env/encours/neovim/src/nvim/lua/executor.h" 1



# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/luajit-2.1/lua.h" 1
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/luajit-2.1/lua.h"
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 14 "/home/toto/.env/encours/neovim/.deps/usr/include/luajit-2.1/lua.h" 2


# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/luajit-2.1/luaconf.h" 1
# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/luajit-2.1/luaconf.h"
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include-fixed/limits.h" 1 3 4
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/luajit-2.1/luaconf.h" 2
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 14 "/home/toto/.env/encours/neovim/.deps/usr/include/luajit-2.1/luaconf.h" 2
# 17 "/home/toto/.env/encours/neovim/.deps/usr/include/luajit-2.1/lua.h" 2
# 51 "/home/toto/.env/encours/neovim/.deps/usr/include/luajit-2.1/lua.h"
typedef struct lua_State lua_State;

typedef int (*lua_CFunction) (lua_State *L);





typedef const char * (*lua_Reader) (lua_State *L, void *ud, size_t *sz);

typedef int (*lua_Writer) (lua_State *L, const void* p, size_t sz, void* ud);





typedef void * (*lua_Alloc) (void *ud, void *ptr, size_t osize, size_t nsize);
# 100 "/home/toto/.env/encours/neovim/.deps/usr/include/luajit-2.1/lua.h"
typedef double lua_Number;



typedef ptrdiff_t lua_Integer;






extern lua_State *(lua_newstate) (lua_Alloc f, void *ud);
extern void (lua_close) (lua_State *L);
extern lua_State *(lua_newthread) (lua_State *L);

extern lua_CFunction (lua_atpanic) (lua_State *L, lua_CFunction panicf);





extern int (lua_gettop) (lua_State *L);
extern void (lua_settop) (lua_State *L, int idx);
extern void (lua_pushvalue) (lua_State *L, int idx);
extern void (lua_remove) (lua_State *L, int idx);
extern void (lua_insert) (lua_State *L, int idx);
extern void (lua_replace) (lua_State *L, int idx);
extern int (lua_checkstack) (lua_State *L, int sz);

extern void (lua_xmove) (lua_State *from, lua_State *to, int n);






extern int (lua_isnumber) (lua_State *L, int idx);
extern int (lua_isstring) (lua_State *L, int idx);
extern int (lua_iscfunction) (lua_State *L, int idx);
extern int (lua_isuserdata) (lua_State *L, int idx);
extern int (lua_type) (lua_State *L, int idx);
extern const char *(lua_typename) (lua_State *L, int tp);

extern int (lua_equal) (lua_State *L, int idx1, int idx2);
extern int (lua_rawequal) (lua_State *L, int idx1, int idx2);
extern int (lua_lessthan) (lua_State *L, int idx1, int idx2);

extern lua_Number (lua_tonumber) (lua_State *L, int idx);
extern lua_Integer (lua_tointeger) (lua_State *L, int idx);
extern int (lua_toboolean) (lua_State *L, int idx);
extern const char *(lua_tolstring) (lua_State *L, int idx, size_t *len);
extern size_t (lua_objlen) (lua_State *L, int idx);
extern lua_CFunction (lua_tocfunction) (lua_State *L, int idx);
extern void *(lua_touserdata) (lua_State *L, int idx);
extern lua_State *(lua_tothread) (lua_State *L, int idx);
extern const void *(lua_topointer) (lua_State *L, int idx);





extern void (lua_pushnil) (lua_State *L);
extern void (lua_pushnumber) (lua_State *L, lua_Number n);
extern void (lua_pushinteger) (lua_State *L, lua_Integer n);
extern void (lua_pushlstring) (lua_State *L, const char *s, size_t l);
extern void (lua_pushstring) (lua_State *L, const char *s);
extern const char *(lua_pushvfstring) (lua_State *L, const char *fmt,
                                                      va_list argp);
extern const char *(lua_pushfstring) (lua_State *L, const char *fmt, ...);
extern void (lua_pushcclosure) (lua_State *L, lua_CFunction fn, int n);
extern void (lua_pushboolean) (lua_State *L, int b);
extern void (lua_pushlightuserdata) (lua_State *L, void *p);
extern int (lua_pushthread) (lua_State *L);





extern void (lua_gettable) (lua_State *L, int idx);
extern void (lua_getfield) (lua_State *L, int idx, const char *k);
extern void (lua_rawget) (lua_State *L, int idx);
extern void (lua_rawgeti) (lua_State *L, int idx, int n);
extern void (lua_createtable) (lua_State *L, int narr, int nrec);
extern void *(lua_newuserdata) (lua_State *L, size_t sz);
extern int (lua_getmetatable) (lua_State *L, int objindex);
extern void (lua_getfenv) (lua_State *L, int idx);





extern void (lua_settable) (lua_State *L, int idx);
extern void (lua_setfield) (lua_State *L, int idx, const char *k);
extern void (lua_rawset) (lua_State *L, int idx);
extern void (lua_rawseti) (lua_State *L, int idx, int n);
extern int (lua_setmetatable) (lua_State *L, int objindex);
extern int (lua_setfenv) (lua_State *L, int idx);





extern void (lua_call) (lua_State *L, int nargs, int nresults);
extern int (lua_pcall) (lua_State *L, int nargs, int nresults, int errfunc);
extern int (lua_cpcall) (lua_State *L, lua_CFunction func, void *ud);
extern int (lua_load) (lua_State *L, lua_Reader reader, void *dt,
                                        const char *chunkname);

extern int (lua_dump) (lua_State *L, lua_Writer writer, void *data);





extern int (lua_yield) (lua_State *L, int nresults);
extern int (lua_resume) (lua_State *L, int narg);
extern int (lua_status) (lua_State *L);
# 232 "/home/toto/.env/encours/neovim/.deps/usr/include/luajit-2.1/lua.h"
extern int (lua_gc) (lua_State *L, int what, int data);






extern int (lua_error) (lua_State *L);

extern int (lua_next) (lua_State *L, int idx);

extern void (lua_concat) (lua_State *L, int n);

extern lua_Alloc (lua_getallocf) (lua_State *L, void **ud);
extern void lua_setallocf (lua_State *L, lua_Alloc f, void *ud);
# 300 "/home/toto/.env/encours/neovim/.deps/usr/include/luajit-2.1/lua.h"
extern void lua_setlevel (lua_State *from, lua_State *to);
# 328 "/home/toto/.env/encours/neovim/.deps/usr/include/luajit-2.1/lua.h"
typedef struct lua_Debug lua_Debug;



typedef void (*lua_Hook) (lua_State *L, lua_Debug *ar);


extern int lua_getstack (lua_State *L, int level, lua_Debug *ar);
extern int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar);
extern const char *lua_getlocal (lua_State *L, const lua_Debug *ar, int n);
extern const char *lua_setlocal (lua_State *L, const lua_Debug *ar, int n);
extern const char *lua_getupvalue (lua_State *L, int funcindex, int n);
extern const char *lua_setupvalue (lua_State *L, int funcindex, int n);
extern int lua_sethook (lua_State *L, lua_Hook func, int mask, int count);
extern lua_Hook lua_gethook (lua_State *L);
extern int lua_gethookmask (lua_State *L);
extern int lua_gethookcount (lua_State *L);


extern void *lua_upvalueid (lua_State *L, int idx, int n);
extern void lua_upvaluejoin (lua_State *L, int idx1, int n1, int idx2, int n2);
extern int lua_loadx (lua_State *L, lua_Reader reader, void *dt,
         const char *chunkname, const char *mode);
extern const lua_Number *lua_version (lua_State *L);
extern void lua_copy (lua_State *L, int fromidx, int toidx);
extern lua_Number lua_tonumberx (lua_State *L, int idx, int *isnum);
extern lua_Integer lua_tointegerx (lua_State *L, int idx, int *isnum);


extern int lua_isyieldable (lua_State *L);


struct lua_Debug {
  int event;
  const char *name;
  const char *namewhat;
  const char *what;
  const char *source;
  int currentline;
  int nups;
  int linedefined;
  int lastlinedefined;
  char short_src[60];

  int i_ci;
};
# 5 "/home/toto/.env/encours/neovim/src/nvim/lua/executor.h" 2
# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/luajit-2.1/lauxlib.h" 1
# 12 "/home/toto/.env/encours/neovim/.deps/usr/include/luajit-2.1/lauxlib.h"
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 13 "/home/toto/.env/encours/neovim/.deps/usr/include/luajit-2.1/lauxlib.h" 2


# 1 "/home/toto/.env/encours/neovim/.deps/usr/include/luajit-2.1/lua.h" 1
# 16 "/home/toto/.env/encours/neovim/.deps/usr/include/luajit-2.1/lauxlib.h" 2





typedef struct luaL_Reg {
  const char *name;
  lua_CFunction func;
} luaL_Reg;

extern void (luaL_openlib) (lua_State *L, const char *libname,
                                const luaL_Reg *l, int nup);
extern void (luaL_register) (lua_State *L, const char *libname,
                                const luaL_Reg *l);
extern int (luaL_getmetafield) (lua_State *L, int obj, const char *e);
extern int (luaL_callmeta) (lua_State *L, int obj, const char *e);
extern int (luaL_typerror) (lua_State *L, int narg, const char *tname);
extern int (luaL_argerror) (lua_State *L, int numarg, const char *extramsg);
extern const char *(luaL_checklstring) (lua_State *L, int numArg,
                                                          size_t *l);
extern const char *(luaL_optlstring) (lua_State *L, int numArg,
                                          const char *def, size_t *l);
extern lua_Number (luaL_checknumber) (lua_State *L, int numArg);
extern lua_Number (luaL_optnumber) (lua_State *L, int nArg, lua_Number def);

extern lua_Integer (luaL_checkinteger) (lua_State *L, int numArg);
extern lua_Integer (luaL_optinteger) (lua_State *L, int nArg,
                                          lua_Integer def);

extern void (luaL_checkstack) (lua_State *L, int sz, const char *msg);
extern void (luaL_checktype) (lua_State *L, int narg, int t);
extern void (luaL_checkany) (lua_State *L, int narg);

extern int (luaL_newmetatable) (lua_State *L, const char *tname);
extern void *(luaL_checkudata) (lua_State *L, int ud, const char *tname);

extern void (luaL_where) (lua_State *L, int lvl);
extern int (luaL_error) (lua_State *L, const char *fmt, ...);

extern int (luaL_checkoption) (lua_State *L, int narg, const char *def,
                                   const char *const lst[]);





extern int (luaL_ref) (lua_State *L, int t);
extern void (luaL_unref) (lua_State *L, int t, int ref);

extern int (luaL_loadfile) (lua_State *L, const char *filename);
extern int (luaL_loadbuffer) (lua_State *L, const char *buff, size_t sz,
                                  const char *name);
extern int (luaL_loadstring) (lua_State *L, const char *s);

extern lua_State *(luaL_newstate) (void);


extern const char *(luaL_gsub) (lua_State *L, const char *s, const char *p,
                                                  const char *r);

extern const char *(luaL_findtable) (lua_State *L, int idx,
                                         const char *fname, int szhint);


extern int luaL_fileresult(lua_State *L, int stat, const char *fname);
extern int luaL_execresult(lua_State *L, int stat);
extern int (luaL_loadfilex) (lua_State *L, const char *filename,
     const char *mode);
extern int (luaL_loadbufferx) (lua_State *L, const char *buff, size_t sz,
       const char *name, const char *mode);
extern void luaL_traceback (lua_State *L, lua_State *L1, const char *msg,
    int level);
extern void (luaL_setfuncs) (lua_State *L, const luaL_Reg *l, int nup);
extern void (luaL_pushmodule) (lua_State *L, const char *modname,
       int sizehint);
extern void *(luaL_testudata) (lua_State *L, int ud, const char *tname);
extern void (luaL_setmetatable) (lua_State *L, const char *tname);
# 135 "/home/toto/.env/encours/neovim/.deps/usr/include/luajit-2.1/lauxlib.h"
typedef struct luaL_Buffer {
  char *p;
  int lvl;
  lua_State *L;
  char buffer[(
# 139 "/home/toto/.env/encours/neovim/.deps/usr/include/luajit-2.1/lauxlib.h" 3 4
             8192 
# 139 "/home/toto/.env/encours/neovim/.deps/usr/include/luajit-2.1/lauxlib.h"
             > 16384 ? 8192 : 
# 139 "/home/toto/.env/encours/neovim/.deps/usr/include/luajit-2.1/lauxlib.h" 3 4
             8192
# 139 "/home/toto/.env/encours/neovim/.deps/usr/include/luajit-2.1/lauxlib.h"
             )];
} luaL_Buffer;
# 151 "/home/toto/.env/encours/neovim/.deps/usr/include/luajit-2.1/lauxlib.h"
extern void (luaL_buffinit) (lua_State *L, luaL_Buffer *B);
extern char *(luaL_prepbuffer) (luaL_Buffer *B);
extern void (luaL_addlstring) (luaL_Buffer *B, const char *s, size_t l);
extern void (luaL_addstring) (luaL_Buffer *B, const char *s);
extern void (luaL_addvalue) (luaL_Buffer *B);
extern void (luaL_pushresult) (luaL_Buffer *B);
# 6 "/home/toto/.env/encours/neovim/src/nvim/lua/executor.h" 2


# 1 "/home/toto/.env/encours/neovim/src/nvim/func_attr.h" 1
# 9 "/home/toto/.env/encours/neovim/src/nvim/lua/executor.h" 2




void nlua_add_api_functions(lua_State *lstate) __attribute__((nonnull));

extern LuaRef nlua_nil_ref ;
extern LuaRef nlua_empty_dict_ref ;
# 122 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 2
# 130 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
static size_t linebuf_size = 0;
static schar_T *linebuf_char = 
# 131 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                              ((void *)0)
# 131 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                  ;
static sattr_T *linebuf_attr = 
# 132 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                              ((void *)0)
# 132 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                  ;

static match_T search_hl;

static foldinfo_T win_foldinfo;

StlClickDefinition *tab_page_click_defs = 
# 138 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                         ((void *)0)
# 138 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                             ;

long tab_page_click_defs_size = 0;



typedef struct {
  const char_u *p;
  int prev_c;
  int prev_c1;
} LineState;



static 
# 152 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
      _Bool 
# 152 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
           send_grid_resize = 
# 152 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                              0
# 152 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                   ;

static 
# 154 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
      _Bool 
# 154 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
           conceal_cursor_used = 
# 154 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                 0
# 154 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                      ;

static 
# 156 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
      _Bool 
# 156 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
           redraw_popupmenu = 
# 156 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                              0
# 156 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                   ;
static 
# 157 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
      _Bool 
# 157 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
           msg_grid_invalid = 
# 157 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                              0
# 157 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                   ;

static 
# 159 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
      _Bool 
# 159 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
           resizing = 
# 159 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                      0
# 159 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                           ;
# 171 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
void redraw_later(int type)
{
  redraw_win_later(curwin, type);
}

void redraw_win_later(win_T *wp, int type)
  FUNC_ATTR_NONNULL_ALL
{
  if (!exiting && wp->w_redr_type < type) {
    wp->w_redr_type = type;
    if (type >= 40)
      wp->w_lines_valid = 0;
    if (must_redraw < type)
      must_redraw = type;
  }
}




void redraw_all_later(int type)
{
  for (win_T *wp = ((curtab) == curtab) ? firstwin : (curtab)->tp_firstwin; wp != 
# 193 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
 ((void *)0)
# 193 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
 ; wp = wp->w_next) {
    redraw_win_later(wp, type);
  }

  if (must_redraw < type) {
    must_redraw = type;
  }
}

void screen_invalidate_highlights(void)
{
  for (win_T *wp = ((curtab) == curtab) ? firstwin : (curtab)->tp_firstwin; wp != 
# 204 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
 ((void *)0)
# 204 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
 ; wp = wp->w_next) {
    redraw_win_later(wp, 40);
    wp->w_grid.valid = 
# 206 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                      0
# 206 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                           ;
  }
}




void redraw_curbuf_later(int type)
{
  redraw_buf_later(curbuf, type);
}

void redraw_buf_later(buf_T *buf, int type)
{
  for (win_T *wp = ((curtab) == curtab) ? firstwin : (curtab)->tp_firstwin; wp != 
# 220 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
 ((void *)0)
# 220 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
 ; wp = wp->w_next) {
    if (wp->w_buffer == buf) {
      redraw_win_later(wp, type);
    }
  }
}

void redraw_buf_line_later(buf_T *buf, linenr_T line)
{
  for (win_T *wp = ((curtab) == curtab) ? firstwin : (curtab)->tp_firstwin; wp != 
# 229 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
 ((void *)0)
# 229 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
 ; wp = wp->w_next) {
    if (wp->w_buffer == buf
        && line >= wp->w_topline && line < wp->w_botline) {
      redrawWinline(wp, line);
    }
  }
}

void redraw_buf_range_later(buf_T *buf, linenr_T firstline, linenr_T lastline)
{
  for (win_T *wp = ((curtab) == curtab) ? firstwin : (curtab)->tp_firstwin; wp != 
# 239 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
 ((void *)0)
# 239 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
 ; wp = wp->w_next) {
    if (wp->w_buffer == buf
        && lastline >= wp->w_topline && firstline < wp->w_botline) {
      if (wp->w_redraw_top == 0 || wp->w_redraw_top > firstline) {
          wp->w_redraw_top = firstline;
      }
      if (wp->w_redraw_bot == 0 || wp->w_redraw_bot < lastline) {
          wp->w_redraw_bot = lastline;
      }
      redraw_win_later(wp, 10);
    }
  }
}
# 261 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
void
redrawWinline(
    win_T *wp,
    linenr_T lnum
)
  FUNC_ATTR_NONNULL_ALL
{
  if (lnum >= wp->w_topline
      && lnum < wp->w_botline) {
    if (wp->w_redraw_top == 0 || wp->w_redraw_top > lnum) {
        wp->w_redraw_top = lnum;
    }
    if (wp->w_redraw_bot == 0 || wp->w_redraw_bot < lnum) {
        wp->w_redraw_bot = lnum;
    }
    redraw_win_later(wp, 10);
  }
}




void update_curbuf(int type)
{
  redraw_curbuf_later(type);
  update_screen(type);
}







int update_screen(int type)
{
  static int did_intro = 0;
  int did_one;




  if (!default_grid.chars || resizing) {
    return 0;
  }


  if (need_diff_redraw) {
    diff_redraw(
# 309 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
               1
# 309 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                   );
  }

  if (must_redraw) {
    if (type < must_redraw)
      type = must_redraw;





    must_redraw = 0;
  }


  if (curwin->w_lines_valid == 0 && type < 40)
    type = 40;



  if (!redrawing() || updating_screen) {
    redraw_later(type);
    must_redraw = type;
    if (type > 25) {
      curwin->w_lines_valid = 0;
    }
    return 0;
  }
  updating_screen = 1;

  display_tick++;




  if (msg_did_scroll) {
    msg_did_scroll = 
# 345 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                    0
# 345 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                         ;
    msg_scrolled_at_flush = 0;
  }

  if (type >= 50 || !default_grid.valid) {
    ui_comp_set_screen_valid(
# 350 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                            0
# 350 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                 );
  }


  if (msg_scrolled || msg_grid_invalid) {
    clear_cmdline = 
# 355 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                   1
# 355 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                       ;
    int valid = 
# 356 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
               (((
# 356 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
               Rows - msg_scrollsize()
# 356 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
               )>(
# 356 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
               0
# 356 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
               ))?(
# 356 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
               Rows - msg_scrollsize()
# 356 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
               ):(
# 356 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
               0
# 356 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
               ))
# 356 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                              ;
    if (msg_grid.chars) {

      for (int i = 0; i < 
# 359 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                         (((
# 359 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                         msg_scrollsize()
# 359 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                         )<(
# 359 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                         msg_grid.Rows
# 359 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                         ))?(
# 359 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                         msg_scrollsize()
# 359 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                         ):(
# 359 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                         msg_grid.Rows
# 359 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                         ))
# 359 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                             ; i++) {
        grid_clear_line(&msg_grid, msg_grid.line_offset[i],
                        (int)msg_grid.Columns, 
# 361 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                              0
# 361 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                   );
      }
    }
    if (msg_use_msgsep()) {
      msg_grid.throttled = 
# 365 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                          0
# 365 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                               ;

      if (type == 40 && !ui_has(kUIMultigrid) && msg_scrolled) {
        ui_comp_set_screen_valid(
# 368 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                0
# 368 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                     );
        for (int i = valid; i < Rows-p_ch; i++) {
          grid_clear_line(&default_grid, default_grid.line_offset[i],
                          Columns, 
# 371 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                  0
# 371 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                       );
        }
        for (win_T *wp = ((curtab) == curtab) ? firstwin : (curtab)->tp_firstwin; wp != 
# 373 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
       ((void *)0)
# 373 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
       ; wp = wp->w_next) {
          if (wp->w_floating) {
            continue;
          }
          if ((wp->w_winrow + wp->w_height) > valid) {
            wp->w_redr_type = 
# 378 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                             (((
# 378 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                             wp->w_redr_type
# 378 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                             )>(
# 378 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                             40
# 378 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                             ))?(
# 378 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                             wp->w_redr_type
# 378 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                             ):(
# 378 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                             40
# 378 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                             ))
# 378 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                            ;
          }
          if ((wp->w_winrow + wp->w_height) + wp->w_status_height > valid) {
            wp->w_redr_status = 
# 381 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                               1
# 381 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                   ;
          }
        }
      }
      msg_grid_set_pos(Rows-p_ch, 
# 385 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                 0
# 385 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                      );
      msg_grid_invalid = 
# 386 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                        0
# 386 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                             ;
    } else if (msg_scrolled > Rows - 5) {
      type = 50;
    } else if (type != 50) {
      check_for_delay(
# 390 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                     0
# 390 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                          );
      grid_ins_lines(&default_grid, 0, msg_scrolled, Rows, 0, Columns);
      for (win_T *wp = ((curtab) == curtab) ? firstwin : (curtab)->tp_firstwin; wp != 
# 392 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
     ((void *)0)
# 392 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
     ; wp = wp->w_next) {
        if (wp->w_floating) {
          continue;
        }
        if (wp->w_winrow < msg_scrolled) {
          if ((wp->w_winrow + wp->w_height) > msg_scrolled
              && wp->w_redr_type < 30
              && wp->w_lines_valid > 0
              && wp->w_topline == wp->w_lines[0].wl_lnum) {
            wp->w_upd_rows = msg_scrolled - wp->w_winrow;
            wp->w_redr_type = 30;
          } else {
            wp->w_redr_type = 40;
            if ((wp->w_winrow + wp->w_height) + wp->w_status_height
                <= msg_scrolled) {
              wp->w_redr_status = 1;
            }
          }
        }
      }
      redraw_cmdline = 1;
      redraw_tabline = 1;
    }
    msg_scrolled = 0;
    msg_scrolled_at_flush = 0;
    need_wait_return = 
# 417 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                      0
# 417 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                           ;
  }

  win_ui_flush();
  msg_ext_check_clear();


  compute_cmdrow();


  if (need_highlight_changed)
    highlight_changed();

  if (type == 50) {
    screenclear();
    cmdline_screen_cleared();
    type = 40;

    must_redraw = 0;
  } else if (!default_grid.valid) {
    grid_invalidate(&default_grid);
    default_grid.valid = 
# 438 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                        1
# 438 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                            ;
  }



  if (type == 40 && (msg_use_grid() || msg_grid.chars)) {
    grid_fill(&default_grid, Rows-p_ch, Rows, 0, Columns, ' ', ' ', 0);
  }

  ui_comp_set_screen_valid(
# 447 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                          1
# 447 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                              );

  if (clear_cmdline)
    check_for_delay(0);



  if (curwin->w_redr_type < 40
      && curwin->w_nrwidth != ((curwin->w_onebuf_opt.wo_nu || curwin->w_onebuf_opt.wo_rnu)
                               ? number_width(curwin) : 0))
    curwin->w_redr_type = 40;




  if (type == 20)
    update_curswant();
  if (curwin->w_redr_type < type
      && !((type == 10
            && curwin->w_lines[0].wl_valid
            && curwin->w_topfill == curwin->w_old_topfill
            && curwin->w_botfill == curwin->w_old_botfill
            && curwin->w_topline == curwin->w_lines[0].wl_lnum)
           || (type == 20
               && VIsual_active
               && curwin->w_old_cursor_lnum == curwin->w_cursor.lnum
               && curwin->w_old_visual_mode == VIsual_mode
               && (curwin->w_valid & 0x04)
               && curwin->w_old_curswant == curwin->w_curswant)
           ))
    curwin->w_redr_type = type;


  if (redraw_tabline || type >= 40) {
    update_window_hl(curwin, type >= 40);
    for (tabpage_T *tp = first_tabpage; tp != 
# 482 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
   ((void *)0)
# 482 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
   ; tp = tp->tp_next) {
      if (tp != curtab) {
        update_window_hl(tp->tp_curwin, type >= 40);
      }
    }
    draw_tabline();
  }





  for (win_T *wp = ((curtab) == curtab) ? firstwin : (curtab)->tp_firstwin; wp != 
# 494 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
 ((void *)0)
# 494 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
 ; wp = wp->w_next) {
    update_window_hl(wp, type >= 40);

    if (wp->w_buffer->b_mod_set) {
      win_T *wwp;


      for (wwp = firstwin; wwp != wp; wwp = wwp->w_next) {
        if (wwp->w_buffer == wp->w_buffer) {
          break;
        }
      }
      if (wwp == wp && syntax_present(wp)) {
        syn_stack_apply_changes(wp->w_buffer);
      }

      buf_T *buf = wp->w_buffer;
      if (buf->b_luahl && buf->b_luahl_window != (-2)) {
        Error err = { .type = kErrorTypeNone, .msg = 
# 512 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                   ((void *)0) 
# 512 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                   };
        Array args = {.size = 0, .capacity = 0, .items = 
# 513 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
       ((void *)0)
# 513 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
       }; Object args__items[2]; args.size = 2; args.items = args__items;;
        args.items[0] = ((Object) { .type = kObjectTypeBuffer, .data.integer = buf->handle });
        args.items[1] = ((Object) { .type = kObjectTypeInteger, .data.integer = display_tick });
        executor_exec_lua_cb(buf->b_luahl_start, "start", args, 
# 516 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                                               0
# 516 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                                    , &err);
        if (((&err)->type != kErrorTypeNone)) {
          logmsg(3, 
# 518 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
         ((void *)0)
# 518 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
         , __func__, 518, 
# 518 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
         1
# 518 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
         , "error in luahl start: %s", err.msg);
          api_clear_error(&err);
        }
      }
    }
  }





  did_one = 0;
  search_hl.rm.regprog = 
# 530 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                        ((void *)0)
# 530 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                            ;


  for (win_T *wp = ((curtab) == curtab) ? firstwin : (curtab)->tp_firstwin; wp != 
# 533 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
 ((void *)0)
# 533 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
 ; wp = wp->w_next) {
    if (wp->w_redr_type == 50 && wp->w_floating && wp->w_grid.chars) {
      grid_invalidate(&wp->w_grid);
      wp->w_redr_type = 40;
    }

    if (wp->w_redr_type != 0) {
      if (!did_one) {
        did_one = 1;
        start_search_hl();
      }
      win_update(wp);
    }


    if (wp->w_redr_status) {
      win_redr_status(wp);
    }
  }

  end_search_hl();


  if (pum_drawn() && must_redraw_pum) {
    pum_redraw();
  }

  send_grid_resize = 
# 560 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                    0
# 560 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                         ;



  for (win_T *wp = ((curtab) == curtab) ? firstwin : (curtab)->tp_firstwin; wp != 
# 564 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
 ((void *)0)
# 564 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
 ; wp = wp->w_next) {
    wp->w_buffer->b_mod_set = 
# 565 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                             0
# 565 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                  ;
  }

  updating_screen = 0;



  if (clear_cmdline || redraw_cmdline) {
    showmode();
  }


  if (!did_intro)
    maybe_intro_message();
  did_intro = 1;


  cmdline_was_last_drawn = 
# 582 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                          0
# 582 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                               ;
  return 1;
}




# 588 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
_Bool 
# 588 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
    conceal_cursor_line(const win_T *wp)
  FUNC_ATTR_NONNULL_ALL
{
  int c;

  if (*wp->w_onebuf_opt.wo_cocu == '\000') {
    return 
# 594 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
          0
# 594 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
               ;
  }
  if (get_real_state() & 0x02) {
    c = 'v';
  } else if (State & 0x10) {
    c = 'i';
  } else if (State & 0x01) {
    c = 'n';
  } else if (State & 0x08) {
    c = 'c';
  } else {
    return 
# 605 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
          0
# 605 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
               ;
  }
  return vim_strchr(wp->w_onebuf_opt.wo_cocu, c) != 
# 607 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                       ((void *)0)
# 607 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                           ;
}




void conceal_check_cursor_line(void)
{
  
# 615 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
 _Bool 
# 615 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
      should_conceal = conceal_cursor_line(curwin);
  if (curwin->w_onebuf_opt.wo_cole > 0 && (conceal_cursor_used != should_conceal)) {
    redrawWinline(curwin, curwin->w_cursor.lnum);


    curs_columns(
# 620 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                1
# 620 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                    );
  }
}








# 630 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
_Bool 
# 630 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
    win_cursorline_standout(const win_T *wp)
  FUNC_ATTR_NONNULL_ALL
{
  return wp->w_onebuf_opt.wo_cul
    || (wp->w_onebuf_opt.wo_cole > 0 && (VIsual_active || !conceal_cursor_line(wp)));
}

static DecorationRedrawState decorations;

# 638 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
_Bool 
# 638 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
    decorations_active = 
# 638 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                         0
# 638 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                              ;

void decorations_add_luahl_attr(int attr_id,
                                int start_row, int start_col,
                                int end_row, int end_col)
{
  (*((((decorations.active).size == (decorations.active).capacity) ? (((decorations.active).capacity = ((decorations.active).capacity ? (decorations.active).capacity << 1 : 8), (decorations.active).items = xrealloc((decorations.active).items, sizeof((decorations.active).items[0]) * (decorations.active).capacity)), 0) : 0), ((decorations.active).items + ((decorations.active).size++))) = (((HlRange){ start_row, start_col, end_row, end_col, attr_id, 
# 644 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
 ((void *)0) 
# 644 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
 })))
                                                                               ;
}
# 675 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
static void win_update(win_T *wp)
{
  buf_T *buf = wp->w_buffer;
  int type;
  int top_end = 0;

  int mid_start = 999;

  int mid_end = 0;

  int bot_start = 999;

  int scrolled_down = 0;

  
# 689 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
 _Bool 
# 689 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
      top_to_mod = 
# 689 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                   0
# 689 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                        ;

  int row;
  linenr_T lnum;
  int idx;
  int srow;

  int eof = 0;
  int didline = 0;
  int i;
  long j;
  static int recursive = 0;
  int old_botline = wp->w_botline;
  long fold_count;




  int did_update = 1;
  linenr_T syntax_last_parsed = 0;
  linenr_T mod_top = 0;
  linenr_T mod_bot = 0;
  int save_got_int;




  buf_signcols(buf);

  type = wp->w_redr_type;

  win_grid_alloc(wp);

  if (type >= 40) {
    wp->w_redr_status = 
# 723 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                       1
# 723 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                           ;
    wp->w_lines_valid = 0;
  }


  if (wp->w_grid.Rows == 0) {
    wp->w_redr_type = 0;
    return;
  }


  if (wp->w_grid.Columns == 0) {

    draw_vsep_win(wp, 0);
    wp->w_redr_type = 0;
    return;
  }

  init_search_hl(wp);



  i = (wp->w_onebuf_opt.wo_nu || wp->w_onebuf_opt.wo_rnu) ? number_width(wp) : 0;
  if (wp->w_nrwidth != i) {
    type = 40;
    wp->w_nrwidth = i;

    if (buf->terminal) {
      terminal_check_size(buf->terminal);
    }
  } else if (buf->b_mod_set
             && buf->b_mod_xlines != 0
             && wp->w_redraw_top != 0) {



    type = 40;
  } else {




    mod_top = wp->w_redraw_top;
    if (wp->w_redraw_bot != 0)
      mod_bot = wp->w_redraw_bot + 1;
    else
      mod_bot = 0;
    if (buf->b_mod_set) {
      if (mod_top == 0 || mod_top > buf->b_mod_top) {
        mod_top = buf->b_mod_top;


        if (syntax_present(wp)) {
          mod_top -= buf->b_s.b_syn_sync_linebreaks;
          if (mod_top < 1)
            mod_top = 1;
        }
      }
      if (mod_bot == 0 || mod_bot < buf->b_mod_bot)
        mod_bot = buf->b_mod_bot;






      if (search_hl.rm.regprog != 
# 789 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                 ((void *)0)
          
# 790 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
         && re_multiline(search_hl.rm.regprog)) {
        top_to_mod = 
# 791 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                    1
# 791 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                        ;
      } else {
        const matchitem_T *cur = wp->w_match_head;
        while (cur != 
# 794 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                     ((void *)0)
# 794 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                         ) {
          if (cur->match.regprog != 
# 795 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                   ((void *)0)
              
# 796 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
             && re_multiline(cur->match.regprog)) {
            top_to_mod = 
# 797 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                        1
# 797 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                            ;
            break;
          }
          cur = cur->next;
        }
      }
    }
    if (mod_top != 0 && hasAnyFolding(wp)) {
      linenr_T lnumt, lnumb;
# 819 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
      lnumt = wp->w_topline;
      lnumb = MAXLNUM;
      for (i = 0; i < wp->w_lines_valid; ++i)
        if (wp->w_lines[i].wl_valid) {
          if (wp->w_lines[i].wl_lastlnum < mod_top)
            lnumt = wp->w_lines[i].wl_lastlnum + 1;
          if (lnumb == MAXLNUM && wp->w_lines[i].wl_lnum >= mod_bot) {
            lnumb = wp->w_lines[i].wl_lnum;


            if (compute_foldcolumn(wp, 0) > 0) {
              lnumb++;
            }
          }
        }

      (void)hasFoldingWin(wp, mod_top, &mod_top, 
# 835 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                                ((void *)0)
# 835 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                    , 
# 835 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                                      1
# 835 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                          , 
# 835 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                                            ((void *)0)
# 835 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                                );
      if (mod_top > lnumt) {
        mod_top = lnumt;
      }


      mod_bot--;
      (void)hasFoldingWin(wp, mod_bot, 
# 842 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                      ((void *)0)
# 842 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                          , &mod_bot, 
# 842 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                                      1
# 842 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                          , 
# 842 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                                            ((void *)0)
# 842 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                                );
      mod_bot++;
      if (mod_bot < lnumb) {
        mod_bot = lnumb;
      }
    }





    if (mod_top != 0 && mod_top < wp->w_topline) {
      if (mod_bot > wp->w_topline)
        mod_top = wp->w_topline;
      else if (syntax_present(wp))
        top_end = 1;
    }



    if (mod_top != 0 && buf->b_mod_xlines != 0 && wp->w_onebuf_opt.wo_nu)
      mod_bot = MAXLNUM;
  }
  wp->w_redraw_top = 0;
  wp->w_redraw_bot = 0;





  if (type == 30) {
    j = 0;
    for (i = 0; i < wp->w_lines_valid; ++i) {
      j += wp->w_lines[i].wl_size;
      if (j >= wp->w_upd_rows) {
        top_end = j;
        break;
      }
    }
    if (top_end == 0)

      type = 40;
    else

      type = 10;
  }
# 897 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
  if ((type == 10 || type == 35
       || type == 20 || type == 25)
      && !wp->w_botfill && !wp->w_old_botfill
      ) {
    if (mod_top != 0 && wp->w_topline == mod_top) {




    } else if (wp->w_lines[0].wl_valid
               && (wp->w_topline < wp->w_lines[0].wl_lnum
                   || (wp->w_topline == wp->w_lines[0].wl_lnum
                       && wp->w_topfill > wp->w_old_topfill)
                   )) {



      if (hasAnyFolding(wp)) {
        linenr_T ln;



        j = 0;
        for (ln = wp->w_topline; ln < wp->w_lines[0].wl_lnum; ln++) {
          j++;
          if (j >= wp->w_grid.Rows - 2) {
            break;
          }
          (void)hasFoldingWin(wp, ln, 
# 925 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                     ((void *)0)
# 925 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                         , &ln, 
# 925 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                                1
# 925 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                    , 
# 925 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                                      ((void *)0)
# 925 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                          );
        }
      } else
        j = wp->w_lines[0].wl_lnum - wp->w_topline;
      if (j < wp->w_grid.Rows - 2) {
        i = plines_m_win(wp, wp->w_topline, wp->w_lines[0].wl_lnum - 1);

        if (wp->w_lines[0].wl_lnum != wp->w_topline)
          i += diff_check_fill(wp, wp->w_lines[0].wl_lnum)
               - wp->w_old_topfill;
        if (i != 0 && i < wp->w_grid.Rows - 2) {



          win_scroll_lines(wp, 0, i);
          if (wp->w_lines_valid != 0) {


            top_end = i;
            scrolled_down = 
# 944 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                           1
# 944 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                               ;



            if ((wp->w_lines_valid += j) > wp->w_grid.Rows) {
              wp->w_lines_valid = wp->w_grid.Rows;
            }
            for (idx = wp->w_lines_valid; idx - j >= 0; idx--) {
              wp->w_lines[idx] = wp->w_lines[idx - j];
            }
            while (idx >= 0) {
              wp->w_lines[idx--].wl_valid = 
# 955 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                           0
# 955 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                ;
            }
          }
        } else {
          mid_start = 0;
        }
      } else {
        mid_start = 0;
      }
    } else {







      j = -1;
      row = 0;
      for (i = 0; i < wp->w_lines_valid; i++) {
        if (wp->w_lines[i].wl_valid
            && wp->w_lines[i].wl_lnum == wp->w_topline) {
          j = i;
          break;
        }
        row += wp->w_lines[i].wl_size;
      }
      if (j == -1) {


        mid_start = 0;
      } else {






        if (wp->w_lines[0].wl_lnum == wp->w_topline)
          row += wp->w_old_topfill;
        else
          row += diff_check_fill(wp, wp->w_topline);

        row -= wp->w_topfill;
        if (row > 0) {
          win_scroll_lines(wp, 0, -row);
          bot_start = wp->w_grid.Rows - row;
        }
        if ((row == 0 || bot_start < 999) && wp->w_lines_valid != 0) {






          bot_start = 0;
          idx = 0;
          for (;; ) {
            wp->w_lines[idx] = wp->w_lines[j];


            if (row > 0 && bot_start + row
                + (int)wp->w_lines[j].wl_size > wp->w_grid.Rows) {
              wp->w_lines_valid = idx + 1;
              break;
            }
            bot_start += wp->w_lines[idx++].wl_size;


            if (++j >= wp->w_lines_valid) {
              wp->w_lines_valid = idx;
              break;
            }
          }


          if (wp->w_onebuf_opt.wo_diff && bot_start > 0)
            wp->w_lines[0].wl_size =
              plines_win_nofill(wp, wp->w_topline, 
# 1033 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                                  1
# 1033 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                      )
              + wp->w_topfill;
        }
      }
    }


    if (mid_start == 0) {
      mid_end = wp->w_grid.Rows;
    }
  } else {

    mid_start = 0;
    mid_end = wp->w_grid.Rows;
  }

  if (type == 35) {

    mid_start = 0;
    mid_end = wp->w_grid.Rows;
    type = 40;
  }


  if ((VIsual_active && buf == curwin->w_buffer)
      || (wp->w_old_cursor_lnum != 0 && type != 40)) {
    linenr_T from, to;

    if (VIsual_active) {
      if (VIsual_mode != wp->w_old_visual_mode || type == 25) {



        if (curwin->w_cursor.lnum < VIsual.lnum) {
          from = curwin->w_cursor.lnum;
          to = VIsual.lnum;
        } else {
          from = VIsual.lnum;
          to = curwin->w_cursor.lnum;
        }

        if (wp->w_old_cursor_lnum < from)
          from = wp->w_old_cursor_lnum;
        if (wp->w_old_cursor_lnum > to)
          to = wp->w_old_cursor_lnum;
        if (wp->w_old_visual_lnum < from)
          from = wp->w_old_visual_lnum;
        if (wp->w_old_visual_lnum > to)
          to = wp->w_old_visual_lnum;
      } else {





        if (curwin->w_cursor.lnum < wp->w_old_cursor_lnum) {
          from = curwin->w_cursor.lnum;
          to = wp->w_old_cursor_lnum;
        } else {
          from = wp->w_old_cursor_lnum;
          to = curwin->w_cursor.lnum;
          if (from == 0)
            from = to;
        }

        if (VIsual.lnum != wp->w_old_visual_lnum
            || VIsual.col != wp->w_old_visual_col) {
          if (wp->w_old_visual_lnum < from
              && wp->w_old_visual_lnum != 0)
            from = wp->w_old_visual_lnum;
          if (wp->w_old_visual_lnum > to)
            to = wp->w_old_visual_lnum;
          if (VIsual.lnum < from)
            from = VIsual.lnum;
          if (VIsual.lnum > to)
            to = VIsual.lnum;
        }
      }






      if (VIsual_mode == 22) {
        colnr_T fromc, toc;
        int save_ve_flags = ve_flags;

        if (curwin->w_onebuf_opt.wo_lbr)
          ve_flags = 4;

        getvcols(wp, &VIsual, &curwin->w_cursor, &fromc, &toc);
        ve_flags = save_ve_flags;
        ++toc;
        if (curwin->w_curswant == MAXCOL)
          toc = MAXCOL;

        if (fromc != wp->w_old_cursor_fcol
            || toc != wp->w_old_cursor_lcol) {
          if (from > VIsual.lnum)
            from = VIsual.lnum;
          if (to < VIsual.lnum)
            to = VIsual.lnum;
        }
        wp->w_old_cursor_fcol = fromc;
        wp->w_old_cursor_lcol = toc;
      }
    } else {

      if (wp->w_old_cursor_lnum < wp->w_old_visual_lnum) {
        from = wp->w_old_cursor_lnum;
        to = wp->w_old_visual_lnum;
      } else {
        from = wp->w_old_visual_lnum;
        to = wp->w_old_cursor_lnum;
      }
    }




    if (from < wp->w_topline)
      from = wp->w_topline;





    if (wp->w_valid & 0x20) {
      if (from >= wp->w_botline)
        from = wp->w_botline - 1;
      if (to >= wp->w_botline)
        to = wp->w_botline - 1;
    }
# 1177 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
    if (mid_start > 0) {
      lnum = wp->w_topline;
      idx = 0;
      srow = 0;
      if (scrolled_down)
        mid_start = top_end;
      else
        mid_start = 0;
      while (lnum < from && idx < wp->w_lines_valid) {
        if (wp->w_lines[idx].wl_valid)
          mid_start += wp->w_lines[idx].wl_size;
        else if (!scrolled_down)
          srow += wp->w_lines[idx].wl_size;
        ++idx;
        if (idx < wp->w_lines_valid && wp->w_lines[idx].wl_valid)
          lnum = wp->w_lines[idx].wl_lnum;
        else
          ++lnum;
      }
      srow += mid_start;
      mid_end = wp->w_grid.Rows;
      for (; idx < wp->w_lines_valid; idx++) {
        if (wp->w_lines[idx].wl_valid
            && wp->w_lines[idx].wl_lnum >= to + 1) {

          mid_end = srow;
          break;
        }
        srow += wp->w_lines[idx].wl_size;
      }
    }
  }

  if (VIsual_active && buf == curwin->w_buffer) {
    wp->w_old_visual_mode = VIsual_mode;
    wp->w_old_cursor_lnum = curwin->w_cursor.lnum;
    wp->w_old_visual_lnum = VIsual.lnum;
    wp->w_old_visual_col = VIsual.col;
    wp->w_old_curswant = curwin->w_curswant;
  } else {
    wp->w_old_visual_mode = 0;
    wp->w_old_cursor_lnum = 0;
    wp->w_old_visual_lnum = 0;
    wp->w_old_visual_col = 0;
  }


  save_got_int = got_int;
  got_int = 0;

  proftime_T syntax_tm = profile_setlimit(p_rdt);
  syn_set_timeout(&syntax_tm);
  win_foldinfo.fi_level = 0;




  idx = 0;
  row = 0;
  srow = 0;
  lnum = wp->w_topline;

  decorations_active = decorations_redraw_reset(buf, &decorations);

  if (buf->b_luahl && buf->b_luahl_window != (-2)) {
    Error err = { .type = kErrorTypeNone, .msg = 
# 1242 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
               ((void *)0) 
# 1242 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
               };
    Array args = {.size = 0, .capacity = 0, .items = 
# 1243 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
   ((void *)0)
# 1243 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
   }; Object args__items[4]; args.size = 4; args.items = args__items;;
    linenr_T knownmax = ((wp->w_valid & 0x20)
                         ? wp->w_botline
                         : (wp->w_topline + wp->w_height_inner));
    args.items[0] = ((Object) { .type = kObjectTypeWindow, .data.integer = wp->handle });
    args.items[1] = ((Object) { .type = kObjectTypeBuffer, .data.integer = buf->handle });

    args.items[2] = ((Object) { .type = kObjectTypeInteger, .data.integer = wp->w_topline-1 });
    args.items[3] = ((Object) { .type = kObjectTypeInteger, .data.integer = knownmax });


    executor_exec_lua_cb(buf->b_luahl_window, "window", args, 
# 1254 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                                             0
# 1254 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                                  , &err);
    if (((&err)->type != kErrorTypeNone)) {
      logmsg(3, 
# 1256 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
     ((void *)0)
# 1256 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
     , __func__, 1256, 
# 1256 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
     1
# 1256 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
     , "error in luahl window: %s", err.msg);
      api_clear_error(&err);
    }
  }


  for (;; ) {


    if (row == wp->w_grid.Rows) {
      didline = 
# 1266 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
               1
# 1266 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                   ;
      break;
    }


    if (lnum > buf->b_ml.ml_line_count) {
      eof = 1;
      break;
    }



    srow = row;
# 1287 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
    if (row < top_end
        || (row >= mid_start && row < mid_end)
        || top_to_mod
        || idx >= wp->w_lines_valid
        || (row + wp->w_lines[idx].wl_size > bot_start)
        || (mod_top != 0
            && (lnum == mod_top
                || (lnum >= mod_top
                    && (lnum < mod_bot
                        || did_update == 3
                        || (did_update == 2
                            && syntax_present(wp)
                            && ((foldmethodIsSyntax(wp)
                                 && hasAnyFolding(wp))
                                || syntax_check_changed(lnum)))


                        || (wp->w_match_head != 
# 1304 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                               ((void *)0)
                            
# 1305 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                           && buf->b_mod_xlines != 0)))))) {
      if (lnum == mod_top) {
        top_to_mod = 
# 1307 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                    0
# 1307 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                         ;
      }







      if (lnum == mod_top
          && mod_bot != MAXLNUM
          && !(dollar_vcol >= 0 && mod_bot == mod_top + 1)) {
        int old_rows = 0;
        int new_rows = 0;
        int xtra_rows;
        linenr_T l;




        for (i = idx; i < wp->w_lines_valid; ++i) {


          if (wp->w_lines[i].wl_valid
              && wp->w_lines[i].wl_lnum == mod_bot)
            break;
          old_rows += wp->w_lines[i].wl_size;
          if (wp->w_lines[i].wl_valid
              && wp->w_lines[i].wl_lastlnum + 1 == mod_bot) {


            ++i;
            while (i < wp->w_lines_valid
                   && !wp->w_lines[i].wl_valid)
              old_rows += wp->w_lines[i++].wl_size;
            break;
          }
        }

        if (i >= wp->w_lines_valid) {



          bot_start = 0;
        } else {


          j = idx;
          for (l = lnum; l < mod_bot; l++) {
            if (hasFoldingWin(wp, l, 
# 1356 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                    ((void *)0)
# 1356 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                        , &l, 
# 1356 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                              1
# 1356 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                  , 
# 1356 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                                    ((void *)0)
# 1356 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                        )) {
              new_rows++;
            } else if (l == wp->w_topline) {
              new_rows += plines_win_nofill(wp, l, 
# 1359 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                                  1
# 1359 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                      ) + wp->w_topfill;
            } else {
              new_rows += plines_win(wp, l, 
# 1361 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                           1
# 1361 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                               );
            }
            j++;
            if (new_rows > wp->w_grid.Rows - row - 2) {

              new_rows = 9999;
              break;
            }
          }
          xtra_rows = new_rows - old_rows;
          if (xtra_rows < 0) {




            if (row - xtra_rows >= wp->w_grid.Rows - 2) {
              mod_bot = MAXLNUM;
            } else {
              win_scroll_lines(wp, row, xtra_rows);
              bot_start = wp->w_grid.Rows + xtra_rows;
            }
          } else if (xtra_rows > 0) {



            if (row + xtra_rows >= wp->w_grid.Rows - 2) {
              mod_bot = MAXLNUM;
            } else {
              win_scroll_lines(wp, row + old_rows, xtra_rows);
              if (top_end > row + old_rows) {


                top_end += xtra_rows;
              }
            }
          }



          if (mod_bot != MAXLNUM && i != j) {
            if (j < i) {
              int x = row + new_rows;


              for (;; ) {

                if (i >= wp->w_lines_valid) {
                  wp->w_lines_valid = j;
                  break;
                }
                wp->w_lines[j] = wp->w_lines[i];

                if (x + (int)wp->w_lines[j].wl_size
                    > wp->w_grid.Rows) {
                  wp->w_lines_valid = j + 1;
                  break;
                }
                x += wp->w_lines[j++].wl_size;
                ++i;
              }
              if (bot_start > x)
                bot_start = x;
            } else {

              j -= i;
              wp->w_lines_valid += j;
              if (wp->w_lines_valid > wp->w_grid.Rows) {
                wp->w_lines_valid = wp->w_grid.Rows;
              }
              for (i = wp->w_lines_valid; i - j >= idx; i--) {
                wp->w_lines[i] = wp->w_lines[i - j];
              }




              while (i >= idx) {
                wp->w_lines[i].wl_size = 0;
                wp->w_lines[i--].wl_valid = 0;
              }
            }
          }
        }
      }






      fold_count = foldedCount(wp, lnum, &win_foldinfo);
      if (fold_count != 0) {
        fold_line(wp, fold_count, &win_foldinfo, lnum, row);
        ++row;
        --fold_count;
        wp->w_lines[idx].wl_folded = 1;
        wp->w_lines[idx].wl_lastlnum = lnum + fold_count;
        did_update = 3;
      } else if (idx < wp->w_lines_valid
                 && wp->w_lines[idx].wl_valid
                 && wp->w_lines[idx].wl_lnum == lnum
                 && lnum > wp->w_topline
                 && !(dy_flags & (0x001 | 0x002))
                 && srow + wp->w_lines[idx].wl_size > wp->w_grid.Rows
                 && diff_check_fill(wp, lnum) == 0
                 ) {


        row = wp->w_grid.Rows + 1;
      } else {
        prepare_search_hl(wp, lnum);

        if (syntax_last_parsed != 0 && syntax_last_parsed + 1 < lnum
            && syntax_present(wp))
          syntax_end_parsing(syntax_last_parsed + 1);




        row = win_line(wp, lnum, srow, wp->w_grid.Rows, mod_top == 0, 
# 1480 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                                                     0
# 1480 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                                          );

        wp->w_lines[idx].wl_folded = 0;
        wp->w_lines[idx].wl_lastlnum = lnum;
        did_update = 2;
        syntax_last_parsed = lnum;
      }

      wp->w_lines[idx].wl_lnum = lnum;
      wp->w_lines[idx].wl_valid = 
# 1489 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                 1
# 1489 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                     ;

      if (row > wp->w_grid.Rows) {

        if (dollar_vcol == -1) {
          wp->w_lines[idx].wl_size = plines_win(wp, lnum, 
# 1494 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                                         1
# 1494 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                             );
        }
        idx++;
        break;
      }
      if (dollar_vcol == -1)
        wp->w_lines[idx].wl_size = row - srow;
      ++idx;
      lnum += fold_count + 1;
    } else {
      if (wp->w_onebuf_opt.wo_rnu) {


        fold_count = foldedCount(wp, lnum, &win_foldinfo);
        if (fold_count != 0) {
          fold_line(wp, fold_count, &win_foldinfo, lnum, row);
        } else {
          (void)win_line(wp, lnum, srow, wp->w_grid.Rows, 
# 1511 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                                         1
# 1511 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                             , 
# 1511 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                                               1
# 1511 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                                   );
        }
      }


      row += wp->w_lines[idx++].wl_size;
      if (row > wp->w_grid.Rows) {
        break;
      }
      lnum = wp->w_lines[idx - 1].wl_lastlnum + 1;
      did_update = 1;
    }

    if (lnum > buf->b_ml.ml_line_count) {
      eof = 1;
      break;
    }
  }





  if (idx > wp->w_lines_valid)
    wp->w_lines_valid = idx;




  if (syntax_last_parsed != 0 && syntax_present(wp))
    syntax_end_parsing(syntax_last_parsed + 1);





  wp->w_empty_rows = 0;
  wp->w_filler_rows = 0;
  if (!eof && !didline) {
    int at_attr = hl_combine_attr(wp->w_hl_attr_normal,
                                  win_hl_attr(wp, HLF_AT));
    if (lnum == wp->w_topline) {




      wp->w_botline = lnum + 1;
    } else if (diff_check_fill(wp, lnum) >= wp->w_grid.Rows - srow) {

      wp->w_botline = lnum;
      wp->w_filler_rows = wp->w_grid.Rows - srow;
    } else if (dy_flags & 0x002) {
      int scr_row = wp->w_grid.Rows - 1;


      grid_puts_len(&wp->w_grid, (char_u *)"@@", 2, scr_row, 0, at_attr);

      grid_fill(&wp->w_grid, scr_row, scr_row + 1, 2, wp->w_grid.Columns,
                '@', ' ', at_attr);
      set_empty_rows(wp, srow);
      wp->w_botline = lnum;
    } else if (dy_flags & 0x001) {

      grid_fill(&wp->w_grid, wp->w_grid.Rows - 1, wp->w_grid.Rows,
                wp->w_grid.Columns - 3, wp->w_grid.Columns, '@', '@', at_attr);
      set_empty_rows(wp, srow);
      wp->w_botline = lnum;
    } else {
      win_draw_end(wp, '@', ' ', 
# 1579 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                1
# 1579 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                    , srow, wp->w_grid.Rows, HLF_AT);
      wp->w_botline = lnum;
    }
  } else {
    if (eof) {
      wp->w_botline = buf->b_ml.ml_line_count + 1;
      j = diff_check_fill(wp, wp->w_botline);
      if (j > 0 && !wp->w_botfill) {

        if (char2cells(wp->w_p_fcs_chars.diff) > 1) {
          i = '-';
        } else {
          i = wp->w_p_fcs_chars.diff;
        }
        if (row + j > wp->w_grid.Rows) {
          j = wp->w_grid.Rows - row;
        }
        win_draw_end(wp, i, i, 
# 1596 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                              1
# 1596 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                  , row, row + (int)j, HLF_DED);
        row += j;
      }
    } else if (dollar_vcol == -1)
      wp->w_botline = lnum;



    win_draw_end(wp, wp->w_p_fcs_chars.eob, ' ', 
# 1604 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                                0
# 1604 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                     , row, wp->w_grid.Rows,
                 HLF_EOB);
  }

  if (wp->w_redr_type >= 30) {
    draw_vsep_win(wp, 0);
  }
  syn_set_timeout(
# 1611 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                 ((void *)0)
# 1611 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                     );


  wp->w_redr_type = 0;
  wp->w_old_topfill = wp->w_topfill;
  wp->w_old_botfill = wp->w_botfill;

  if (dollar_vcol == -1) {
# 1631 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
    wp->w_valid |= 0x20;
    wp->w_viewport_invalid = 
# 1632 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                            1
# 1632 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                ;
    if (wp == curwin && wp->w_botline != old_botline && !recursive) {
      recursive = 1;
      curwin->w_valid &= ~0x80;
      update_topline();
      if (must_redraw != 0) {

        i = curbuf->b_mod_set;
        curbuf->b_mod_set = 
# 1640 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                           0
# 1640 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                ;
        win_update(curwin);
        must_redraw = 0;
        curbuf->b_mod_set = i;
      }
      recursive = 0;
    }
  }


  if (!got_int)
    got_int = save_got_int;
}
# 1663 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
int win_signcol_width(win_T *wp)
{

  return 2;
}



static int win_fill_end(win_T *wp, int c1, int c2, int off, int width, int row,
                        int endrow, int attr)
{
  int nn = off + width;

  if (nn > wp->w_grid.Columns) {
    nn = wp->w_grid.Columns;
  }

  if (wp->w_onebuf_opt.wo_rl) {
    grid_fill(&wp->w_grid, row, endrow, (wp->w_wincol + wp->w_width) - nn, (wp->w_wincol + wp->w_width) - off,
              c1, c2, attr);
  } else {
    grid_fill(&wp->w_grid, row, endrow, off, nn, c1, c2, attr);
  }

  return nn;
}




static void win_draw_end(win_T *wp, int c1, int c2, 
# 1693 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                                   _Bool 
# 1693 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                        draw_margin, int row,
                         int endrow, hlf_T hl)
{
  
# 1696 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
 ((void) sizeof ((
# 1696 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
 hl >= 0 && hl < HLF_COUNT
# 1696 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
 ) ? 1 : 0), __extension__ ({ if (
# 1696 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
 hl >= 0 && hl < HLF_COUNT
# 1696 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
 ) ; else __assert_fail (
# 1696 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
 "hl >= 0 && hl < HLF_COUNT"
# 1696 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
 , "/home/toto/.env/encours/neovim/src/nvim/screen.c", 1696, __extension__ __PRETTY_FUNCTION__); }))
# 1696 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                  ;
  int n = 0;

  if (draw_margin) {

    int fdc = compute_foldcolumn(wp, 0);
    if (fdc > 0) {
      n = win_fill_end(wp, ' ', ' ', n, fdc, row, endrow,
                       win_hl_attr(wp, HLF_FC));
    }

    int count = win_signcol_count(wp);
    if (count > 0) {
      n = win_fill_end(wp, ' ', ' ', n, win_signcol_width(wp) * count, row,
                       endrow, win_hl_attr(wp, HLF_SC));
    }

    if ((wp->w_onebuf_opt.wo_nu || wp->w_onebuf_opt.wo_rnu) && vim_strchr(p_cpo, 'n') == 
# 1713 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                                                       ((void *)0)
# 1713 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                                           ) {
      n = win_fill_end(wp, ' ', ' ', n, number_width(wp) + 1, row, endrow,
                       win_hl_attr(wp, HLF_N));
    }
  }

  int attr = hl_combine_attr(wp->w_hl_attr_normal, win_hl_attr(wp, hl));

  if (wp->w_onebuf_opt.wo_rl) {
    grid_fill(&wp->w_grid, row, endrow, wp->w_wincol, (wp->w_wincol + wp->w_width) - 1 - n,
              c2, c2, attr);
    grid_fill(&wp->w_grid, row, endrow, (wp->w_wincol + wp->w_width) - 1 - n, (wp->w_wincol + wp->w_width) - n,
              c1, c2, attr);
  } else {
    grid_fill(&wp->w_grid, row, endrow, n, wp->w_grid.Columns, c1, c2, attr);
  }

  set_empty_rows(wp, row);
}





static int advance_color_col(int vcol, int **color_cols)
{
  while (**color_cols >= 0 && vcol > **color_cols)
    ++*color_cols;
  return **color_cols >= 0;
}


static int text_to_screenline(win_T *wp, char_u *text, int col, int off)
  FUNC_ATTR_NONNULL_ALL
{
  int idx = wp->w_onebuf_opt.wo_rl ? off : off + col;
  LineState s = { text, 0, 0 };

  while (*s.p != '\000') {




    const int maxcells = wp->w_grid.Columns - col - (wp->w_onebuf_opt.wo_rl ? col : 0);
    const int cells = line_putchar(&s, &linebuf_char[idx], maxcells,
                                   wp->w_onebuf_opt.wo_rl);
    if (cells == -1) {
      break;
    }
    col += cells;
    idx += cells;
  }

  return col;
}



static int compute_foldcolumn(win_T *wp, int col)
{
  int fdc = win_fdccol_count(wp);
  int wmw = wp == curwin && p_wmw == 0 ? 1 : p_wmw;
  int wwidth = wp->w_grid.Columns;

  if (fdc > wwidth - (col + wmw)) {
    fdc = wwidth - (col + wmw);
  }
  return fdc;
}




static int line_putchar(LineState *s, schar_T *dest, int maxcells, 
# 1786 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                                                  _Bool 
# 1786 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                                       rl)
{
  const char_u *p = s->p;
  int cells = utf_ptr2cells(p);
  int c_len = utfc_ptr2len(p);
  int u8c, u8cc[6];
  if (cells > maxcells) {
    return -1;
  }
  u8c = utfc_ptr2char(p, u8cc);
  if (*p < 0x80 && u8cc[0] == 0) {
    schar_from_ascii(dest[0], *p);
    s->prev_c = u8c;
  } else {
    if (p_arshape && !p_tbidi && arabic_char(u8c)) {

      int pc, pc1, nc;
      int pcc[6];
      int firstbyte = *p;



      if (rl) {
        pc = s->prev_c;
        pc1 = s->prev_c1;
        nc = utf_ptr2char(p + c_len);
        s->prev_c1 = u8cc[0];
      } else {
        pc = utfc_ptr2char(p + c_len, pcc);
        nc = s->prev_c;
        pc1 = pcc[0];
      }
      s->prev_c = u8c;

      u8c = arabic_shape(u8c, &firstbyte, &u8cc[0], pc, pc1, nc);
    } else {
      s->prev_c = u8c;
    }
    schar_from_cc(dest[0], u8c, u8cc);
  }
  if (cells > 1) {
    dest[1][0] = 0;
  }
  s->p += c_len;
  return cells;
}




static void fold_line(win_T *wp, long fold_count, foldinfo_T *foldinfo, linenr_T lnum, int row)
{
  char_u buf[FOLD_TEXT_LEN];
  pos_T *top, *bot;
  linenr_T lnume = lnum + fold_count - 1;
  int len;
  char_u *text;
  int fdc;
  int col;
  int txtcol;
  int off;
# 1856 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
  col = 0;
  off = 0;





  if (cmdwin_type != 0 && wp == curwin) {
    schar_from_ascii(linebuf_char[off], cmdwin_type);
    linebuf_attr[off] = win_hl_attr(wp, HLF_AT);
    col++;
  }
# 1884 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
  fdc = compute_foldcolumn(wp, col);
  if (fdc > 0) {
    fill_foldcolumn(buf, wp, 
# 1886 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                            1
# 1886 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                , lnum);
    const char_u *it = &buf[0];
    for (int i = 0; i < fdc; i++) {
      int mb_c = mb_ptr2char_adv(&it);
      if (wp->w_onebuf_opt.wo_rl) {
          schar_from_char(linebuf_char[off + wp->w_grid.Columns - i - 1 - col],
                          mb_c);
      } else {
        schar_from_char(linebuf_char[off + col + i], mb_c);
      }
    }
    do { if (wp->w_onebuf_opt.wo_rl) { for (int ri = 0; ri < fdc; ri++) { linebuf_attr[off + (wp->w_grid.Columns - (col) - (fdc)) + ri] = win_hl_attr(wp, HLF_FC); } } else { for (int ri = 0; ri < fdc; ri++) { linebuf_attr[off + (col) + ri] = win_hl_attr(wp, HLF_FC); } } } while (0);
    col += fdc;
  }



  do { if (wp->w_onebuf_opt.wo_rl) { for (int ri = 0; ri < wp->w_grid.Columns - col; ri++) { linebuf_attr[off + (wp->w_grid.Columns - (col) - (wp->w_grid.Columns - col)) + ri] = win_hl_attr(wp, HLF_FL); } } else { for (int ri = 0; ri < wp->w_grid.Columns - col; ri++) { linebuf_attr[off + (col) + ri] = win_hl_attr(wp, HLF_FL); } } } while (0);


  if (win_signcol_count(wp) > 0) {
      len = wp->w_grid.Columns - col;
      if (len > 0) {
          int len_max = win_signcol_width(wp) * win_signcol_count(wp);
          if (len > len_max) {
              len = len_max;
          }
          char_u space_buf[18] = "                  ";
          
# 1914 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
         ((void) sizeof ((
# 1914 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
         (size_t)len_max <= sizeof(space_buf)
# 1914 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
         ) ? 1 : 0), __extension__ ({ if (
# 1914 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
         (size_t)len_max <= sizeof(space_buf)
# 1914 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
         ) ; else __assert_fail (
# 1914 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
         "(size_t)len_max <= sizeof(space_buf)"
# 1914 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
         , "/home/toto/.env/encours/neovim/src/nvim/screen.c", 1914, __extension__ __PRETTY_FUNCTION__); }))
# 1914 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                     ;
          copy_text_attr(off + col, space_buf, len,
                         win_hl_attr(wp, HLF_FL));
          col += len;
      }
  }




  if (wp->w_onebuf_opt.wo_nu || wp->w_onebuf_opt.wo_rnu) {
    len = wp->w_grid.Columns - col;
    if (len > 0) {
      int w = number_width(wp);
      long num;
      char *fmt = "%*ld ";

      if (len > w + 1)
        len = w + 1;

      if (wp->w_onebuf_opt.wo_nu && !wp->w_onebuf_opt.wo_rnu)

        num = (long)lnum;
      else {

        num = labs((long)get_cursor_rel_lnum(wp, lnum));
        if (num == 0 && wp->w_onebuf_opt.wo_nu && wp->w_onebuf_opt.wo_rnu) {


          num = lnum;
          fmt = "%-*ld ";
        }
      }

      snprintf((char *)buf, FOLD_TEXT_LEN, fmt, w, num);
      if (wp->w_onebuf_opt.wo_rl) {

        copy_text_attr(off + wp->w_grid.Columns - len - col, buf, len,
                       win_hl_attr(wp, HLF_FL));
      } else {
        copy_text_attr(off + col, buf, len, win_hl_attr(wp, HLF_FL));
      }
      col += len;
    }
  }




  text = get_foldtext(wp, lnum, lnume, foldinfo, buf);

  txtcol = col;




  col = text_to_screenline(wp, text, col, off);


  if (wp->w_onebuf_opt.wo_rl)
    col -= txtcol;

  schar_T sc;
  schar_from_char(sc, wp->w_p_fcs_chars.fold);
  while (col < wp->w_grid.Columns
         - (wp->w_onebuf_opt.wo_rl ? txtcol : 0)
         ) {
    schar_copy(linebuf_char[off+col++], sc);
  }

  if (text != buf)
    xfree(text);





  if (VIsual_active && wp->w_buffer == curwin->w_buffer) {
    if (ltoreq(curwin->w_cursor, VIsual)) {

      top = &curwin->w_cursor;
      bot = &VIsual;
    } else {

      top = &VIsual;
      bot = &curwin->w_cursor;
    }
    if (lnum >= top->lnum
        && lnume <= bot->lnum
        && (VIsual_mode != 'v'
            || ((lnum > top->lnum
                 || (lnum == top->lnum
                     && top->col == 0))
                && (lnume < bot->lnum
                    || (lnume == bot->lnum
                        && (bot->col - (*p_sel == 'e'))
                        >= (colnr_T)strlen((char *)(ml_get_buf(wp->w_buffer, lnume, 0)))
                                       ))))) {
      if (VIsual_mode == 22) {

        if (wp->w_old_cursor_fcol + txtcol < (colnr_T)wp->w_grid.Columns) {
          if (wp->w_old_cursor_lcol != MAXCOL
              && wp->w_old_cursor_lcol + txtcol
              < (colnr_T)wp->w_grid.Columns) {
            len = wp->w_old_cursor_lcol;
          } else {
            len = wp->w_grid.Columns - txtcol;
          }
          do { if (wp->w_onebuf_opt.wo_rl) { for (int ri = 0; ri < len - (int)wp->w_old_cursor_fcol; ri++) { linebuf_attr[off + (wp->w_grid.Columns - (wp->w_old_cursor_fcol + txtcol) - (len - (int)wp->w_old_cursor_fcol)) + ri] = win_hl_attr(wp, HLF_V); } } else { for (int ri = 0; ri < len - (int)wp->w_old_cursor_fcol; ri++) { linebuf_attr[off + (wp->w_old_cursor_fcol + txtcol) + ri] = win_hl_attr(wp, HLF_V); } } } while (0)
                                                     ;
        }
      } else {

        do { if (wp->w_onebuf_opt.wo_rl) { for (int ri = 0; ri < wp->w_grid.Columns - txtcol; ri++) { linebuf_attr[off + (wp->w_grid.Columns - (txtcol) - (wp->w_grid.Columns - txtcol)) + ri] = win_hl_attr(wp, HLF_V); } } else { for (int ri = 0; ri < wp->w_grid.Columns - txtcol; ri++) { linebuf_attr[off + (txtcol) + ri] = win_hl_attr(wp, HLF_V); } } } while (0);
      }
    }
  }


  if (wp->w_p_cc_cols) {
    int i = 0;
    int j = wp->w_p_cc_cols[i];
    int old_txtcol = txtcol;

    while (j > -1) {
      txtcol += j;
      if (wp->w_onebuf_opt.wo_wrap) {
        txtcol -= wp->w_skipcol;
      } else {
        txtcol -= wp->w_leftcol;
      }
      if (txtcol >= 0 && txtcol < wp->w_grid.Columns) {
        linebuf_attr[off + txtcol] =
          hl_combine_attr(linebuf_attr[off + txtcol], win_hl_attr(wp, HLF_MC));
      }
      txtcol = old_txtcol;
      j = wp->w_p_cc_cols[++i];
    }
  }


  if (wp->w_onebuf_opt.wo_cuc) {
    txtcol += wp->w_virtcol;
    if (wp->w_onebuf_opt.wo_wrap)
      txtcol -= wp->w_skipcol;
    else
      txtcol -= wp->w_leftcol;
    if (txtcol >= 0 && txtcol < wp->w_grid.Columns) {
      linebuf_attr[off + txtcol] = hl_combine_attr(
          linebuf_attr[off + txtcol], win_hl_attr(wp, HLF_CUC));
    }
  }

  grid_put_linebuf(&wp->w_grid, row, 0, wp->w_grid.Columns, wp->w_grid.Columns,
                   
# 2068 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                  0
# 2068 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                       , wp, wp->w_hl_attr_normal, 
# 2068 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                                   0
# 2068 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                        );





  if (wp == curwin
      && lnum <= curwin->w_cursor.lnum
      && lnume >= curwin->w_cursor.lnum) {
    curwin->w_cline_row = row;
    curwin->w_cline_height = 1;
    curwin->w_cline_folded = 
# 2079 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                            1
# 2079 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                ;
    curwin->w_valid |= (0x08|0x10);
    conceal_cursor_used = conceal_cursor_line(curwin);
  }
}





static void copy_text_attr(int off, char_u *buf, int len, int attr)
{
  int i;

  for (i = 0; i < len; i++) {
    schar_from_ascii(linebuf_char[off + i], buf[i]);
    linebuf_attr[off + i] = attr;
  }
}
# 2108 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
static size_t
fill_foldcolumn(
    char_u *p,
    win_T *wp,
    int closed,
    linenr_T lnum
)
{
  int i = 0;
  int level;
  int first_level;
  int fdc = compute_foldcolumn(wp, 0);
  size_t char_counter = 0;
  int symbol = 0;
  int len = 0;

  memset(p, ' ', 6 * fdc + 1);

  level = win_foldinfo.fi_level;



  first_level = level - fdc - closed + 1;
  if (first_level < 1) {
    first_level = 1;
  }

  for (i = 0; i < 
# 2135 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                  (((
# 2135 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                  fdc
# 2135 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                  )<(
# 2135 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                  level
# 2135 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                  ))?(
# 2135 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                  fdc
# 2135 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                  ):(
# 2135 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                  level
# 2135 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                  ))
# 2135 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                 ; i++) {
    if (win_foldinfo.fi_lnum == lnum
        && first_level + i >= win_foldinfo.fi_low_level) {
      symbol = wp->w_p_fcs_chars.foldopen;
    } else if (first_level == 1) {
      symbol = wp->w_p_fcs_chars.foldsep;
    } else if (first_level + i <= 9) {
      symbol = '0' + first_level + i;
    } else {
      symbol = '>';
    }

    len = utf_char2bytes(symbol, &p[char_counter]);
    char_counter += len;
    if (first_level + i >= level) {
      i++;
      break;
    }
  }

  if (closed) {
    if (symbol != 0) {

      char_counter -= len;
      memset(&p[char_counter], ' ', len);
    }
    len = utf_char2bytes(wp->w_p_fcs_chars.foldclosed, &p[char_counter]);
    char_counter += len;
  }

  return 
# 2165 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
        (((
# 2165 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
        char_counter + (fdc-i)
# 2165 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
        )>(
# 2165 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
        (size_t)fdc
# 2165 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
        ))?(
# 2165 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
        char_counter + (fdc-i)
# 2165 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
        ):(
# 2165 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
        (size_t)fdc
# 2165 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
        ))
# 2165 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                ;
}
# 2175 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
static int
win_line (
    win_T *wp,
    linenr_T lnum,
    int startrow,
    int endrow,
    
# 2181 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
   _Bool 
# 2181 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
        nochange,
    
# 2182 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
   _Bool 
# 2182 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
        number_only
)
{
  int c = 0;
  long vcol = 0;
  long vcol_sbr = -1;
  long vcol_prev = -1;
  char_u *line;
  char_u *ptr;
  int row;
  ScreenGrid *grid = &wp->w_grid;

  char_u extra[57];

  int n_extra = 0;
  char_u *p_extra = 
# 2197 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                        ((void *)0)
# 2197 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                            ;
  char_u *p_extra_free = 
# 2198 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                             ((void *)0)
# 2198 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                 ;
  int c_extra = '\000';
  int c_final = '\000';
  int extra_attr = 0;
  static char_u *at_end_str = (char_u *)"";


  int lcs_eol_one = wp->w_p_lcs_chars.eol;
  int lcs_prec_todo = wp->w_p_lcs_chars.prec;


  int saved_n_extra = 0;
  char_u *saved_p_extra = 
# 2210 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                              ((void *)0)
# 2210 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                  ;
  int saved_c_extra = 0;
  int saved_c_final = 0;
  int saved_char_attr = 0;

  int n_attr = 0;
  int saved_attr2 = 0;
  int n_attr3 = 0;
  int saved_attr3 = 0;

  int n_skip = 0;

  int fromcol = -10;
  int tocol = MAXCOL;
  int fromcol_prev = -2;
  
# 2225 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
 _Bool 
# 2225 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
      noinvcur = 
# 2225 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                 0
# 2225 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                      ;
  int lnum_in_visual_area = 
# 2226 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                           0
# 2226 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                ;
  pos_T pos;
  long v;

  int char_attr = 0;
  int attr_pri = 0;
  int area_highlighting = 0;

  int attr = 0;
  int area_attr = 0;
  int search_attr = 0;
  int vcol_save_attr = 0;
  int syntax_attr = 0;
  int has_syntax = 0;
  int save_did_emsg;
  int eol_hl_off = 0;
  int draw_color_col = 
# 2242 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                      0
# 2242 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                           ;
  int *color_cols = 
# 2243 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                   ((void *)0)
# 2243 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                       ;
  
# 2244 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
 _Bool 
# 2244 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
      has_spell = 
# 2244 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                  0
# 2244 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                       ;

  char_u nextline[150 * 2];
  int nextlinecol = 0;
  int nextline_idx = 0;

  int spell_attr = 0;
  int word_end = 0;
  static linenr_T checked_lnum = 0;
  static int checked_col = 0;

  static int cap_col = -1;
  static linenr_T capcol_lnum = 0;
  int cur_checked_col = 0;
  int extra_check = 0;
  int multi_attr = 0;
  int mb_l = 1;
  int mb_c = 0;
  
# 2262 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
 _Bool 
# 2262 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
      mb_utf8 = 
# 2262 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                0
# 2262 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                     ;
  int u8cc[6];
  int filler_lines;
  int filler_todo;
  hlf_T diff_hlf = (hlf_T)0;
  int change_start = MAXCOL;
  int change_end = -1;
  colnr_T trailcol = MAXCOL;
  
# 2270 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
 _Bool 
# 2270 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
      need_showbreak = 
# 2270 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                       0
# 2270 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                            ;
  int line_attr = 0;
  int line_attr_lowprio = 0;
  matchitem_T *cur;
  match_T *shl;
  int shl_flag;

  
# 2277 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
 _Bool 
# 2277 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
      prevcol_hl_flag;


  int prev_c = 0;
  int prev_c1 = 0;

  
# 2283 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
 _Bool 
# 2283 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
      search_attr_from_match = 
# 2283 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                               0
# 2283 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                    ;
  
# 2284 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
 _Bool 
# 2284 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
      has_decorations = 
# 2284 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                        0
# 2284 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                             ;
  
# 2285 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
 _Bool 
# 2285 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
      do_virttext = 
# 2285 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                    0
# 2285 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                         ;
# 2296 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
  int draw_state = 0;

  int syntax_flags = 0;
  int syntax_seqnr = 0;
  int prev_syntax_id = 0;
  int conceal_attr = win_hl_attr(wp, HLF_CONCEAL);
  int is_concealing = 
# 2302 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                       0
# 2302 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                            ;
  int boguscols = 0;

  int vcol_off = 0;
  int did_wcol = 
# 2306 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                       0
# 2306 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                            ;
  int match_conc = 0;
  int old_boguscols = 0;
# 2320 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
  if (startrow > endrow)
    return startrow;

  row = startrow;

  char *luatext = 
# 2325 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                 ((void *)0)
# 2325 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                     ;

  buf_T *buf = wp->w_buffer;

  if (!number_only) {


    extra_check = wp->w_onebuf_opt.wo_lbr;
    if (syntax_present(wp) && !wp->w_s->b_syn_error && !wp->w_s->b_syn_slow) {


      save_did_emsg = did_emsg;
      did_emsg = 
# 2337 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                0
# 2337 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                     ;
      syntax_start(wp, lnum);
      if (did_emsg) {
        wp->w_s->b_syn_error = 
# 2340 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                              1
# 2340 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                  ;
      } else {
        did_emsg = save_did_emsg;
        if (!wp->w_s->b_syn_slow) {
          has_syntax = 
# 2344 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                      1
# 2344 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                          ;
          extra_check = 
# 2345 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                       1
# 2345 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                           ;
        }
      }
    }

    if (decorations_active) {
      if (buf->b_luahl && buf->b_luahl_line != (-2)) {
        Error err = { .type = kErrorTypeNone, .msg = 
# 2352 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                   ((void *)0) 
# 2352 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                   };
        Array args = {.size = 0, .capacity = 0, .items = 
# 2353 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
       ((void *)0)
# 2353 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
       }; Object args__items[3]; args.size = 3; args.items = args__items;;
        args.items[0] = ((Object) { .type = kObjectTypeWindow, .data.integer = wp->handle });
        args.items[1] = ((Object) { .type = kObjectTypeBuffer, .data.integer = buf->handle });
        args.items[2] = ((Object) { .type = kObjectTypeInteger, .data.integer = lnum-1 });
        lua_attr_active = 
# 2357 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                         1
# 2357 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                             ;
        extra_check = 
# 2358 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                     1
# 2358 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                         ;
        Object o = executor_exec_lua_cb(buf->b_luahl_line, "line",
                                        args, 
# 2360 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                             1
# 2360 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                 , &err);
        lua_attr_active = 
# 2361 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                         0
# 2361 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                              ;
        if (o.type == kObjectTypeString) {


          luatext = o.data.string.data;
          do_virttext = 
# 2366 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                       1
# 2366 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                           ;
        } else if (((&err)->type != kErrorTypeNone)) {
          logmsg(3, 
# 2368 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
         ((void *)0)
# 2368 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
         , __func__, 2368, 
# 2368 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
         1
# 2368 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
         , "error in luahl line: %s", err.msg);
          luatext = err.msg;
          do_virttext = 
# 2370 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                       1
# 2370 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                           ;
        }
      }

      has_decorations = decorations_redraw_line(wp->w_buffer, lnum-1,
                                                &decorations);
      if (has_decorations) {
        extra_check = 
# 2377 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                     1
# 2377 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                         ;
      }
    }


    color_cols = wp->w_buffer->terminal ? 
# 2382 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                         ((void *)0) 
# 2382 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                              : wp->w_p_cc_cols;
    if (color_cols != 
# 2383 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                     ((void *)0)
# 2383 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                         ) {
      draw_color_col = advance_color_col((vcol - vcol_off), &color_cols);
    }

    if (wp->w_onebuf_opt.wo_spell
        && *wp->w_s->b_p_spl != '\000'
        && !((&wp->w_s->b_langp)->ga_len <= 0)
        && *(char **)(wp->w_s->b_langp.ga_data) != 
# 2390 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                                  ((void *)0)
# 2390 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                      ) {

      has_spell = 
# 2392 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                 1
# 2392 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                     ;
      extra_check = 
# 2393 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                   1
# 2393 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                       ;




      nextline[150] = '\000';
      if (lnum < wp->w_buffer->b_ml.ml_line_count) {
        line = ml_get_buf(wp->w_buffer, lnum + 1, 
# 2400 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                                 0
# 2400 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                      );
        spell_cat_line(nextline + 150, line, 150);
      }



      if (lnum == checked_lnum) {
        cur_checked_col = checked_col;
      }
      checked_lnum = 0;




      if (lnum != capcol_lnum) {
        cap_col = -1;
      }
      if (lnum == 1) {
        cap_col = 0;
      }
      capcol_lnum = 0;
    }


    if (VIsual_active && wp->w_buffer == curwin->w_buffer) {
      pos_T *top, *bot;

      if (ltoreq(curwin->w_cursor, VIsual)) {

        top = &curwin->w_cursor;
        bot = &VIsual;
      } else {

        top = &VIsual;
        bot = &curwin->w_cursor;
      }
      lnum_in_visual_area = (lnum >= top->lnum && lnum <= bot->lnum);
      if (VIsual_mode == 22) {

        if (lnum_in_visual_area) {
          fromcol = wp->w_old_cursor_fcol;
          tocol = wp->w_old_cursor_lcol;
        }
      } else {

        if (lnum > top->lnum && lnum <= bot->lnum) {
          fromcol = 0;
        } else if (lnum == top->lnum) {
          if (VIsual_mode == 'V') {
            fromcol = 0;
          } else {
            getvvcol(wp, top, (colnr_T *)&fromcol, 
# 2451 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                                  ((void *)0)
# 2451 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                      , 
# 2451 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                                        ((void *)0)
# 2451 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                            );
            if (gchar_pos(top) == '\000') {
              tocol = fromcol + 1;
            }
          }
        }
        if (VIsual_mode != 'V' && lnum == bot->lnum) {
          if (*p_sel == 'e' && bot->col == 0
              && bot->coladd == 0) {
            fromcol = -10;
            tocol = MAXCOL;
          } else if (bot->col == MAXCOL) {
            tocol = MAXCOL;
          } else {
            pos = *bot;
            if (*p_sel == 'e') {
              getvvcol(wp, &pos, (colnr_T *)&tocol, 
# 2467 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                                   ((void *)0)
# 2467 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                       , 
# 2467 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                                         ((void *)0)
# 2467 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                             );
            } else {
              getvvcol(wp, &pos, 
# 2469 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                ((void *)0)
# 2469 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                    , 
# 2469 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                      ((void *)0)
# 2469 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                          , (colnr_T *)&tocol);
              tocol++;
            }
          }
        }
      }


      if (!highlight_match && lnum == curwin->w_cursor.lnum && wp == curwin
          && cursor_is_block_during_visual(*p_sel == 'e')) {
        noinvcur = 
# 2479 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                  1
# 2479 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                      ;
      }


      if (fromcol >= 0) {
        area_highlighting = 
# 2484 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                           1
# 2484 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                               ;
        attr = win_hl_attr(wp, HLF_V);
      }

    } else if (highlight_match
               && wp == curwin
               && lnum >= curwin->w_cursor.lnum
               && lnum <= curwin->w_cursor.lnum + search_match_lines) {
      if (lnum == curwin->w_cursor.lnum) {
        getvcol(curwin, &(curwin->w_cursor),
                (colnr_T *)&fromcol, 
# 2494 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                    ((void *)0)
# 2494 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                        , 
# 2494 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                          ((void *)0)
# 2494 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                              );
      } else {
        fromcol = 0;
      }
      if (lnum == curwin->w_cursor.lnum + search_match_lines) {
        pos.lnum = lnum;
        pos.col = search_match_endcol;
        getvcol(curwin, &pos, (colnr_T *)&tocol, 
# 2501 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                                ((void *)0)
# 2501 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                    , 
# 2501 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                                      ((void *)0)
# 2501 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                          );
      }

      if (fromcol == tocol) {
        tocol = fromcol + 1;
      }
      area_highlighting = 
# 2507 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                         1
# 2507 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                             ;
      attr = win_hl_attr(wp, HLF_I);
    }
  }

  filler_lines = diff_check(wp, lnum);
  if (filler_lines < 0) {
    if (filler_lines == -1) {
      if (diff_find_change(wp, lnum, &change_start, &change_end))
        diff_hlf = HLF_ADD;
      else if (change_start == 0)
        diff_hlf = HLF_TXD;
      else
        diff_hlf = HLF_CHD;
    } else
      diff_hlf = HLF_ADD;
    filler_lines = 0;
    area_highlighting = 1;
  }
  if (lnum == wp->w_topline)
    filler_lines = wp->w_topfill;
  filler_todo = filler_lines;


  if (lnum == wp->w_cursor.lnum) {


    if (wp->w_onebuf_opt.wo_cul && !(wp == curwin && VIsual_active)) {
      int cul_attr = win_hl_attr(wp, HLF_CUL);
      HlAttrs ae = syn_attr2entry(cul_attr);




      if (ae.rgb_fg_color == -1 && ae.cterm_fg_color == 0) {
        line_attr_lowprio = cul_attr;
      } else {
        if (!(State & 0x10) && bt_quickfix(wp->w_buffer)
            && qf_current_entry(wp) == lnum) {
          line_attr = hl_combine_attr(cul_attr, line_attr);
        } else {
          line_attr = cul_attr;
        }
      }
    }

    wp->w_last_cursorline = wp->w_cursor.lnum;
  }


  v = buf_getsigntype(wp->w_buffer, lnum, SIGN_LINEHL, 0, 1);
  if (v != 0) {
    line_attr = sign_get_attr((int)v, SIGN_LINEHL);
  }


  if (bt_quickfix(wp->w_buffer) && qf_current_entry(wp) == lnum) {
    line_attr = win_hl_attr(wp, HLF_QFL);
  }

  if (line_attr_lowprio || line_attr) {
    area_highlighting = 
# 2568 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                       1
# 2568 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                           ;
  }

  line = ml_get_buf(wp->w_buffer, lnum, 0);
  ptr = line;

  if (has_spell && !number_only) {

    if (cap_col == 0) {
      cap_col = (int)getwhitecols(line);
    }




    if (nextline[150] == '\000') {

      nextlinecol = MAXCOL;
      nextline_idx = 0;
    } else {
      v = (long)strlen((char *)(line));
      if (v < 150) {


        nextlinecol = 0;
        memmove(nextline, line, (size_t)v);
        memmove((nextline + v), (nextline + 150), strlen((char *)(nextline + 150)) + 1);
        nextline_idx = v + 1;
      } else {

        nextlinecol = v - 150;
        memmove(nextline, line + nextlinecol, 150);
        nextline_idx = 150 + 1;
      }
    }
  }

  if (wp->w_onebuf_opt.wo_list) {
    if (curwin->w_p_lcs_chars.space
        || wp->w_p_lcs_chars.trail
        || wp->w_p_lcs_chars.nbsp) {
      extra_check = 
# 2609 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                   1
# 2609 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                       ;
    }

    if (wp->w_p_lcs_chars.trail) {
      trailcol = (colnr_T)strlen((char *)(ptr));
      while (trailcol > (colnr_T)0 && ascii_iswhite(ptr[trailcol - 1])) {
        trailcol--;
      }
      trailcol += (colnr_T) (ptr - line);
    }
  }





  if (wp->w_onebuf_opt.wo_wrap)
    v = wp->w_skipcol;
  else
    v = wp->w_leftcol;
  if (v > 0 && !number_only) {
    char_u *prev_ptr = ptr;
    while (vcol < v && *ptr != '\000') {
      c = win_lbr_chartabsize(wp, line, ptr, (colnr_T)vcol, 
# 2632 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                                           ((void *)0)
# 2632 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                               );
      vcol += c;
      prev_ptr = ptr;
      (ptr += utfc_ptr2len((char_u *)ptr));
    }







    if (vcol < v && (wp->w_onebuf_opt.wo_cuc
                     || draw_color_col
                     || virtual_active()
                     || (VIsual_active && wp->w_buffer == curwin->w_buffer))) {
      vcol = v;
    }



    if (vcol > v) {
      vcol -= c;
      ptr = prev_ptr;


      if (utf_ptr2cells(ptr) >= c || *ptr == '\011') {
        n_skip = v - vcol;
      }
    }





    if (tocol <= vcol)
      fromcol = 0;
    else if (fromcol >= 0 && fromcol < vcol)
      fromcol = vcol;


    if (wp->w_onebuf_opt.wo_wrap) {
      need_showbreak = 
# 2674 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                      1
# 2674 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                          ;
    }


    if (has_spell) {
      size_t len;
      colnr_T linecol = (colnr_T)(ptr - line);
      hlf_T spell_hlf = HLF_COUNT;

      pos = wp->w_cursor;
      wp->w_cursor.lnum = lnum;
      wp->w_cursor.col = linecol;
      len = spell_move_to(wp, FORWARD, 1, 1, &spell_hlf);


      line = ml_get_buf(wp->w_buffer, lnum, 0);
      ptr = line + linecol;

      if (len == 0 || (int)wp->w_cursor.col > ptr - line) {


        spell_hlf = HLF_COUNT;
        word_end = (int)(spell_to_word_end(ptr, wp) - line + 1);
      } else {

        
# 2699 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
       ((void) sizeof ((
# 2699 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
       len <= 0x7fffffff
# 2699 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
       ) ? 1 : 0), __extension__ ({ if (
# 2699 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
       len <= 0x7fffffff
# 2699 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
       ) ; else __assert_fail (
# 2699 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
       "len <= INT_MAX"
# 2699 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
       , "/home/toto/.env/encours/neovim/src/nvim/screen.c", 2699, __extension__ __PRETTY_FUNCTION__); }))
# 2699 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                             ;
        word_end = wp->w_cursor.col + (int)len + 1;


        if (spell_hlf != HLF_COUNT)
          spell_attr = highlight_attr[spell_hlf];
      }
      wp->w_cursor = pos;


      if (has_syntax) {
        syntax_start(wp, lnum);
      }
    }
  }





  if (fromcol >= 0) {
    if (noinvcur) {
      if ((colnr_T)fromcol == wp->w_virtcol) {


        fromcol_prev = fromcol;
        fromcol = -1;
      } else if ((colnr_T)fromcol < wp->w_virtcol)

        fromcol_prev = wp->w_virtcol;
    }
    if (fromcol >= tocol)
      fromcol = -1;
  }





  cur = wp->w_match_head;
  shl_flag = 
# 2739 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
            0
# 2739 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                 ;
  while ((cur != 
# 2740 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                ((void *)0) 
# 2740 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                     || !shl_flag) && !number_only) {
    if (!shl_flag) {
      shl = &search_hl;
      shl_flag = 
# 2743 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                1
# 2743 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                    ;
    } else {
      shl = &cur->hl;
    }
    shl->startcol = MAXCOL;
    shl->endcol = MAXCOL;
    shl->attr_cur = 0;
    shl->is_addpos = 
# 2750 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                    0
# 2750 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                         ;
    v = (long)(ptr - line);
    if (cur != 
# 2752 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
              ((void *)0)
# 2752 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                  ) {
      cur->pos.cur = 0;
    }
    next_search_hl(wp, shl, lnum, (colnr_T)v,
                   shl == &search_hl ? 
# 2756 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                      ((void *)0) 
# 2756 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                           : cur);
    if (wp->w_s->b_syn_slow) {
      has_syntax = 
# 2758 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                  0
# 2758 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                       ;
    }



    line = ml_get_buf(wp->w_buffer, lnum, 
# 2763 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                         0
# 2763 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                              );
    ptr = line + v;

    if (shl->lnum != 0 && shl->lnum <= lnum) {
      if (shl->lnum == lnum) {
        shl->startcol = shl->rm.startpos[0].col;
      } else {
        shl->startcol = 0;
      }
      if (lnum == shl->lnum + shl->rm.endpos[0].lnum
                  - shl->rm.startpos[0].lnum) {
          shl->endcol = shl->rm.endpos[0].col;
      } else {
          shl->endcol = MAXCOL;
      }

      if (shl->startcol == shl->endcol) {
          if (line[shl->endcol] != '\000') {
              shl->endcol += (*utfc_ptr2len)(line + shl->endcol);
          } else {
              ++shl->endcol;
          }
      }
      if ((long)shl->startcol < v) {
        shl->attr_cur = shl->attr;
        search_attr = shl->attr;
        search_attr_from_match = shl != &search_hl;
      }
      area_highlighting = 
# 2791 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                         1
# 2791 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                             ;
    }
    if (shl != &search_hl && cur != 
# 2793 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                   ((void *)0)
# 2793 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                       )
      cur = cur->next;
  }

  unsigned off = 0;
  int col = 0;
  if (wp->w_onebuf_opt.wo_rl) {



    col = grid->Columns - 1;
    off += col;
  }


  int term_attrs[1024] = {0};
  if (wp->w_buffer->terminal) {
    terminal_get_line_attributes(wp->w_buffer->terminal, wp, lnum, term_attrs);
    extra_check = 
# 2811 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                 1
# 2811 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                     ;
  }

  int sign_idx = 0;

  for (;; ) {
    int has_match_conc = 0;
    
# 2818 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
   _Bool 
# 2818 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
        did_decrement_ptr = 
# 2818 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                            0
# 2818 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                 ;

    if (draw_state != 0 + 1 + 1 + 1 + 1 + 1 + 1 + 1) {
      if (draw_state == 0 + 1 - 1 && n_extra == 0) {
        draw_state = 0 + 1;
        if (cmdwin_type != 0 && wp == curwin) {

          n_extra = 1;
          c_extra = cmdwin_type;
          c_final = '\000';
          char_attr = win_hl_attr(wp, HLF_AT);
        }
      }

      if (draw_state == 0 + 1 + 1 - 1 && n_extra == 0) {
        int fdc = compute_foldcolumn(wp, 0);

        draw_state = 0 + 1 + 1;
        if (fdc > 0) {


          xfree(p_extra_free);
          p_extra_free = xmalloc(6 * fdc + 1);
          n_extra = fill_foldcolumn(p_extra_free, wp, 
# 2841 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                                     0
# 2841 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                          , lnum);
          p_extra_free[n_extra] = '\000';
          p_extra = p_extra_free;
          c_extra = '\000';
          c_final = '\000';
          char_attr = win_hl_attr(wp, HLF_FC);
        }
      }


      if (draw_state == 0 + 1 + 1 + 1 - 1 && n_extra == 0) {
          draw_state = 0 + 1 + 1 + 1;


          int count = win_signcol_count(wp);
          if (count > 0) {
              int text_sign;

              c_extra = ' ';
              c_final = '\000';
              char_attr = win_hl_attr(wp, HLF_SC);
              n_extra = win_signcol_width(wp);

              if (row == startrow + filler_lines && filler_todo <= 0) {
                  text_sign = buf_getsigntype(wp->w_buffer, lnum, SIGN_TEXT,
                                              sign_idx, count);
                  if (text_sign != 0) {
                      p_extra = sign_get_text(text_sign);
                      if (p_extra != 
# 2869 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                    ((void *)0)
# 2869 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                        ) {
                          int symbol_blen = (int)strlen((char *)(p_extra));

                          c_extra = '\000';
                          c_final = '\000';



                          
# 2877 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                         ((void) sizeof ((
# 2877 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                         (size_t)win_signcol_width(wp) >= mb_string2cells(p_extra)
# 2877 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                         ) ? 1 : 0), __extension__ ({ if (
# 2877 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                         (size_t)win_signcol_width(wp) >= mb_string2cells(p_extra)
# 2877 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                         ) ; else __assert_fail (
# 2877 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                         "(size_t)win_signcol_width(wp) >= mb_string2cells(p_extra)"
# 2877 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                         ,
                                                            "/home/toto/.env/encours/neovim/src/nvim/screen.c"
# 2877 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                          ,
                                                            2878
# 2877 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                          , __extension__ __PRETTY_FUNCTION__); }))
                                                             
# 2878 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                            ;

                          n_extra = symbol_blen +
                            (win_signcol_width(wp) - mb_string2cells(p_extra));

                          
# 2883 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                         ((void) sizeof ((
# 2883 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                         sizeof(extra) > (size_t)symbol_blen
# 2883 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                         ) ? 1 : 0), __extension__ ({ if (
# 2883 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                         sizeof(extra) > (size_t)symbol_blen
# 2883 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                         ) ; else __assert_fail (
# 2883 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                         "sizeof(extra) > (size_t)symbol_blen"
# 2883 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                         , "/home/toto/.env/encours/neovim/src/nvim/screen.c", 2883, __extension__ __PRETTY_FUNCTION__); }))
# 2883 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                                    ;
                          memset(extra, ' ', sizeof(extra));
                          memcpy(extra, p_extra, symbol_blen);

                          p_extra = extra;
                          p_extra[n_extra] = '\000';
                      }
                      char_attr = sign_get_attr(text_sign, SIGN_TEXT);
                  }
              }

              sign_idx++;
              if (sign_idx < count) {
                  draw_state = 0 + 1 + 1 + 1 - 1;
              }
          }
      }

      if (draw_state == 0 + 1 + 1 + 1 + 1 - 1 && n_extra == 0) {
        draw_state = 0 + 1 + 1 + 1 + 1;


        if ((wp->w_onebuf_opt.wo_nu || wp->w_onebuf_opt.wo_rnu)
            && (row == startrow
                + filler_lines
                || vim_strchr(p_cpo, 'n') == 
# 2908 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                                   ((void *)0)
# 2908 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                       )) {

          if (row == startrow
              + filler_lines
              ) {
            long num;
            char *fmt = "%*ld ";

            if (wp->w_onebuf_opt.wo_nu && !wp->w_onebuf_opt.wo_rnu)

              num = (long)lnum;
            else {

              num = labs((long)get_cursor_rel_lnum(wp, lnum));
              if (num == 0 && wp->w_onebuf_opt.wo_nu && wp->w_onebuf_opt.wo_rnu) {

                num = lnum;
                fmt = "%-*ld ";
              }
            }

            sprintf((char *)extra, fmt,
                number_width(wp), num);
            if (wp->w_skipcol > 0)
              for (p_extra = extra; *p_extra == ' '; ++p_extra)
                *p_extra = '-';
            if (wp->w_onebuf_opt.wo_rl) {

              char_u *p2 = skiptowhite(extra) - 1;
              for (char_u *p1 = extra; p1 < p2; p1++, p2--) {
                const int t = *p1;
                *p1 = *p2;
                *p2 = t;
              }
            }
            p_extra = extra;
            c_extra = '\000';
            c_final = '\000';
          } else {
            c_extra = ' ';
            c_final = '\000';
          }
          n_extra = number_width(wp) + 1;
          char_attr = win_hl_attr(wp, HLF_N);

          int num_sign = buf_getsigntype(wp->w_buffer, lnum, SIGN_NUMHL,
                                         0, 1);
          if (num_sign != 0) {

            char_attr = sign_get_attr(num_sign, SIGN_NUMHL);
          } else if ((wp->w_onebuf_opt.wo_cul || wp->w_onebuf_opt.wo_rnu)
                     && lnum == wp->w_cursor.lnum) {




            char_attr = win_hl_attr(wp, HLF_CLN);
          }
        }
      }

      if (wp->w_briopt_sbr && draw_state == 0 + 1 + 1 + 1 + 1 + 1 - 1
          && n_extra == 0 && *p_sbr != '\000') {

        draw_state = 0 + 1 + 1 + 1 + 1 + 1;
      } else if (wp->w_briopt_sbr && draw_state == 0 + 1 + 1 + 1 + 1 + 1 + 1 && n_extra == 0) {

        draw_state = 0 + 1 + 1 + 1 + 1 + 1 - 1;
      }


      if (draw_state == 0 + 1 + 1 + 1 + 1 + 1 - 1 && n_extra == 0) {
        draw_state = 0 + 1 + 1 + 1 + 1 + 1;

        if (wp->w_onebuf_opt.wo_bri && (row != startrow || need_showbreak)
            && filler_lines == 0) {
          char_attr = 0;

          if (diff_hlf != (hlf_T)0) {
            char_attr = win_hl_attr(wp, diff_hlf);
            if (wp->w_onebuf_opt.wo_cul && lnum == wp->w_cursor.lnum) {
              char_attr = hl_combine_attr(char_attr, win_hl_attr(wp, HLF_CUL));
            }
          }
          p_extra = 
# 2992 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                   ((void *)0)
# 2992 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                       ;
          c_extra = ' ';
          c_final = '\000';
          n_extra =
            get_breakindent_win(wp, ml_get_buf(wp->w_buffer, lnum, 
# 2996 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                                                  0
# 2996 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                                       ));
          if (row == startrow) {
            n_extra -= win_col_off2(wp);
            if (n_extra < 0) {
              n_extra = 0;
            }
          }
          if (wp->w_skipcol > 0 && wp->w_onebuf_opt.wo_wrap && wp->w_briopt_sbr) {
            need_showbreak = 
# 3004 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                            0
# 3004 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                 ;
          }


          if (tocol == vcol) {
            tocol += n_extra;
          }
        }
      }

      if (draw_state == 0 + 1 + 1 + 1 + 1 + 1 + 1 - 1 && n_extra == 0) {
        draw_state = 0 + 1 + 1 + 1 + 1 + 1 + 1;
        if (filler_todo > 0) {

          if (char2cells(wp->w_p_fcs_chars.diff) > 1) {
            c_extra = '-';
            c_final = '\000';
          } else {
            c_extra = wp->w_p_fcs_chars.diff;
            c_final = '\000';
          }
          if (wp->w_onebuf_opt.wo_rl) {
            n_extra = col + 1;
          } else {
            n_extra = grid->Columns - col;
          }
          char_attr = win_hl_attr(wp, HLF_DED);
        }
        if (*p_sbr != '\000' && need_showbreak) {

          p_extra = p_sbr;
          c_extra = '\000';
          c_final = '\000';
          n_extra = (int)strlen((char *)(p_sbr));
          char_attr = win_hl_attr(wp, HLF_AT);
          if (wp->w_skipcol == 0 || !wp->w_onebuf_opt.wo_wrap) {
            need_showbreak = 
# 3040 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                            0
# 3040 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                 ;
          }
          vcol_sbr = vcol + mb_charlen(p_sbr);


          if (tocol == vcol)
            tocol += n_extra;

          if (wp->w_onebuf_opt.wo_cul && lnum == wp->w_cursor.lnum) {
            char_attr = hl_combine_attr(char_attr, win_hl_attr(wp, HLF_CUL));
          }
        }
      }

      if (draw_state == 0 + 1 + 1 + 1 + 1 + 1 + 1 + 1 - 1 && n_extra == 0) {
        sign_idx = 0;
        draw_state = 0 + 1 + 1 + 1 + 1 + 1 + 1 + 1;
        if (saved_n_extra) {

          n_extra = saved_n_extra;
          c_extra = saved_c_extra;
          c_final = saved_c_final;
          p_extra = saved_p_extra;
          char_attr = saved_char_attr;
        } else {
          char_attr = 0;
        }
      }
    }


    if ((dollar_vcol >= 0 && wp == curwin
         && lnum == wp->w_cursor.lnum && vcol >= (long)wp->w_virtcol
         && filler_todo <= 0)
        || (number_only && draw_state > 0 + 1 + 1 + 1 + 1)) {
      grid_put_linebuf(grid, row, 0, col, -grid->Columns, wp->w_onebuf_opt.wo_rl, wp,
                       wp->w_hl_attr_normal, 
# 3076 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                            0
# 3076 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                 );


      if (wp->w_onebuf_opt.wo_cuc) {
        row = wp->w_cline_row + wp->w_cline_height;
      } else {
        row = grid->Rows;
      }
      break;
    }

    if (draw_state == 0 + 1 + 1 + 1 + 1 + 1 + 1 + 1 && (area_highlighting || has_spell)) {

      if (vcol == fromcol
          || (vcol + 1 == fromcol && n_extra == 0
              && utf_ptr2cells(ptr) > 1)
          || ((int)vcol_prev == fromcol_prev
              && vcol_prev < vcol
              && vcol < tocol)) {
        area_attr = attr;
      } else if (area_attr != 0 && (vcol == tocol
                                    || (noinvcur
                                        && (colnr_T)vcol == wp->w_virtcol))) {
        area_attr = 0;
     }

      if (!n_extra) {
# 3111 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
        v = (long)(ptr - line);
        cur = wp->w_match_head;
        shl_flag = 0;
        while (cur != 
# 3114 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                     ((void *)0) 
# 3114 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                          || shl_flag == 0) {
          if (shl_flag == 0
              && ((cur != 
# 3116 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                         ((void *)0)
                   
# 3117 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                  && cur->priority > 0)
                  || cur == 
# 3118 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                           ((void *)0)
# 3118 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                               )) {
            shl = &search_hl;
            shl_flag = 1;
          } else
            shl = &cur->hl;
          if (cur != 
# 3123 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                    ((void *)0)
# 3123 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                        ) {
            cur->pos.cur = 0;
          }
          
# 3126 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
         _Bool 
# 3126 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
              pos_inprogress = 
# 3126 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                               1
# 3126 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                   ;

          while (shl->rm.regprog != 
# 3128 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                   ((void *)0)
                                 
# 3129 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                || (cur != 
# 3129 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                           ((void *)0) 
# 3129 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                && pos_inprogress)) {
            if (shl->startcol != MAXCOL
                && v >= (long)shl->startcol
                && v < (long)shl->endcol) {
              int tmp_col = v + utfc_ptr2len(ptr);

              if (shl->endcol < tmp_col) {
                shl->endcol = tmp_col;
              }
              shl->attr_cur = shl->attr;


              if (cur != 
# 3141 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                        ((void *)0)
                  
# 3142 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                 && shl != &search_hl
                  && syn_name2id((char_u *)"Conceal") == cur->hlg_id) {
                has_match_conc = v == (long)shl->startcol ? 2 : 1;
                match_conc = cur->conceal_char;
              } else {
                has_match_conc = match_conc = 0;
              }
            } else if (v == (long)shl->endcol) {
              shl->attr_cur = 0;

              next_search_hl(wp, shl, lnum, (colnr_T)v,
                             shl == &search_hl ? 
# 3153 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                                ((void *)0) 
# 3153 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                     : cur);
              pos_inprogress = !(cur == 
# 3154 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                       ((void *)0) 
# 3154 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                            || cur->pos.cur == 0);



              line = ml_get_buf(wp->w_buffer, lnum, 0);
              ptr = line + v;

              if (shl->lnum == lnum) {
                shl->startcol = shl->rm.startpos[0].col;
                if (shl->rm.endpos[0].lnum == 0)
                  shl->endcol = shl->rm.endpos[0].col;
                else
                  shl->endcol = MAXCOL;

                if (shl->startcol == shl->endcol) {

                  shl->endcol += (*utfc_ptr2len)(line + shl->endcol);
                }



                continue;
              }
            }
            break;
          }
          if (shl != &search_hl && cur != 
# 3180 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                         ((void *)0)
# 3180 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                             )
            cur = cur->next;
        }



        search_attr_from_match = 
# 3186 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                0
# 3186 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                     ;
        search_attr = search_hl.attr_cur;
        cur = wp->w_match_head;
        shl_flag = 0;
        while (cur != 
# 3190 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                     ((void *)0) 
# 3190 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                          || shl_flag == 0) {
          if (shl_flag == 0
              && ((cur != 
# 3192 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                         ((void *)0)
                   
# 3193 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                  && cur->priority > 0)
                  || cur == 
# 3194 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                           ((void *)0)
# 3194 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                               )) {
            shl = &search_hl;
            shl_flag = 1;
          } else
            shl = &cur->hl;
          if (shl->attr_cur != 0) {
            search_attr = shl->attr_cur;
            search_attr_from_match = shl != &search_hl;
          }
          if (shl != &search_hl && cur != 
# 3203 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                         ((void *)0)
# 3203 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                             )
            cur = cur->next;
        }

        if (*ptr == '\000'
            && (wp->w_onebuf_opt.wo_list && lcs_eol_one == -1)) {
          search_attr = 0;
        }
      }

      if (diff_hlf != (hlf_T)0) {
        if (diff_hlf == HLF_CHD && ptr - line >= change_start
            && n_extra == 0) {
          diff_hlf = HLF_TXD;
        }
        if (diff_hlf == HLF_TXD && ptr - line > change_end
            && n_extra == 0) {
          diff_hlf = HLF_CHD;
        }
        line_attr = win_hl_attr(wp, diff_hlf);

        if (wp->w_onebuf_opt.wo_cul && lnum == wp->w_cursor.lnum) {
          line_attr = 0 != line_attr_lowprio
            ? hl_combine_attr(hl_combine_attr(win_hl_attr(wp, HLF_CUL),
                                              line_attr),
                              hl_get_underline())
            : hl_combine_attr(line_attr, win_hl_attr(wp, HLF_CUL));
        }
      }


      attr_pri = 
# 3234 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                1
# 3234 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                    ;

      if (area_attr != 0) {
        char_attr = hl_combine_attr(line_attr, area_attr);
      } else if (search_attr != 0) {
        char_attr = hl_combine_attr(line_attr, search_attr);
      }


      else if (line_attr != 0 && ((fromcol == -10 && tocol == MAXCOL)
                                  || vcol < fromcol || vcol_prev < fromcol_prev
                                  || vcol >= tocol)) {
        char_attr = line_attr;
    } else {
        attr_pri = 
# 3248 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                  0
# 3248 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                       ;
        if (has_syntax) {
          char_attr = syntax_attr;
        } else {
          char_attr = 0;
        }
      }
    }
# 3266 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
    if (n_extra > 0) {
      if (c_extra != '\000' || (n_extra == 1 && c_final != '\000')) {
        c = (n_extra == 1 && c_final != '\000') ? c_final : c_extra;
        mb_c = c;
        if (utf_char2len(c) > 1) {
          mb_utf8 = 
# 3271 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                   1
# 3271 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                       ;
          u8cc[0] = 0;
          c = 0xc0;
        } else {
          mb_utf8 = 
# 3275 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                   0
# 3275 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                        ;
        }
      } else {
        c = *p_extra;
        mb_c = c;


        mb_l = utfc_ptr2len(p_extra);
        mb_utf8 = 
# 3283 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                 0
# 3283 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                      ;
        if (mb_l > n_extra) {
          mb_l = 1;
        } else if (mb_l > 1) {
          mb_c = utfc_ptr2char(p_extra, u8cc);
          mb_utf8 = 
# 3288 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                   1
# 3288 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                       ;
          c = 0xc0;
        }
        if (mb_l == 0) {
          mb_l = 1;
        }


        if ((wp->w_onebuf_opt.wo_rl ? (col <= 0) : (col >= grid->Columns - 1))
            && (*utf_char2cells)(mb_c) == 2) {
          c = '>';
          mb_c = c;
          mb_l = 1;
          (void)mb_l;
          multi_attr = win_hl_attr(wp, HLF_AT);



          n_extra++;
          p_extra--;
        } else {
          n_extra -= mb_l - 1;
          p_extra += mb_l - 1;
        }
        p_extra++;
      }
      n_extra--;
    } else {
      int c0;

      do { void **ptr_ = (void **)&(p_extra_free); xfree(*ptr_); *ptr_ = 
# 3318 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
     ((void *)0)
# 3318 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
     ; (void)(*ptr_); } while (0);


      c0 = c = *ptr;
      mb_c = c;


      mb_l = utfc_ptr2len(ptr);
      mb_utf8 = 
# 3326 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
               0
# 3326 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                    ;
      if (mb_l > 1) {
        mb_c = utfc_ptr2char(ptr, u8cc);


        if (mb_c < 0x80) {
          c0 = c = mb_c;
        }
        mb_utf8 = 
# 3334 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                 1
# 3334 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                     ;



        if (utf_iscomposing(mb_c)) {
          int i;

          for (i = 6 - 1; i > 0; i--) {
            u8cc[i] = u8cc[i - 1];
          }
          u8cc[0] = mb_c;
          mb_c = ' ';
        }
      }

      if ((mb_l == 1 && c >= 0x80)
          || (mb_l >= 1 && mb_c == 0)
          || (mb_l > 1 && (!vim_isprintc(mb_c)))) {


        transchar_hex((char *)extra, mb_c);
        if (wp->w_onebuf_opt.wo_rl) {
          rl_mirror(extra);
        }

        p_extra = extra;
        c = *p_extra;
        mb_c = mb_ptr2char_adv((const char_u **)&p_extra);
        mb_utf8 = (c >= 0x80);
        n_extra = (int)strlen((char *)(p_extra));
        c_extra = '\000';
        c_final = '\000';
        if (area_attr == 0 && search_attr == 0) {
          n_attr = n_extra + 1;
          extra_attr = win_hl_attr(wp, HLF_8);
          saved_attr2 = char_attr;
        }
      } else if (mb_l == 0) {
        mb_l = 1;
      } else if (p_arshape && !p_tbidi && arabic_char(mb_c)) {

        int pc, pc1, nc;
        int pcc[6];



        if (wp->w_onebuf_opt.wo_rl) {
          pc = prev_c;
          pc1 = prev_c1;
          nc = utf_ptr2char(ptr + mb_l);
          prev_c1 = u8cc[0];
        } else {
          pc = utfc_ptr2char(ptr + mb_l, pcc);
          nc = prev_c;
          pc1 = pcc[0];
        }
        prev_c = mb_c;

        mb_c = arabic_shape(mb_c, &c, &u8cc[0], pc, pc1, nc);
      } else {
        prev_c = mb_c;
      }



      if ((wp->w_onebuf_opt.wo_rl ? (col <= 0) :
           (col >= grid->Columns - 1))
          && (*utf_char2cells)(mb_c) == 2) {
        c = '>';
        mb_c = c;
        mb_utf8 = 
# 3404 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                 0
# 3404 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                      ;
        mb_l = 1;
        multi_attr = win_hl_attr(wp, HLF_AT);


        ptr--;
        did_decrement_ptr = 
# 3410 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                           1
# 3410 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                               ;
      } else if (*ptr != '\000') {
        ptr += mb_l - 1;
      }



      if (n_skip > 0 && mb_l > 1 && n_extra == 0) {
        n_extra = 1;
        c_extra = '<';
        c_final = '\000';
        c = ' ';
        if (area_attr == 0 && search_attr == 0) {
          n_attr = n_extra + 1;
          extra_attr = win_hl_attr(wp, HLF_AT);
          saved_attr2 = char_attr;
        }
        mb_c = c;
        mb_utf8 = 
# 3428 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                 0
# 3428 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                      ;
        mb_l = 1;
      }
      ptr++;

      if (extra_check) {
        
# 3434 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
       _Bool 
# 3434 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
            can_spell = 
# 3434 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                        1
# 3434 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                            ;



        v = (long)(ptr - line);
        if (has_syntax && v > 0) {


          save_did_emsg = did_emsg;
          did_emsg = 0;

          syntax_attr = get_syntax_attr((colnr_T)v - 1,
                                        has_spell ? &can_spell : 
# 3446 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                                                ((void *)0)
# 3446 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                                    , 
# 3446 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                                                      0
# 3446 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                                           );

          if (did_emsg) {
            wp->w_s->b_syn_error = 1;
            has_syntax = 0;
          } else
            did_emsg = save_did_emsg;



          line = ml_get_buf(wp->w_buffer, lnum, 0);
          ptr = line + v;

          if (!attr_pri) {
            char_attr = syntax_attr;
          } else {
            char_attr = hl_combine_attr(syntax_attr, char_attr);
          }


          if (c == '\000') {
            syntax_flags = 0;
          } else {
            syntax_flags = get_syntax_info(&syntax_seqnr);
          }
        } else if (!attr_pri) {
          char_attr = 0;
        }





        if (has_spell && v >= word_end && v > cur_checked_col) {
          spell_attr = 0;
          if (!attr_pri) {
            char_attr = syntax_attr;
          }
          if (c != 0 && (!has_syntax || can_spell)) {
            char_u *prev_ptr;
            char_u *p;
            int len;
            hlf_T spell_hlf = HLF_COUNT;
            prev_ptr = ptr - mb_l;
            v -= mb_l - 1;



            if ((prev_ptr - line) - nextlinecol >= 0) {
              p = nextline + ((prev_ptr - line) - nextlinecol);
            } else {
              p = prev_ptr;
            }
            cap_col -= (int)(prev_ptr - line);
            size_t tmplen = spell_check(wp, p, &spell_hlf, &cap_col, nochange);
            
# 3501 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
           ((void) sizeof ((
# 3501 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
           tmplen <= 0x7fffffff
# 3501 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
           ) ? 1 : 0), __extension__ ({ if (
# 3501 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
           tmplen <= 0x7fffffff
# 3501 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
           ) ; else __assert_fail (
# 3501 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
           "tmplen <= INT_MAX"
# 3501 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
           , "/home/toto/.env/encours/neovim/src/nvim/screen.c", 3501, __extension__ __PRETTY_FUNCTION__); }))
# 3501 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                    ;
            len = (int)tmplen;
            word_end = v + len;



            if (spell_hlf != HLF_COUNT
                && (State & 0x10) != 0
                && wp->w_cursor.lnum == lnum
                && wp->w_cursor.col >=
                (colnr_T)(prev_ptr - line)
                && wp->w_cursor.col < (colnr_T)word_end) {
              spell_hlf = HLF_COUNT;
              spell_redraw_lnum = lnum;
            }

            if (spell_hlf == HLF_COUNT && p != prev_ptr
                && (p - nextline) + len > nextline_idx) {


              checked_lnum = lnum + 1;
              checked_col = (int)((p - nextline) + len - nextline_idx);
            }


            if (spell_hlf != HLF_COUNT)
              spell_attr = highlight_attr[spell_hlf];

            if (cap_col > 0) {
              if (p != prev_ptr
                  && (p - nextline) + cap_col >= nextline_idx) {


                capcol_lnum = lnum + 1;
                cap_col = (int)((p - nextline) + cap_col
                                - nextline_idx);
              } else

                cap_col += (int)(prev_ptr - line);
            }
          }
        }
        if (spell_attr != 0) {
          if (!attr_pri)
            char_attr = hl_combine_attr(char_attr, spell_attr);
          else
            char_attr = hl_combine_attr(spell_attr, char_attr);
        }

        if (has_decorations && v > 0) {
          int extmark_attr = decorations_redraw_col(wp->w_buffer, (colnr_T)v-1,
                                                    &decorations);
          if (extmark_attr != 0) {
            if (!attr_pri) {
              char_attr = hl_combine_attr(char_attr, extmark_attr);
            } else {
              char_attr = hl_combine_attr(extmark_attr, char_attr);
            }
          }
        }

        if (wp->w_buffer->terminal) {
          char_attr = hl_combine_attr(term_attrs[vcol], char_attr);
        }


        if (wp->w_onebuf_opt.wo_lbr && c0 == c && vim_isbreak(c)
            && !vim_isbreak((int)(*ptr))) {
          int mb_off = utf_head_off(line, ptr - 1);
          char_u *p = ptr - (mb_off + 1);

          n_extra = win_lbr_chartabsize(wp, line, p, (colnr_T)vcol, 
# 3572 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                                                   ((void *)0)
# 3572 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                                       ) - 1;
          if (c == '\011' && n_extra + col > grid->Columns) {
            n_extra = (int)wp->w_buffer->b_p_ts
                      - vcol % (int)wp->w_buffer->b_p_ts - 1;
          }
          c_extra = mb_off > 0 ? '<' : ' ';
          c_final = '\000';
          if (ascii_iswhite(c)) {
            if (c == '\011')

              { n_extra += vcol_off; vcol -= vcol_off; vcol_off = 0; col -= boguscols; old_boguscols = boguscols; boguscols = 0; };
            if (!wp->w_onebuf_opt.wo_list) {
              c = ' ';
            }
          }
        }


        if (wp->w_onebuf_opt.wo_list
            && (((c == 160
                  || (mb_utf8 && (mb_c == 160 || mb_c == 0x202f)))
                 && curwin->w_p_lcs_chars.nbsp)
                || (c == ' ' && curwin->w_p_lcs_chars.space
                    && ptr - line <= trailcol))) {
          c = (c == ' ') ? wp->w_p_lcs_chars.space : wp->w_p_lcs_chars.nbsp;
          n_attr = 1;
          extra_attr = win_hl_attr(wp, HLF_0);
          saved_attr2 = char_attr;
          mb_c = c;
          if (utf_char2len(c) > 1) {
            mb_utf8 = 
# 3602 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                     1
# 3602 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                         ;
            u8cc[0] = 0;
            c = 0xc0;
          } else {
            mb_utf8 = 
# 3606 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                     0
# 3606 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                          ;
          }
        }

        if (trailcol != MAXCOL && ptr > line + trailcol && c == ' ') {
          c = wp->w_p_lcs_chars.trail;
          n_attr = 1;
          extra_attr = win_hl_attr(wp, HLF_0);
          saved_attr2 = char_attr;
          mb_c = c;
          if (utf_char2len(c) > 1) {
            mb_utf8 = 
# 3617 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                     1
# 3617 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                         ;
            u8cc[0] = 0;
            c = 0xc0;
          } else {
            mb_utf8 = 
# 3621 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                     0
# 3621 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                          ;
          }
        }
      }




      if (!vim_isprintc(c)) {


        if (c == '\011' && (!wp->w_onebuf_opt.wo_list || wp->w_p_lcs_chars.tab1)) {
          int tab_len = 0;
          long vcol_adjusted = vcol;


          if (*p_sbr != '\000' && vcol == vcol_sbr && wp->w_onebuf_opt.wo_wrap) {
            vcol_adjusted = vcol - mb_charlen(p_sbr);
          }

          tab_len = (int)wp->w_buffer->b_p_ts
                    - vcol_adjusted % (int)wp->w_buffer->b_p_ts - 1;

          if (!wp->w_onebuf_opt.wo_lbr || !wp->w_onebuf_opt.wo_list) {
            n_extra = tab_len;
          } else {
            char_u *p;
            int i;
            int saved_nextra = n_extra;

            if (vcol_off > 0) {

              tab_len += vcol_off;
            }

            if (wp->w_p_lcs_chars.tab1 && old_boguscols > 0
                && n_extra > tab_len) {
              tab_len += n_extra - tab_len;
            }




            int len = (tab_len * utf_char2len(wp->w_p_lcs_chars.tab2));
            if (n_extra > 0) {
              len += n_extra - tab_len;
            }
            c = wp->w_p_lcs_chars.tab1;
            p = xmalloc(len + 1);
            memset(p, ' ', len);
            p[len] = '\000';
            xfree(p_extra_free);
            p_extra_free = p;
            for (i = 0; i < tab_len; i++) {
              int lcs = wp->w_p_lcs_chars.tab2;



              if (wp->w_p_lcs_chars.tab3 && i == tab_len - 1) {
                lcs = wp->w_p_lcs_chars.tab3;
              }
              utf_char2bytes(lcs, p);
              p += utf_char2len(lcs);
              n_extra += utf_char2len(lcs) - (saved_nextra > 0 ? 1 : 0);
            }
            p_extra = p_extra_free;



            if (vcol_off > 0) {
              n_extra -= vcol_off;
            }
          }

          {
            int vc_saved = vcol_off;







            { n_extra += vcol_off; vcol -= vcol_off; vcol_off = 0; col -= boguscols; old_boguscols = boguscols; boguscols = 0; };




            if (n_extra == tab_len + vc_saved && wp->w_onebuf_opt.wo_list
                && wp->w_p_lcs_chars.tab1) {
              tab_len += vc_saved;
            }
          }

          mb_utf8 = 
# 3715 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                   0
# 3715 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                        ;
          if (wp->w_onebuf_opt.wo_list) {
            c = (n_extra == 0 && wp->w_p_lcs_chars.tab3)
                 ? wp->w_p_lcs_chars.tab3
                 : wp->w_p_lcs_chars.tab1;
            if (wp->w_onebuf_opt.wo_lbr) {
              c_extra = '\000';
            } else {
              c_extra = wp->w_p_lcs_chars.tab2;
            }
            c_final = wp->w_p_lcs_chars.tab3;
            n_attr = tab_len + 1;
            extra_attr = win_hl_attr(wp, HLF_0);
            saved_attr2 = char_attr;
            mb_c = c;
            if (utf_char2len(c) > 1) {
              mb_utf8 = 
# 3731 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                       1
# 3731 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                           ;
              u8cc[0] = 0;
              c = 0xc0;
            }
          } else {
            c_final = '\000';
            c_extra = ' ';
            c = ' ';
          }
        } else if (c == '\000'
                   && (wp->w_onebuf_opt.wo_list
                       || ((fromcol >= 0 || fromcol_prev >= 0)
                           && tocol > vcol
                           && VIsual_mode != 22
                           && (wp->w_onebuf_opt.wo_rl ? (col >= 0) : (col < grid->Columns))
                           && !(noinvcur
                                && lnum == wp->w_cursor.lnum
                                && (colnr_T)vcol == wp->w_virtcol)))
                   && lcs_eol_one > 0) {



          if (diff_hlf == (hlf_T)0
              && line_attr == 0
              && line_attr_lowprio == 0) {

            if (area_highlighting && virtual_active()
                && tocol != MAXCOL && vcol < tocol) {
              n_extra = 0;
            } else {
              p_extra = at_end_str;
              n_extra = 1;
              c_extra = '\000';
              c_final = '\000';
            }
          }
          if (wp->w_onebuf_opt.wo_list && wp->w_p_lcs_chars.eol > 0) {
            c = wp->w_p_lcs_chars.eol;
          } else {
            c = ' ';
          }
          lcs_eol_one = -1;
          ptr--;
          extra_attr = win_hl_attr(wp, HLF_AT);
          n_attr = 1;
          mb_c = c;
          if (utf_char2len(c) > 1) {
            mb_utf8 = 
# 3778 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                     1
# 3778 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                         ;
            u8cc[0] = 0;
            c = 0xc0;
          } else {
            mb_utf8 = 
# 3782 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                     0
# 3782 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                          ;
          }
        } else if (c != '\000') {
          p_extra = transchar(c);
          if (n_extra == 0) {
              n_extra = byte2cells(c) - 1;
          }
          if ((dy_flags & 0x004) && wp->w_onebuf_opt.wo_rl)
            rl_mirror(p_extra);
          c_extra = '\000';
          c_final = '\000';
          if (wp->w_onebuf_opt.wo_lbr) {
            char_u *p;

            c = *p_extra;
            p = xmalloc(n_extra + 1);
            memset(p, ' ', n_extra);
            strncpy((char *)(p), (char *)(p_extra + 1), (size_t)(strlen((char *)(p_extra)) - 1));
            p[n_extra] = '\000';
            xfree(p_extra_free);
            p_extra_free = p_extra = p;
          } else {
            n_extra = byte2cells(c) - 1;
            c = *p_extra++;
          }
          n_attr = n_extra + 1;
          extra_attr = win_hl_attr(wp, HLF_8);
          saved_attr2 = char_attr;
          mb_utf8 = 
# 3810 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                   0
# 3810 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                        ;
        } else if (VIsual_active
                   && (VIsual_mode == 22 || VIsual_mode == 'v')
                   && virtual_active()
                   && tocol != MAXCOL
                   && vcol < tocol
                   && (wp->w_onebuf_opt.wo_rl ? (col >= 0) : (col < grid->Columns))) {
          c = ' ';
          ptr--;
        }
      }

      if (wp->w_onebuf_opt.wo_cole > 0
          && (wp != curwin || lnum != wp->w_cursor.lnum
              || conceal_cursor_line(wp))
          && ((syntax_flags & 0x20000) != 0 || has_match_conc > 0)
          && !(lnum_in_visual_area
               && vim_strchr(wp->w_onebuf_opt.wo_cocu, 'v') == 
# 3827 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                                  ((void *)0)
# 3827 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                      )) {
        char_attr = conceal_attr;
        if ((prev_syntax_id != syntax_seqnr || has_match_conc > 1)
            && (syn_get_sub_char() != '\000' || match_conc
                || wp->w_onebuf_opt.wo_cole == 1)
            && wp->w_onebuf_opt.wo_cole != 3) {


          if (match_conc) {
            c = match_conc;
          } else if (syn_get_sub_char() != '\000') {
            c = syn_get_sub_char();
          } else if (wp->w_p_lcs_chars.conceal != '\000') {
            c = wp->w_p_lcs_chars.conceal;
          } else {
            c = ' ';
          }

          prev_syntax_id = syntax_seqnr;

          if (n_extra > 0)
            vcol_off += n_extra;
          vcol += n_extra;
          if (wp->w_onebuf_opt.wo_wrap && n_extra > 0) {
            if (wp->w_onebuf_opt.wo_rl) {
              col -= n_extra;
              boguscols -= n_extra;
            } else {
              boguscols += n_extra;
              col += n_extra;
            }
          }
          n_extra = 0;
          n_attr = 0;
        } else if (n_skip == 0) {
          is_concealing = 1;
          n_skip = 1;
        }
        mb_c = c;
        if (utf_char2len(c) > 1) {
          mb_utf8 = 
# 3867 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                   1
# 3867 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                       ;
          u8cc[0] = 0;
          c = 0xc0;
        } else {
          mb_utf8 = 
# 3871 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                   0
# 3871 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                        ;
        }
      } else {
        prev_syntax_id = 0;
        is_concealing = 0;
      }

      if (n_skip > 0 && did_decrement_ptr) {

        ptr++;
      }
    }



    if (!did_wcol && draw_state == 0 + 1 + 1 + 1 + 1 + 1 + 1 + 1
        && wp == curwin && lnum == wp->w_cursor.lnum
        && conceal_cursor_line(wp)
        && (int)wp->w_virtcol <= vcol + n_skip) {
      if (wp->w_onebuf_opt.wo_rl) {
        wp->w_wcol = grid->Columns - col + boguscols - 1;
      } else {
        wp->w_wcol = col - boguscols;
      }
      wp->w_wrow = row;
      did_wcol = 
# 3896 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                1
# 3896 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                    ;
      curwin->w_valid |= 0x02|0x01|0x04;
    }


    if (n_attr > 0 && draw_state == 0 + 1 + 1 + 1 + 1 + 1 + 1 + 1 && !search_attr_from_match) {
      char_attr = hl_combine_attr(char_attr, extra_attr);
    }




    if (lcs_prec_todo != '\000'
        && wp->w_onebuf_opt.wo_list
        && (wp->w_onebuf_opt.wo_wrap ? (wp->w_skipcol > 0 && row == 0) : wp->w_leftcol > 0)
        && filler_todo <= 0
        && draw_state > 0 + 1 + 1 + 1 + 1
        && c != '\000') {
      c = wp->w_p_lcs_chars.prec;
      lcs_prec_todo = '\000';
      if ((*utf_char2cells)(mb_c) > 1) {


        c_extra = '<';
        c_final = '\000';
        n_extra = 1;
        n_attr = 2;
        extra_attr = win_hl_attr(wp, HLF_AT);
      }
      mb_c = c;
      if (utf_char2len(c) > 1) {
        mb_utf8 = 
# 3927 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                 1
# 3927 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                     ;
        u8cc[0] = 0;
        c = 0xc0;
      } else {
        mb_utf8 = 
# 3931 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                 0
# 3931 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                      ;
      }
      saved_attr3 = char_attr;
      char_attr = win_hl_attr(wp, HLF_AT);
      n_attr3 = 1;
    }


    if (c == '\000') {
      long prevcol = (long)(ptr - line) - 1;


      if ((long)(wp->w_onebuf_opt.wo_wrap ? wp->w_skipcol : wp->w_leftcol) > prevcol) {
        prevcol++;
      }





      prevcol_hl_flag = 
# 3951 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                       0
# 3951 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                            ;
      if (!search_hl.is_addpos && prevcol == (long)search_hl.startcol) {
        prevcol_hl_flag = 
# 3953 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                         1
# 3953 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                             ;
      } else {
        cur = wp->w_match_head;
        while (cur != 
# 3956 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                     ((void *)0)
# 3956 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                         ) {
          if (!cur->hl.is_addpos && prevcol == (long)cur->hl.startcol) {
            prevcol_hl_flag = 
# 3958 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                             1
# 3958 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                 ;
            break;
          }
          cur = cur->next;
        }
      }
      if (wp->w_p_lcs_chars.eol == lcs_eol_one
          && ((area_attr != 0 && vcol == fromcol
               && (VIsual_mode != 22
                   || lnum == VIsual.lnum
                   || lnum == curwin->w_cursor.lnum))

              || prevcol_hl_flag)) {
        int n = 0;

        if (wp->w_onebuf_opt.wo_rl) {
          if (col < 0)
            n = 1;
        } else {
          if (col >= grid->Columns) {
            n = -1;
          }
        }
        if (n != 0) {


          off += n;
          col += n;
        } else {

          schar_from_ascii(linebuf_char[off], ' ');
        }
        if (area_attr == 0) {


          char_attr = search_hl.attr;
          cur = wp->w_match_head;
          shl_flag = 0;
          while (cur != 
# 3996 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                       ((void *)0) 
# 3996 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                            || shl_flag == 0) {
            if (shl_flag == 0
                && ((cur != 
# 3998 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                           ((void *)0)
                     
# 3999 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                    && cur->priority > 0)
                    || cur == 
# 4000 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                             ((void *)0)
# 4000 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                 )) {
              shl = &search_hl;
              shl_flag = 1;
            } else
              shl = &cur->hl;
            if ((ptr - line) - 1 == (long)shl->startcol
                && (shl == &search_hl || !shl->is_addpos)) {
              char_attr = shl->attr;
            }
            if (shl != &search_hl && cur != 
# 4009 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                           ((void *)0)
# 4009 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                               ) {
              cur = cur->next;
            }
          }
        }

        int eol_attr = char_attr;
        if (wp->w_onebuf_opt.wo_cul && lnum == wp->w_cursor.lnum) {
          eol_attr = hl_combine_attr(win_hl_attr(wp, HLF_CUL), eol_attr);
        }
        linebuf_attr[off] = eol_attr;
        if (wp->w_onebuf_opt.wo_rl) {
          --col;
          --off;
        } else {
          ++col;
          ++off;
        }
        ++vcol;
        eol_hl_off = 1;
      }

      if (wp->w_onebuf_opt.wo_wrap) {
        v = wp->w_skipcol;
      } else {
        v = wp->w_leftcol;
      }


      if (vcol < v + col - win_col_off(wp))
        vcol = v + col - win_col_off(wp);


      col -= boguscols;


      if (draw_color_col)
        draw_color_col = advance_color_col((vcol - vcol_off), &color_cols);

      VirtText virt_text = { .size = 0, .capacity = 0, .items = 
# 4048 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                          ((void *)0) 
# 4048 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                          };
      if (luatext) {
        (*((((virt_text).size == (virt_text).capacity) ? (((virt_text).capacity = ((virt_text).capacity ? (virt_text).capacity << 1 : 8), (virt_text).items = xrealloc((virt_text).items, sizeof((virt_text).items[0]) * (virt_text).capacity)), 0) : 0), ((virt_text).items + ((virt_text).size++))) = (((VirtTextChunk){ .text = luatext, .hl_id = 0 })));
        do_virttext = 
# 4051 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                     1
# 4051 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                         ;
      } else if (has_decorations) {
        VirtText *vp = decorations_redraw_virt_text(wp->w_buffer, &decorations);
        if (vp) {
          virt_text = *vp;
          do_virttext = 
# 4056 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                       1
# 4056 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                           ;
        }
      }

      if (((wp->w_onebuf_opt.wo_cuc
            && (int)wp->w_virtcol >= (vcol - vcol_off) - eol_hl_off
            && (int)wp->w_virtcol <
            grid->Columns * (row - startrow + 1) + v
            && lnum != wp->w_cursor.lnum)
           || draw_color_col || line_attr_lowprio || line_attr
           || diff_hlf != (hlf_T)0 || do_virttext)) {
        int rightmost_vcol = 0;
        int i;

        size_t virt_pos = 0;
        LineState s = { (char_u *)"", 0, 0 };
        int virt_attr = 0;



        
# 4076 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
       _Bool 
# 4076 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
            delay_virttext = wp->w_p_lcs_chars.eol == lcs_eol_one
                              && eol_hl_off == 0;

        if (wp->w_onebuf_opt.wo_cuc) {
          rightmost_vcol = wp->w_virtcol;
        }

        if (draw_color_col) {

          for (i = 0; color_cols[i] >= 0; i++) {
            if (rightmost_vcol < color_cols[i]) {
              rightmost_vcol = color_cols[i];
            }
          }
        }

        int cuc_attr = win_hl_attr(wp, HLF_CUC);
        int mc_attr = win_hl_attr(wp, HLF_MC);

        int diff_attr = 0;
        if (diff_hlf == HLF_TXD) {
          diff_hlf = HLF_CHD;
        }
        if (diff_hlf != 0) {
          diff_attr = win_hl_attr(wp, diff_hlf);
        }

        int base_attr = hl_combine_attr(line_attr_lowprio, diff_attr);
        if (base_attr || line_attr) {
          rightmost_vcol = 0x7fffffff;
        }

        int col_stride = wp->w_onebuf_opt.wo_rl ? -1 : 1;

        while (wp->w_onebuf_opt.wo_rl ? col >= 0 : col < grid->Columns) {
          int cells = -1;
          if (do_virttext && !delay_virttext) {
            if (*s.p == '\000') {
              if (virt_pos < virt_text.size) {
                s.p = (char_u *)((virt_text).items[(virt_pos)]).text;
                int hl_id = ((virt_text).items[(virt_pos)]).hl_id;
                virt_attr = hl_id > 0 ? syn_id2attr(hl_id) : 0;
                virt_pos++;
              } else {
               do_virttext = 
# 4120 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                            0
# 4120 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                 ;
              }
            }
            if (*s.p != '\000') {
              cells = line_putchar(&s, &linebuf_char[off], grid->Columns - col,
                                   
# 4125 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                  0
# 4125 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                       );
            }
          }
          delay_virttext = 
# 4128 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                          0
# 4128 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                               ;

          if (cells == -1) {
            schar_from_ascii(linebuf_char[off], ' ');
            cells = 1;
          }
          col += cells * col_stride;
          if (draw_color_col) {
            draw_color_col = advance_color_col((vcol - vcol_off), &color_cols);
          }

          int col_attr = base_attr;

          if (wp->w_onebuf_opt.wo_cuc && (vcol - vcol_off) == (long)wp->w_virtcol) {
            col_attr = cuc_attr;
          } else if (draw_color_col && (vcol - vcol_off) == *color_cols) {
            col_attr = mc_attr;
          }

          if (do_virttext) {
            col_attr = hl_combine_attr(col_attr, virt_attr);
          }

          col_attr = hl_combine_attr(col_attr, line_attr);

          linebuf_attr[off] = col_attr;
          if (cells == 2) {
            linebuf_attr[off+1] = col_attr;
          }
          off += cells * col_stride;

          if ((vcol - vcol_off) >= rightmost_vcol && *s.p == '\000'
              && virt_pos >= virt_text.size) {
            break;
          }

          vcol += cells;
        }
      }


      if (wp->w_buffer->terminal) {


        int n = wp->w_onebuf_opt.wo_rl ? -1 : 1;
        while (col >= 0 && col < grid->Columns) {
          schar_from_ascii(linebuf_char[off], ' ');
          linebuf_attr[off] = term_attrs[vcol];
          off += n;
          vcol += n;
          col += n;
        }
      }
      grid_put_linebuf(grid, row, 0, col, grid->Columns, wp->w_onebuf_opt.wo_rl, wp,
                       wp->w_hl_attr_normal, 
# 4182 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                            0
# 4182 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                 );
      row++;





      if (wp == curwin && lnum == curwin->w_cursor.lnum) {
        curwin->w_cline_row = startrow;
        curwin->w_cline_height = row - startrow;
        curwin->w_cline_folded = 
# 4192 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                0
# 4192 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                     ;
        curwin->w_valid |= (0x08|0x10);
        conceal_cursor_used = conceal_cursor_line(curwin);
      }

      break;
    }



    if (wp->w_p_lcs_chars.ext != '\000'
        && wp->w_onebuf_opt.wo_list
        && !wp->w_onebuf_opt.wo_wrap
        && filler_todo <= 0
        && (wp->w_onebuf_opt.wo_rl ? col == 0 : col == grid->Columns - 1)
        && (*ptr != '\000'
            || lcs_eol_one > 0
            || (n_extra && (c_extra != '\000' || *p_extra != '\000')))) {
      c = wp->w_p_lcs_chars.ext;
      char_attr = win_hl_attr(wp, HLF_AT);
      mb_c = c;
      if (utf_char2len(c) > 1) {
        mb_utf8 = 
# 4214 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                 1
# 4214 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                     ;
        u8cc[0] = 0;
        c = 0xc0;
      } else {
        mb_utf8 = 
# 4218 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                 0
# 4218 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                      ;
      }
    }


    if (draw_color_col) {
      draw_color_col = advance_color_col((vcol - vcol_off), &color_cols);
    }





    vcol_save_attr = -1;
    if (draw_state == 0 + 1 + 1 + 1 + 1 + 1 + 1 + 1 && !lnum_in_visual_area
        && search_attr == 0 && area_attr == 0) {
      if (wp->w_onebuf_opt.wo_cuc && (vcol - vcol_off) == (long)wp->w_virtcol
          && lnum != wp->w_cursor.lnum) {
        vcol_save_attr = char_attr;
        char_attr = hl_combine_attr(win_hl_attr(wp, HLF_CUC), char_attr);
      } else if (draw_color_col && (vcol - vcol_off) == *color_cols) {
        vcol_save_attr = char_attr;
        char_attr = hl_combine_attr(win_hl_attr(wp, HLF_MC), char_attr);
      }
    }


    if (draw_state == 0 + 1 + 1 + 1 + 1 + 1 + 1 + 1) {
      char_attr = hl_combine_attr(line_attr_lowprio, char_attr);
    }



    vcol_prev = vcol;
    if (draw_state < 0 + 1 + 1 + 1 + 1 + 1 + 1 + 1 || n_skip <= 0) {



      if (wp->w_onebuf_opt.wo_rl && (*utf_char2cells)(mb_c) > 1) {

        off--;
        col--;
      }
      if (mb_utf8) {
        schar_from_cc(linebuf_char[off], mb_c, u8cc);
      } else {
        schar_from_ascii(linebuf_char[off], c);
      }
      if (multi_attr) {
        linebuf_attr[off] = multi_attr;
        multi_attr = 0;
      } else {
        linebuf_attr[off] = char_attr;
      }

      if ((*utf_char2cells)(mb_c) > 1) {

        off++;
        col++;

        linebuf_char[off][0] = 0;
        if (draw_state > 0 + 1 + 1 + 1 + 1 && filler_todo <= 0) {
          vcol++;
        }


        if (tocol == vcol) {
          tocol++;
        }
        if (wp->w_onebuf_opt.wo_rl) {

          --off;
          --col;
        }
      }
      if (wp->w_onebuf_opt.wo_rl) {
        --off;
        --col;
      } else {
        ++off;
        ++col;
      }
    } else if (wp->w_onebuf_opt.wo_cole > 0 && is_concealing) {
      --n_skip;
      ++vcol_off;
      if (n_extra > 0)
        vcol_off += n_extra;
      if (wp->w_onebuf_opt.wo_wrap) {
# 4319 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
        if (n_extra > 0) {
          vcol += n_extra;
          if (wp->w_onebuf_opt.wo_rl) {
            col -= n_extra;
            boguscols -= n_extra;
          } else {
            col += n_extra;
            boguscols += n_extra;
          }
          n_extra = 0;
          n_attr = 0;
        }


        if ((*utf_char2cells)(mb_c) > 1) {

          if (wp->w_onebuf_opt.wo_rl) {
            --boguscols;
            --col;
          } else {
            ++boguscols;
            ++col;
          }
        }

        if (wp->w_onebuf_opt.wo_rl) {
          --boguscols;
          --col;
        } else {
          ++boguscols;
          ++col;
        }
      } else {
        if (n_extra > 0) {
          vcol += n_extra;
          n_extra = 0;
          n_attr = 0;
        }
      }

    } else
      --n_skip;



    if (draw_state > 0 + 1 + 1 + 1 + 1
        && filler_todo <= 0
        )
      ++vcol;

    if (vcol_save_attr >= 0)
      char_attr = vcol_save_attr;


    if (draw_state > 0 + 1 + 1 + 1 + 1 && n_attr3 > 0 && --n_attr3 == 0)
      char_attr = saved_attr3;


    if (n_attr > 0 && draw_state == 0 + 1 + 1 + 1 + 1 + 1 + 1 + 1 && --n_attr == 0)
      char_attr = saved_attr2;





    if ((wp->w_onebuf_opt.wo_rl ? (col < 0) : (col >= grid->Columns))
        && (*ptr != '\000'
            || filler_todo > 0
            || (wp->w_onebuf_opt.wo_list && wp->w_p_lcs_chars.eol != '\000'
                && p_extra != at_end_str)
            || (n_extra != 0 && (c_extra != '\000' || *p_extra != '\000')))
        ) {
      
# 4391 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
     _Bool 
# 4391 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
          wrap = wp->w_onebuf_opt.wo_wrap
        && filler_todo <= 0
        && lcs_eol_one != -1
        && row != endrow - 1
        && (grid->Columns == Columns
            || ui_has(kUIMultigrid))
        && !wp->w_onebuf_opt.wo_rl;
      grid_put_linebuf(grid, row, 0, col - boguscols, grid->Columns, wp->w_onebuf_opt.wo_rl,
                       wp, wp->w_hl_attr_normal, wrap);
      if (wrap) {
        ScreenGrid *current_grid = grid;
        int current_row = row, dummy_col = 0;
        screen_adjust_grid(&current_grid, &current_row, &dummy_col);


        current_grid->attrs[current_grid->line_offset[current_row+1]] = -1;


        current_grid->line_wraps[current_row] = 
# 4409 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                               1
# 4409 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                   ;
      }

      boguscols = 0;
      row++;



      if ((!wp->w_onebuf_opt.wo_wrap
           && filler_todo <= 0
           ) || lcs_eol_one == -1)
        break;


      if (draw_state != 0 + 1 + 1 + 1 + 1 + 1 + 1 + 1 && filler_todo <= 0) {
        win_draw_end(wp, '@', ' ', 
# 4424 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                  1
# 4424 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                      , row, wp->w_grid.Rows, HLF_AT);
        row = endrow;
      }


      if (row == endrow) {
        ++row;
        break;
      }

      col = 0;
      off = 0;
      if (wp->w_onebuf_opt.wo_rl) {
        col = grid->Columns - 1;
        off += col;
      }


      draw_state = 0;
      saved_n_extra = n_extra;
      saved_p_extra = p_extra;
      saved_c_extra = c_extra;
      saved_c_final = c_final;
      saved_char_attr = char_attr;
      n_extra = 0;
      lcs_prec_todo = wp->w_p_lcs_chars.prec;
      if (filler_todo <= 0) {
        need_showbreak = 
# 4451 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                        1
# 4451 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                            ;
      }
      filler_todo--;


      if (filler_todo == 0 && wp->w_botfill) {
        break;
      }
    }

  }


  if (*skipwhite(line) == '\000') {
    capcol_lnum = lnum + 1;
    cap_col = 0;
  }

  xfree(p_extra_free);
  xfree(luatext);
  return row;
}
# 4484 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
void screen_adjust_grid(ScreenGrid **grid, int *row_off, int *col_off)
{
  if (!(*grid)->chars && *grid != &default_grid) {
      *row_off += (*grid)->row_offset;
      *col_off += (*grid)->col_offset;
    if (*grid == &msg_grid_adj && msg_grid.chars) {
      *grid = &msg_grid;
    } else {
      *grid = &default_grid;
    }
  }
}
# 4505 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
static int grid_char_needs_redraw(ScreenGrid *grid, int off_from, int off_to,
                                  int cols)
{
  return (cols > 0
          && ((schar_cmp(linebuf_char[off_from], grid->chars[off_to])
               || linebuf_attr[off_from] != grid->attrs[off_to]
               || (line_off2cells(linebuf_char, off_from, off_from + cols) > 1
                   && schar_cmp(linebuf_char[off_from + 1],
                                grid->chars[off_to + 1])))
              || rdb_flags & 0x008));
}
# 4528 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
static void grid_put_linebuf(ScreenGrid *grid, int row, int coloff, int endcol,
                             int clear_width, int rlflag, win_T *wp,
                             int bg_attr, 
# 4530 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                         _Bool 
# 4530 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                              wrap)
{
  unsigned off_from;
  unsigned off_to;
  unsigned max_off_from;
  unsigned max_off_to;
  int col = 0;
  
# 4537 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
 _Bool 
# 4537 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
      redraw_this;
  
# 4538 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
 _Bool 
# 4538 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
      redraw_next;
  
# 4539 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
 _Bool 
# 4539 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
      clear_next = 
# 4539 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                   0
# 4539 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                        ;
  int char_cells;

  int start_dirty = -1, end_dirty = 0;



  if (row >= grid->Rows) {
    row = grid->Rows - 1;
  }
  if (endcol > grid->Columns) {
    endcol = grid->Columns;
  }

  screen_adjust_grid(&grid, &row, &coloff);


  if (grid->chars == 
# 4556 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                    ((void *)0) 
# 4556 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                         || row >= grid->Rows || coloff >= grid->Columns) {
    ;
    return;
  }

  off_from = 0;
  off_to = grid->line_offset[row] + coloff;
  max_off_from = linebuf_size;
  max_off_to = grid->line_offset[row] + grid->Columns;

  if (rlflag) {

    if (clear_width > 0) {
      while (col <= endcol && grid->chars[off_to][0] == ' '
             && grid->chars[off_to][1] == '\000'
             && grid->attrs[off_to] == bg_attr
             ) {
        ++off_to;
        ++col;
      }
      if (col <= endcol) {
        grid_fill(grid, row, row + 1, col + coloff, endcol + coloff + 1,
                  ' ', ' ', bg_attr);
      }
    }
    col = endcol + 1;
    off_to = grid->line_offset[row] + col + coloff;
    off_from += col;
    endcol = (clear_width > 0 ? clear_width : -clear_width);
  }

  if (bg_attr) {
    for (int c = col; c < endcol; c++) {
      linebuf_attr[off_from+c] =
        hl_combine_attr(bg_attr, linebuf_attr[off_from+c]);
    }
  }

  redraw_next = grid_char_needs_redraw(grid, off_from, off_to, endcol - col);

  while (col < endcol) {
    char_cells = 1;
    if (col + 1 < endcol) {
      char_cells = line_off2cells(linebuf_char, off_from, max_off_from);
    }
    redraw_this = redraw_next;
    redraw_next = grid_char_needs_redraw(grid, off_from + char_cells,
                                         off_to + char_cells,
                                         endcol - col - char_cells);

    if (redraw_this) {
      if (start_dirty == -1) {
        start_dirty = col;
      }
      end_dirty = col + char_cells;





      if (col + char_cells == endcol
          && ((char_cells == 1
               && grid_off2cells(grid, off_to, max_off_to) > 1)
              || (char_cells == 2
                  && grid_off2cells(grid, off_to, max_off_to) == 1
                  && grid_off2cells(grid, off_to + 1, max_off_to) > 1))) {
        clear_next = 
# 4622 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                    1
# 4622 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                        ;
      }

      schar_copy(grid->chars[off_to], linebuf_char[off_from]);
      if (char_cells == 2) {
        schar_copy(grid->chars[off_to+1], linebuf_char[off_from+1]);
      }

      grid->attrs[off_to] = linebuf_attr[off_from];


      if (char_cells == 2) {
        grid->attrs[off_to + 1] = linebuf_attr[off_from];
      }
    }

    off_to += char_cells;
    off_from += char_cells;
    col += char_cells;
  }

  if (clear_next) {


    schar_from_ascii(grid->chars[off_to], ' ');
    end_dirty++;
  }

  int clear_end = -1;
  if (clear_width > 0 && !rlflag) {


    while (col < clear_width) {
      if (grid->chars[off_to][0] != ' '
          || grid->chars[off_to][1] != '\000'
          || grid->attrs[off_to] != bg_attr) {
        grid->chars[off_to][0] = ' ';
        grid->chars[off_to][1] = '\000';
        grid->attrs[off_to] = bg_attr;
        if (start_dirty == -1) {
          start_dirty = col;
          end_dirty = col;
        } else if (clear_end == -1) {
          end_dirty = endcol;
        }
        clear_end = col+1;
      }
      col++;
      off_to++;
    }
  }

  if (clear_width > 0 || wp->w_width != grid->Columns) {


    grid->line_wraps[row] = 
# 4677 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                           0
# 4677 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                ;
  }

  if (clear_end < end_dirty) {
    clear_end = end_dirty;
  }
  if (start_dirty == -1) {
    start_dirty = end_dirty;
  }
  if (clear_end > start_dirty) {
    ui_line(grid, row, coloff+start_dirty, coloff+end_dirty, coloff+clear_end,
            bg_attr, wrap);
  }
}





void rl_mirror(char_u *str)
{
  char_u *p1, *p2;
  int t;

  for (p1 = str, p2 = str + strlen((char *)(str)) - 1; p1 < p2; ++p1, --p2) {
    t = *p1;
    *p1 = *p2;
    *p2 = t;
  }
}




void status_redraw_all(void)
{

  for (win_T *wp = ((curtab) == curtab) ? firstwin : (curtab)->tp_firstwin; wp != 
# 4714 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
 ((void *)0)
# 4714 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
 ; wp = wp->w_next) {
    if (wp->w_status_height) {
      wp->w_redr_status = 1;
      redraw_later(10);
    }
  }
}


void status_redraw_curbuf(void)
{
  status_redraw_buf(curbuf);
}


void status_redraw_buf(buf_T *buf)
{
  for (win_T *wp = ((curtab) == curtab) ? firstwin : (curtab)->tp_firstwin; wp != 
# 4731 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
 ((void *)0)
# 4731 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
 ; wp = wp->w_next) {
    if (wp->w_status_height != 0 && wp->w_buffer == buf) {
      wp->w_redr_status = 
# 4733 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                         1
# 4733 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                             ;
      redraw_later(10);
    }
  }
}




void redraw_statuslines(void)
{
  for (win_T *wp = ((curtab) == curtab) ? firstwin : (curtab)->tp_firstwin; wp != 
# 4744 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
 ((void *)0)
# 4744 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
 ; wp = wp->w_next) {
    if (wp->w_redr_status) {
      win_redr_status(wp);
    }
  }
  if (redraw_tabline)
    draw_tabline();
}




void win_redraw_last_status(const frame_T *frp)
  FUNC_ATTR_NONNULL_ARG(1)
{
  if (frp->fr_layout == 0) {
    frp->fr_win->w_redr_status = 
# 4760 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                1
# 4760 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                    ;
  } else if (frp->fr_layout == 1) {
    for (frp = frp->fr_child; frp != 
# 4762 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
   ((void *)0)
# 4762 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
   ; frp = frp->fr_next) {
      win_redraw_last_status(frp);
    }
  } else {
    
# 4766 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
   ((void) sizeof ((
# 4766 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
   frp->fr_layout == 2
# 4766 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 4766 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
   frp->fr_layout == 2
# 4766 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
   ) ; else __assert_fail (
# 4766 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
   "frp->fr_layout == FR_COL"
# 4766 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
   , "/home/toto/.env/encours/neovim/src/nvim/screen.c", 4766, __extension__ __PRETTY_FUNCTION__); }))
# 4766 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                   ;
    frp = frp->fr_child;
    while (frp->fr_next != 
# 4768 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                          ((void *)0)
# 4768 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                              ) {
      frp = frp->fr_next;
    }
    win_redraw_last_status(frp);
  }
}




static void draw_vsep_win(win_T *wp, int row)
{
  int hl;
  int c;

  if (wp->w_vsep_width) {

    c = fillchar_vsep(wp, &hl);
    grid_fill(&default_grid, wp->w_winrow + row, (wp->w_winrow + wp->w_height),
              (wp->w_wincol + wp->w_width), (wp->w_wincol + wp->w_width) + 1, c, ' ', hl);
  }
}





static int status_match_len(expand_T *xp, char_u *s)
{
  int len = 0;

  int emenu = (xp->xp_context == EXPAND_MENUS
               || xp->xp_context == EXPAND_MENUNAMES);


  if (emenu && menu_is_separator(s))
    return 1;

  while (*s != '\000') {
    s += skip_status_match_char(xp, s);
    len += ptr2cells(s);
    (s += utfc_ptr2len((char_u *)s));
  }

  return len;
}





static int skip_status_match_char(expand_T *xp, char_u *s)
{
  if ((rem_backslash(s) && xp->xp_context != EXPAND_HELP)
      || ((xp->xp_context == EXPAND_MENUS
           || xp->xp_context == EXPAND_MENUNAMES)
          && (s[0] == '\t' || (s[0] == '\\' && s[1] != '\000')))
      ) {

    if (xp->xp_shell && csh_like_shell() && s[1] == '\\' && s[2] == '!')
      return 2;

    return 1;
  }
  return 0;
}
# 4842 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
void
win_redr_status_matches (
    expand_T *xp,
    int num_matches,
    char_u **matches,
    int match,
    int showtail
)
{

  int row;
  char_u *buf;
  int len;
  int clen;
  int fillchar;
  int attr;
  int i;
  int highlight = 1;
  char_u *selstart = 
# 4860 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                         ((void *)0)
# 4860 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                             ;
  int selstart_col = 0;
  char_u *selend = 
# 4862 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                       ((void *)0)
# 4862 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                           ;
  static int first_match = 0;
  int add_left = 0;
  char_u *s;
  int emenu;
  int l;

  if (matches == 
# 4869 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                ((void *)0)
# 4869 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                    )
    return;

  buf = xmalloc(Columns * 21 + 1);

  if (match == -1) {
    match = 0;
    highlight = 0;
  }

  clen = status_match_len(xp, (showtail ? sm_gettail(matches[match], 
# 4879 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                             0
# 4879 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                             ) : matches[match])) + 3;
  if (match == 0)
    first_match = 0;
  else if (match < first_match) {

    first_match = match;
    add_left = 1;
  } else {

    for (i = first_match; i < match; ++i)
      clen += status_match_len(xp, (showtail ? sm_gettail(matches[i], 
# 4889 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                  0
# 4889 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                  ) : matches[i])) + 2;
    if (first_match > 0)
      clen += 2;

    if ((long)clen > Columns) {
      first_match = match;

      clen = 2;
      for (i = match; i < num_matches; ++i) {
        clen += status_match_len(xp, (showtail ? sm_gettail(matches[i], 
# 4898 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                    0
# 4898 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                    ) : matches[i])) + 2;
        if ((long)clen >= Columns) {
          break;
        }
      }
      if (i == num_matches)
        add_left = 1;
    }
  }
  if (add_left)
    while (first_match > 0) {
      clen += status_match_len(xp, (showtail ? sm_gettail(matches[first_match - 1], 
# 4909 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                  0
# 4909 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                  ) : matches[first_match - 1])) + 2;
      if ((long)clen >= Columns) {
        break;
      }
      first_match--;
    }

  fillchar = fillchar_status(&attr, curwin);

  if (first_match == 0) {
    *buf = '\000';
    len = 0;
  } else {
    strcpy((char *)(buf), (char *)("< "));
    len = 2;
  }
  clen = len;

  i = first_match;
  while ((long)(clen + status_match_len(xp, (showtail ? sm_gettail(matches[i], 
# 4928 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                           0
# 4928 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                           ) : matches[i])) + 2) < Columns) {
    if (i == match) {
      selstart = buf + len;
      selstart_col = clen;
    }

    s = (showtail ? sm_gettail(matches[i], 
# 4934 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
       0
# 4934 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
       ) : matches[i]);

    emenu = (xp->xp_context == EXPAND_MENUS
             || xp->xp_context == EXPAND_MENUNAMES);
    if (emenu && menu_is_separator(s)) {
      strcpy((char *)(buf + len), (char *)(transchar('|')));
      l = (int)strlen((char *)(buf + len));
      len += l;
      clen += l;
    } else
      for (; *s != '\000'; ++s) {
        s += skip_status_match_char(xp, s);
        clen += ptr2cells(s);
        if ((l = (*utfc_ptr2len)(s)) > 1) {
          strncpy((char *)(buf + len), (char *)(s), (size_t)(l));
          s += l - 1;
          len += l;
        } else {
          strcpy((char *)(buf + len), (char *)(transchar_byte(*s)));
          len += (int)strlen((char *)(buf + len));
        }
      }
    if (i == match)
      selend = buf + len;

    *(buf + len++) = ' ';
    *(buf + len++) = ' ';
    clen += 2;
    if (++i == num_matches)
      break;
  }

  if (i != num_matches) {
    *(buf + len++) = '>';
    ++clen;
  }

  buf[len] = '\000';

  row = cmdline_row - 1;
  if (row >= 0) {
    if (wild_menu_showing == 0 || wild_menu_showing == WM_LIST) {
      if (msg_scrolled > 0) {


        if (cmdline_row == Rows - 1) {
          msg_scroll_up(
# 4980 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                       0
# 4980 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                            );
          msg_scrolled++;
        } else {
          cmdline_row++;
          row++;
        }
        wild_menu_showing = WM_SCROLLED;
      } else {



        if (lastwin->w_status_height == 0) {
          save_p_ls = p_ls;
          save_p_wmh = p_wmh;
          p_ls = 2;
          p_wmh = 0;
          last_status(0);
        }
        wild_menu_showing = WM_SHOWN;
      }
    }



    ScreenGrid *grid = (wild_menu_showing == WM_SCROLLED)
                        ? &msg_grid_adj : &default_grid;

    grid_puts(grid, buf, row, 0, attr);
    if (selstart != 
# 5008 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                   ((void *)0) 
# 5008 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                        && highlight) {
      *selend = '\000';
      grid_puts(grid, selstart, row, selstart_col, highlight_attr[(int)(HLF_WM)]);
    }

    grid_fill(grid, row, row + 1, clen, Columns,
              fillchar, fillchar, attr);
  }

  win_redraw_last_status(topframe);
  xfree(buf);
}




static void win_redr_status(win_T *wp)
{
  int row;
  char_u *p;
  int len;
  int fillchar;
  int attr;
  int this_ru_col;
  static int busy = 0;



  if (busy

      || (wild_menu_showing != 0 && !ui_has(kUIWildmenu))) {
    return;
  }
  busy = 
# 5041 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
        1
# 5041 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
            ;

  wp->w_redr_status = 0;
  if (wp->w_status_height == 0) {

    redraw_cmdline = 
# 5046 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                    1
# 5046 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                        ;
  } else if (!redrawing()) {


    wp->w_redr_status = 
# 5050 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                       1
# 5050 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                           ;
  } else if (*p_stl != '\000' || *wp->w_onebuf_opt.wo_stl != '\000') {

    redraw_custom_statusline(wp);
  } else {
    fillchar = fillchar_status(&attr, wp);

    get_trans_bufname(wp->w_buffer);
    p = NameBuff;
    len = (int)strlen((char *)(p));

    if (bt_help(wp->w_buffer)
        || wp->w_onebuf_opt.wo_pvw
        || bufIsChanged(wp->w_buffer)
        || wp->w_buffer->b_p_ro) {
      *(p + len++) = ' ';
    }
    if (bt_help(wp->w_buffer)) {
      strcpy((char *)(p + len), (char *)(gettext((char *)("[Help]"))));
      len += (int)strlen((char *)(p + len));
    }
    if (wp->w_onebuf_opt.wo_pvw) {
      strcpy((char *)(p + len), (char *)(gettext((char *)("[Preview]"))));
      len += (int)strlen((char *)(p + len));
    }
    if (bufIsChanged(wp->w_buffer)) {
      strcpy((char *)(p + len), (char *)("[+]"));
      len += 3;
    }
    if (wp->w_buffer->b_p_ro) {
      strcpy((char *)(p + len), (char *)(gettext((char *)("[RO]"))));

    }

    this_ru_col = ru_col - (Columns - wp->w_width);
    if (this_ru_col < (wp->w_width + 1) / 2) {
      this_ru_col = (wp->w_width + 1) / 2;
    }
    if (this_ru_col <= 1) {
      p = (char_u *)"<";
      len = 1;
    } else {
      int clen = 0, i;


      clen = (int)mb_string2cells(p);



      for (i = 0; p[i] != '\000' && clen >= this_ru_col - 1;
           i += utfc_ptr2len(p + i)) {
        clen -= utf_ptr2cells(p + i);
      }
      len = clen;
      if (i > 0) {
        p = p + i - 1;
        *p = '<';
        ++len;
      }
    }

    row = (wp->w_winrow + wp->w_height);
    grid_puts(&default_grid, p, row, wp->w_wincol, attr);
    grid_fill(&default_grid, row, row + 1, len + wp->w_wincol,
              this_ru_col + wp->w_wincol, fillchar, fillchar, attr);

    if (get_keymap_str(wp, (char_u *)"<%s>", NameBuff, 
# 5116 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                                      4096
# 5116 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                              )
        && this_ru_col - len > (int)(strlen((char *)(NameBuff)) + 1))
      grid_puts(&default_grid, NameBuff, row,
                (int)(this_ru_col - strlen((char *)(NameBuff)) - 1), attr);

    win_redr_ruler(wp, 1);
  }




  if (wp->w_vsep_width != 0 && wp->w_status_height != 0 && redrawing()) {
    if (stl_connected(wp)) {
      fillchar = fillchar_status(&attr, wp);
    } else {
      fillchar = fillchar_vsep(wp, &attr);
    }
    grid_putchar(&default_grid, fillchar, (wp->w_winrow + wp->w_height), (wp->w_wincol + wp->w_width), attr);
  }
  busy = 0;
}





static void redraw_custom_statusline(win_T *wp)
{
  static int entered = 
# 5144 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                      0
# 5144 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                           ;
  int saved_did_emsg = did_emsg;



  if (entered)
    return;
  entered = 1;

  did_emsg = 
# 5153 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
            0
# 5153 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                 ;
  win_redr_custom(wp, 
# 5154 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                     0
# 5154 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                          );
  if (did_emsg) {



    set_string_option_direct((char_u *)"statusline", -1,
        (char_u *)"", OPT_FREE | (*wp->w_onebuf_opt.wo_stl != '\000'
                                  ? OPT_LOCAL : OPT_GLOBAL), -5);
  }
  did_emsg |= saved_did_emsg;
  entered = 
# 5164 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
           0
# 5164 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                ;
}






int stl_connected(win_T *wp)
{
  frame_T *fr;

  fr = wp->w_frame;
  while (fr->fr_parent != 
# 5177 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                         ((void *)0)
# 5177 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                             ) {
    if (fr->fr_parent->fr_layout == 2) {
      if (fr->fr_next != 
# 5179 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                        ((void *)0)
# 5179 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                            )
        break;
    } else {
      if (fr->fr_next != 
# 5182 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                        ((void *)0)
# 5182 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                            )
        return 1;
    }
    fr = fr->fr_parent;
  }
  return 0;
}





int
get_keymap_str (
    win_T *wp,
    char_u *fmt,
    char_u *buf,
    int len
)
{
  char_u *p;

  if (wp->w_buffer->b_p_iminsert != 1)
    return 0;

  {
    buf_T *old_curbuf = curbuf;
    win_T *old_curwin = curwin;
    char_u *s;

    curbuf = wp->w_buffer;
    curwin = wp;
    strcpy((char *)(buf), (char *)("b:keymap_name"));
    ++emsg_skip;
    s = p = eval_to_string(buf, 
# 5216 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                               ((void *)0)
# 5216 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                   , 0);
    --emsg_skip;
    curbuf = old_curbuf;
    curwin = old_curwin;
    if (p == 
# 5220 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
            ((void *)0) 
# 5220 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                 || *p == '\000') {
      if (wp->w_buffer->b_kmap_state & 2) {
        p = wp->w_buffer->b_p_keymap;
      } else {
        p = (char_u *)"lang";
      }
    }
    if (vim_snprintf((char *)buf, len, (char *)fmt, p) > len - 1) {
      buf[0] = '\000';
    }
    xfree(s);
  }
  return buf[0] != '\000';
}





static void
win_redr_custom (
    win_T *wp,
    int draw_ruler
)
{
  static int entered = 0;
  int attr;
  int curattr;
  int row;
  int col = 0;
  int maxwidth;
  int width;
  int n;
  int len;
  int fillchar;
  char_u buf[
# 5255 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
            4096
# 5255 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                    ];
  char_u *stl;
  char_u *p;
  struct stl_hlrec hltab[80];
  StlClickRecord tabtab[80];
  int use_sandbox = 
# 5260 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                   0
# 5260 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                        ;
  win_T *ewp;
  int p_crb_save;

  ScreenGrid *grid = &default_grid;




  if (entered)
    return;
  entered = 1;


  if (wp == 
# 5274 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
           ((void *)0)
# 5274 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
               ) {

    stl = p_tal;
    row = 0;
    fillchar = ' ';
    attr = highlight_attr[(int)(HLF_TPF)];
    maxwidth = Columns;
    use_sandbox = was_set_insecurely((char_u *)"tabline", 0);
  } else {
    row = (wp->w_winrow + wp->w_height);
    fillchar = fillchar_status(&attr, wp);
    maxwidth = wp->w_width;

    if (draw_ruler) {
      stl = p_ruf;

      if (*stl == '%') {
        if (*++stl == '-')
          stl++;
        if (atoi((char *)stl))
          while (ascii_isdigit(*stl))
            stl++;
        if (*stl++ != '(')
          stl = p_ruf;
      }
      col = ru_col - (Columns - wp->w_width);
      if (col < (wp->w_width + 1) / 2) {
        col = (wp->w_width + 1) / 2;
      }
      maxwidth = wp->w_width - col;
      if (!wp->w_status_height) {
        grid = &msg_grid_adj;
        row = Rows - 1;
        maxwidth--;
        fillchar = ' ';
        attr = highlight_attr[(int)(HLF_MSG)];
      }

      use_sandbox = was_set_insecurely((char_u *)"rulerformat", 0);
    } else {
      if (*wp->w_onebuf_opt.wo_stl != '\000')
        stl = wp->w_onebuf_opt.wo_stl;
      else
        stl = p_stl;
      use_sandbox = was_set_insecurely((char_u *)"statusline",
          *wp->w_onebuf_opt.wo_stl == '\000' ? 0 : OPT_LOCAL);
    }

    col += wp->w_wincol;
  }

  if (maxwidth <= 0)
    goto theend;



  ewp = wp == 
# 5330 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
             ((void *)0) 
# 5330 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                  ? curwin : wp;
  p_crb_save = ewp->w_onebuf_opt.wo_crb;
  ewp->w_onebuf_opt.wo_crb = 0;



  stl = vim_strsave(stl);
  width = build_stl_str_hl(ewp, buf, sizeof(buf),
      stl, use_sandbox,
      fillchar, maxwidth, hltab, tabtab);
  xfree(stl);
  ewp->w_onebuf_opt.wo_crb = p_crb_save;


  p = (char_u *)transstr((const char *)buf);
  len = xstrlcpy((char *)(buf), (char *)(p), (size_t)(sizeof(buf)));
  len = (size_t)len < sizeof(buf) ? len : (int)sizeof(buf) - 1;
  xfree(p);


  while (width < maxwidth && len < (int)sizeof(buf) - 1) {
    len += utf_char2bytes(fillchar, buf + len);
    width++;
  }
  buf[len] = '\000';




  grid_puts_line_start(grid, row);

  curattr = attr;
  p = buf;
  for (n = 0; hltab[n].start != 
# 5363 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                               ((void *)0)
# 5363 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                   ; n++) {
    int textlen = (int)(hltab[n].start - p);
    grid_puts_len(grid, p, textlen, row, col, curattr);
    col += vim_strnsize(p, textlen);
    p = hltab[n].start;

    if (hltab[n].userhl == 0)
      curattr = attr;
    else if (hltab[n].userhl < 0)
      curattr = syn_id2attr(-hltab[n].userhl);
    else if (wp != 
# 5373 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                  ((void *)0) 
# 5373 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                       && wp != curwin && wp->w_status_height != 0)
      curattr = highlight_stlnc[hltab[n].userhl - 1];
    else
      curattr = highlight_user[hltab[n].userhl - 1];
  }

  grid_puts(grid, p >= buf + len ? (char_u *)"" : p, row, col,
            curattr);

  grid_puts_line_flush(
# 5382 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                      0
# 5382 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                           );

  if (wp == 
# 5384 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
           ((void *)0)
# 5384 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
               ) {

    col = 0;
    len = 0;
    p = buf;
    StlClickDefinition cur_click_def = {
      .type = kStlClickDisabled,
    };
    for (n = 0; tabtab[n].start != 
# 5392 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                  ((void *)0)
# 5392 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                      ; n++) {
      len += vim_strnsize(p, (int)(tabtab[n].start - (char *) p));
      while (col < len) {
        tab_page_click_defs[col++] = cur_click_def;
      }
      p = (char_u *) tabtab[n].start;
      cur_click_def = tabtab[n].def;
    }
    while (col < Columns) {
      tab_page_click_defs[col++] = cur_click_def;
    }
  }

theend:
  entered = 0;
}





static void schar_from_ascii(char_u *p, const char c)
{
  p[0] = c;
  p[1] = 0;
}


static int schar_from_char(char_u *p, int c)
{
  int len = utf_char2bytes(c, p);
  p[len] = '\000';
  return len;
}


static int schar_from_cc(char_u *p, int c, int u8cc[6])
{
  int len = utf_char2bytes(c, p);
  for (int i = 0; i < 6; i++) {
    if (u8cc[i] == 0) {
      break;
    }
    len += utf_char2bytes(u8cc[i], p + len);
  }
  p[len] = 0;
  return len;
}


static int schar_cmp(char_u *sc1, char_u *sc2)
{
  return strncmp((char *)(sc1), (char *)(sc2), (size_t)(sizeof(schar_T)));
}


static void schar_copy(char_u *sc1, char_u *sc2)
{
  xstrlcpy((char *)(sc1), (char *)(sc2), (size_t)(sizeof(schar_T)));
}

static int line_off2cells(schar_T *line, size_t off, size_t max_off)
{
  return (off + 1 < max_off && line[off + 1][0] == 0) ? 2 : 1;
}



static int grid_off2cells(ScreenGrid *grid, size_t off, size_t max_off)
{
  return line_off2cells(grid->chars, off, max_off);
}






# 5469 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
_Bool 
# 5469 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
    grid_lefthalve(ScreenGrid *grid, int row, int col)
{
  screen_adjust_grid(&grid, &row, &col);

  return grid_off2cells(grid, grid->line_offset[row] + col,
                        grid->line_offset[row] + grid->Columns) > 1;
}



int grid_fix_col(ScreenGrid *grid, int col, int row)
{
  int coloff = 0;
  screen_adjust_grid(&grid, &row, &coloff);

  col += coloff;
  if (grid->chars != 
# 5485 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                    ((void *)0) 
# 5485 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                         && col > 0
      && grid->chars[grid->line_offset[row] + col][0] == 0) {
    return col - 1 - coloff;
  }
  return col - coloff;
}


void grid_putchar(ScreenGrid *grid, int c, int row, int col, int attr)
{
  char_u buf[21 + 1];

  buf[utf_char2bytes(c, buf)] = '\000';
  grid_puts(grid, buf, row, col, attr);
}



void grid_getbytes(ScreenGrid *grid, int row, int col, char_u *bytes,
                   int *attrp)
{
  unsigned off;

  screen_adjust_grid(&grid, &row, &col);


  if (grid->chars != 
# 5511 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                    ((void *)0) 
# 5511 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                         && row < grid->Rows && col < grid->Columns) {
    off = grid->line_offset[row] + col;
    *attrp = grid->attrs[off];
    schar_copy(bytes, grid->chars[off]);
  }
}






void grid_puts(ScreenGrid *grid, char_u *text, int row, int col, int attr)
{
  grid_puts_len(grid, text, -1, row, col, attr);
}

static ScreenGrid *put_dirty_grid = 
# 5528 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                   ((void *)0)
# 5528 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                       ;
static int put_dirty_row = -1;
static int put_dirty_first = 0x7fffffff;
static int put_dirty_last = 0;





void grid_puts_line_start(ScreenGrid *grid, int row)
{
  int col = 0;
  screen_adjust_grid(&grid, &row, &col);
  
# 5541 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
 ((void) sizeof ((
# 5541 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
 put_dirty_row == -1
# 5541 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
 ) ? 1 : 0), __extension__ ({ if (
# 5541 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
 put_dirty_row == -1
# 5541 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
 ) ; else __assert_fail (
# 5541 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
 "put_dirty_row == -1"
# 5541 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
 , "/home/toto/.env/encours/neovim/src/nvim/screen.c", 5541, __extension__ __PRETTY_FUNCTION__); }))
# 5541 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                            ;
  put_dirty_row = row;
  put_dirty_grid = grid;
}



void grid_puts_len(ScreenGrid *grid, char_u *text, int textlen, int row,
                   int col, int attr)
{
  unsigned off;
  char_u *ptr = text;
  int len = textlen;
  int c;
  unsigned max_off;
  int mbyte_blen = 1;
  int mbyte_cells = 1;
  int u8c = 0;
  int u8cc[6];
  int clear_next_cell = 0;
  int prev_c = 0;
  int pc, nc, nc1;
  int pcc[6];
  int need_redraw;
  
# 5565 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
 _Bool 
# 5565 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
      do_flush = 
# 5565 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                 0
# 5565 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                      ;

  screen_adjust_grid(&grid, &row, &col);



  if (grid->chars == 
# 5571 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                    ((void *)0)
      
# 5572 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
     || row >= grid->Rows || row < 0
      || col >= grid->Columns || col < 0) {
    return;
  }

  if (put_dirty_row == -1) {
    grid_puts_line_start(grid, row);
    do_flush = 
# 5579 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
              1
# 5579 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                  ;
  } else {
    if (grid != put_dirty_grid || row != put_dirty_row) {
      abort();
    }
  }
  off = grid->line_offset[row] + col;



  if (grid != &default_grid && col == 0 && grid_invalid_row(grid, row)) {

    put_dirty_first = -1;
    put_dirty_last = 
# 5592 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                    (((
# 5592 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                    put_dirty_last
# 5592 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                    )>(
# 5592 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                    1
# 5592 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                    ))?(
# 5592 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                    put_dirty_last
# 5592 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                    ):(
# 5592 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                    1
# 5592 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                    ))
# 5592 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                          ;
  }

  max_off = grid->line_offset[row] + grid->Columns;
  while (col < grid->Columns
         && (len < 0 || (int)(ptr - text) < len)
         && *ptr != '\000') {
    c = *ptr;

    if (len > 0) {
      mbyte_blen = utfc_ptr2len_len(ptr, (int)((text + len) - ptr));
    } else {
      mbyte_blen = utfc_ptr2len(ptr);
    }
    if (len >= 0) {
      u8c = utfc_ptr2char_len(ptr, u8cc, (int)((text + len) - ptr));
    } else {
      u8c = utfc_ptr2char(ptr, u8cc);
    }
    mbyte_cells = utf_char2cells(u8c);
    if (p_arshape && !p_tbidi && arabic_char(u8c)) {

      if (len >= 0 && (int)(ptr - text) + mbyte_blen >= len) {

        nc = '\000';
        nc1 = '\000';
      } else {
        nc = utfc_ptr2char_len(ptr + mbyte_blen, pcc,
                               (int)((text + len) - ptr - mbyte_blen));
        nc1 = pcc[0];
      }
      pc = prev_c;
      prev_c = u8c;
      u8c = arabic_shape(u8c, &c, &u8cc[0], nc, nc1, pc);
    } else {
      prev_c = u8c;
    }
    if (col + mbyte_cells > grid->Columns) {


      c = '>';
      mbyte_cells = 1;
    }

    schar_T buf;
    schar_from_cc(buf, u8c, u8cc);


    need_redraw = schar_cmp(grid->chars[off], buf)
                  || (mbyte_cells == 2 && grid->chars[off + 1][0] != 0)
                  || grid->attrs[off] != attr
                  || exmode_active;

    if (need_redraw) {





      if (clear_next_cell) {
        clear_next_cell = 
# 5652 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                         0
# 5652 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                              ;
      } else if ((len < 0 ? ptr[mbyte_blen] == '\000'
                  : ptr + mbyte_blen >= text + len)
                 && ((mbyte_cells == 1
                      && grid_off2cells(grid, off, max_off) > 1)
                     || (mbyte_cells == 2
                         && grid_off2cells(grid, off, max_off) == 1
                         && grid_off2cells(grid, off + 1, max_off) > 1))) {
        clear_next_cell = 
# 5660 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                         1
# 5660 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                             ;
      }

      schar_copy(grid->chars[off], buf);
      grid->attrs[off] = attr;
      if (mbyte_cells == 2) {
        grid->chars[off + 1][0] = 0;
        grid->attrs[off + 1] = attr;
      }
      put_dirty_first = 
# 5669 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                       (((
# 5669 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                       put_dirty_first
# 5669 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                       )<(
# 5669 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                       col
# 5669 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                       ))?(
# 5669 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                       put_dirty_first
# 5669 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                       ):(
# 5669 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                       col
# 5669 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                       ))
# 5669 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                ;
      put_dirty_last = 
# 5670 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                      (((
# 5670 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                      put_dirty_last
# 5670 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                      )>(
# 5670 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                      col+mbyte_cells
# 5670 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                      ))?(
# 5670 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                      put_dirty_last
# 5670 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                      ):(
# 5670 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                      col+mbyte_cells
# 5670 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                      ))
# 5670 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                          ;
    }

    off += mbyte_cells;
    col += mbyte_cells;
    ptr += mbyte_blen;
    if (clear_next_cell) {

      ptr = (char_u *)" ";
      len = -1;
    }
  }

  if (do_flush) {
    grid_puts_line_flush(
# 5684 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                        1
# 5684 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                            );
  }
}







void grid_puts_line_flush(
# 5694 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                         _Bool 
# 5694 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                              set_cursor)
{
  
# 5696 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
 ((void) sizeof ((
# 5696 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
 put_dirty_row != -1
# 5696 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
 ) ? 1 : 0), __extension__ ({ if (
# 5696 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
 put_dirty_row != -1
# 5696 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
 ) ; else __assert_fail (
# 5696 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
 "put_dirty_row != -1"
# 5696 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
 , "/home/toto/.env/encours/neovim/src/nvim/screen.c", 5696, __extension__ __PRETTY_FUNCTION__); }))
# 5696 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                            ;
  if (put_dirty_first < put_dirty_last) {
    if (set_cursor) {
      ui_grid_cursor_goto(put_dirty_grid->handle, put_dirty_row,
                          
# 5700 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                         (((
# 5700 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                         put_dirty_last
# 5700 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                         )<(
# 5700 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                         put_dirty_grid->Columns-1
# 5700 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                         ))?(
# 5700 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                         put_dirty_last
# 5700 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                         ):(
# 5700 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                         put_dirty_grid->Columns-1
# 5700 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                         ))
# 5700 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                                       );
    }
    if (!put_dirty_grid->throttled) {
      ui_line(put_dirty_grid, put_dirty_row, put_dirty_first, put_dirty_last,
              put_dirty_last, 0, 
# 5704 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                0
# 5704 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                     );
    } else if (put_dirty_grid->dirty_col) {
      if (put_dirty_last > put_dirty_grid->dirty_col[put_dirty_row]) {
        put_dirty_grid->dirty_col[put_dirty_row] = put_dirty_last;
      }
    }
    put_dirty_first = 0x7fffffff;
    put_dirty_last = 0;
  }
  put_dirty_row = -1;
  put_dirty_grid = 
# 5714 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                  ((void *)0)
# 5714 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                      ;
}




static void start_search_hl(void)
{
  if (p_hls && !no_hlsearch) {
    end_search_hl();
    last_pat_prog(&search_hl.rm);

    search_hl.tm = profile_setlimit(p_rdt);
  }
}




static void end_search_hl(void)
{
  if (search_hl.rm.regprog != 
# 5735 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                             ((void *)0)
# 5735 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                 ) {
    vim_regfree(search_hl.rm.regprog);
    search_hl.rm.regprog = 
# 5737 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                          ((void *)0)
# 5737 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                              ;
  }
}





static void init_search_hl(win_T *wp)
  FUNC_ATTR_NONNULL_ALL
{


  matchitem_T *cur = wp->w_match_head;
  while (cur != 
# 5751 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
               ((void *)0)
# 5751 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                   ) {
    cur->hl.rm = cur->match;
    if (cur->hlg_id == 0)
      cur->hl.attr = 0;
    else
      cur->hl.attr = syn_id2attr(cur->hlg_id);
    cur->hl.buf = wp->w_buffer;
    cur->hl.lnum = 0;
    cur->hl.first_lnum = 0;

    cur->hl.tm = profile_setlimit(p_rdt);
    cur = cur->next;
  }
  search_hl.buf = wp->w_buffer;
  search_hl.lnum = 0;
  search_hl.first_lnum = 0;
  search_hl.attr = win_hl_attr(wp, HLF_L);


}




static void prepare_search_hl(win_T *wp, linenr_T lnum)
  FUNC_ATTR_NONNULL_ALL
{
  matchitem_T *cur;
  match_T *shl;
  
# 5780 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
 _Bool 
# 5780 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
      shl_flag;





  cur = wp->w_match_head;
  shl_flag = 
# 5787 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
            0
# 5787 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                 ;
  while (cur != 
# 5788 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
               ((void *)0) 
# 5788 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                    || shl_flag == 
# 5788 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                   0
# 5788 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                        ) {
    if (shl_flag == 
# 5789 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                   0
# 5789 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                        ) {
      shl = &search_hl;
      shl_flag = 
# 5791 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                1
# 5791 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                    ;
    } else {
      shl = &cur->hl;
    }
    if (shl->rm.regprog != 
# 5795 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                          ((void *)0)
        
# 5796 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
       && shl->lnum == 0
        && re_multiline(shl->rm.regprog)) {
      if (shl->first_lnum == 0) {
        for (shl->first_lnum = lnum;
             shl->first_lnum > wp->w_topline;
             shl->first_lnum--) {
          if (hasFoldingWin(wp, shl->first_lnum - 1, 
# 5802 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                                    ((void *)0)
# 5802 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                        , 
# 5802 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                                          ((void *)0)
# 5802 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                              , 
# 5802 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                                                1
# 5802 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                                    , 
# 5802 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                                                      ((void *)0)
# 5802 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                                          )) {
            break;
          }
        }
      }
      if (cur != 
# 5807 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                ((void *)0)
# 5807 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                    ) {
        cur->pos.cur = 0;
      }
      
# 5810 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
     _Bool 
# 5810 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
          pos_inprogress = 
# 5810 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                           1
# 5810 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                               ;

      int n = 0;
      while (shl->first_lnum < lnum && (shl->rm.regprog != 
# 5813 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                                          ((void *)0)
                                        
# 5814 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                       || (cur != 
# 5814 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                                  ((void *)0) 
# 5814 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                       && pos_inprogress))) {
        next_search_hl(wp, shl, shl->first_lnum, (colnr_T)n,
                       shl == &search_hl ? 
# 5816 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                          ((void *)0) 
# 5816 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                               : cur);
        pos_inprogress = !(cur == 
# 5817 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                 ((void *)0) 
# 5817 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                      || cur->pos.cur == 0);
        if (shl->lnum != 0) {
          shl->first_lnum = shl->lnum
                            + shl->rm.endpos[0].lnum
                            - shl->rm.startpos[0].lnum;
          n = shl->rm.endpos[0].col;
        } else {
          ++shl->first_lnum;
          n = 0;
        }
      }
    }
    if (shl != &search_hl && cur != 
# 5829 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                   ((void *)0)
# 5829 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                       )
      cur = cur->next;
  }
}
# 5842 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
static void
next_search_hl (
    win_T *win,
    match_T *shl,
    linenr_T lnum,
    colnr_T mincol,
    matchitem_T *cur
)
  FUNC_ATTR_NONNULL_ARG(2)
{
  linenr_T l;
  colnr_T matchcol;
  long nmatched = 0;
  int save_called_emsg = called_emsg;

  if (shl->lnum != 0) {




    l = shl->lnum + shl->rm.endpos[0].lnum - shl->rm.startpos[0].lnum;
    if (lnum > l)
      shl->lnum = 0;
    else if (lnum < l || shl->rm.endpos[0].col > mincol)
      return;
  }





  called_emsg = 0;
  for (;; ) {

    if (profile_passed_limit(shl->tm)) {
      shl->lnum = 0;
      break;
    }





    if (shl->lnum == 0) {
      matchcol = 0;
    } else if (vim_strchr(p_cpo, 'c') == 
# 5887 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                               ((void *)0)
               
# 5888 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
              || (shl->rm.endpos[0].lnum == 0
                   && shl->rm.endpos[0].col <= shl->rm.startpos[0].col)) {
      char_u *ml;

      matchcol = shl->rm.startpos[0].col;
      ml = ml_get_buf(shl->buf, lnum, 0) + matchcol;
      if (*ml == '\000') {
        ++matchcol;
        shl->lnum = 0;
        break;
      }
      matchcol += utfc_ptr2len(ml);
    } else {
      matchcol = shl->rm.endpos[0].col;
    }

    shl->lnum = lnum;
    if (shl->rm.regprog != 
# 5905 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                          ((void *)0)
# 5905 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                              ) {


      
# 5908 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
     _Bool 
# 5908 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
          regprog_is_copy = (shl != &search_hl
                              && cur != 
# 5909 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                       ((void *)0)
                              
# 5910 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                             && shl == &cur->hl
                              && cur->match.regprog == cur->hl.rm.regprog);
      int timed_out = 
# 5912 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                     0
# 5912 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                          ;

      nmatched = vim_regexec_multi(&shl->rm, win, shl->buf, lnum, matchcol,
                                   &(shl->tm), &timed_out);

      if (regprog_is_copy) {
        cur->match.regprog = cur->hl.rm.regprog;
      }
      if (called_emsg || got_int || timed_out) {

        if (shl == &search_hl) {

          vim_regfree(shl->rm.regprog);
          set_no_hlsearch(
# 5925 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                         1
# 5925 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                             );
        }
        shl->rm.regprog = 
# 5927 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                         ((void *)0)
# 5927 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                             ;
        shl->lnum = 0;
        got_int = 0;
        break;
      }
    } else if (cur != 
# 5932 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                     ((void *)0)
# 5932 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                         ) {
      nmatched = next_search_hl_pos(shl, lnum, &(cur->pos), matchcol);
    }
    if (nmatched == 0) {
      shl->lnum = 0;
      break;
    }
    if (shl->rm.startpos[0].lnum > 0
        || shl->rm.startpos[0].col >= mincol
        || nmatched > 1
        || shl->rm.endpos[0].col > mincol) {
      shl->lnum += shl->rm.startpos[0].lnum;
      break;
    }


    called_emsg = save_called_emsg;
  }
}



static int
next_search_hl_pos(
    match_T *shl,
    linenr_T lnum,
    posmatch_T *posmatch,
    colnr_T mincol
)
  FUNC_ATTR_NONNULL_ALL
{
  int i;
  int found = -1;

  shl->lnum = 0;
  for (i = posmatch->cur; i < 8; i++) {
    llpos_T *pos = &posmatch->pos[i];

    if (pos->lnum == 0) {
      break;
    }
    if (pos->len == 0 && pos->col < mincol) {
      continue;
    }
    if (pos->lnum == lnum) {
      if (found >= 0) {


        if (pos->col < posmatch->pos[found].col) {
          llpos_T tmp = *pos;

          *pos = posmatch->pos[found];
          posmatch->pos[found] = tmp;
        }
      } else {
        found = i;
      }
    }
  }
  posmatch->cur = 0;
  if (found >= 0) {
    colnr_T start = posmatch->pos[found].col == 0
                    ? 0: posmatch->pos[found].col - 1;
    colnr_T end = posmatch->pos[found].col == 0
                  ? MAXCOL : start + posmatch->pos[found].len;

    shl->lnum = lnum;
    shl->rm.startpos[0].lnum = 0;
    shl->rm.startpos[0].col = start;
    shl->rm.endpos[0].lnum = 0;
    shl->rm.endpos[0].col = end;
    shl->is_addpos = 
# 6003 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                    1
# 6003 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                        ;
    posmatch->cur = found + 1;
    return 1;
  }
  return 0;
}





void grid_fill(ScreenGrid *grid, int start_row, int end_row, int start_col,
               int end_col, int c1, int c2, int attr)
{
  schar_T sc;

  int row_off = 0, col_off = 0;
  screen_adjust_grid(&grid, &row_off, &col_off);
  start_row += row_off;
  end_row += row_off;
  start_col += col_off;
  end_col += col_off;


  if (end_row > grid->Rows) {
    end_row = grid->Rows;
  }
  if (end_col > grid->Columns) {
    end_col = grid->Columns;
  }


  if (start_row >= end_row || start_col >= end_col) {
    return;
  }

  for (int row = start_row; row < end_row; row++) {




    if (start_col > 0 && grid_fix_col(grid, start_col, row) != start_col) {
      grid_puts_len(grid, (char_u *)" ", 1, row, start_col - 1, 0);
    }
    if (end_col < grid->Columns
        && grid_fix_col(grid, end_col, row) != end_col) {
      grid_puts_len(grid, (char_u *)" ", 1, row, end_col, 0);
    }




    int dirty_first = 0x7fffffff;
    int dirty_last = 0;

    int col = start_col;
    schar_from_char(sc, c1);
    int lineoff = grid->line_offset[row];
    for (col = start_col; col < end_col; col++) {
      int off = lineoff + col;
      if (schar_cmp(grid->chars[off], sc)
          || grid->attrs[off] != attr) {
        schar_copy(grid->chars[off], sc);
        grid->attrs[off] = attr;
        if (dirty_first == 0x7fffffff) {
          dirty_first = col;
        }
        dirty_last = col+1;
      }
      if (col == start_col) {
        schar_from_char(sc, c2);
      }
    }
    if (dirty_last > dirty_first) {

      if (put_dirty_row == row) {
        put_dirty_first = 
# 6079 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                         (((
# 6079 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                         put_dirty_first
# 6079 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                         )<(
# 6079 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                         dirty_first
# 6079 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                         ))?(
# 6079 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                         put_dirty_first
# 6079 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                         ):(
# 6079 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                         dirty_first
# 6079 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                         ))
# 6079 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                          ;
        put_dirty_last = 
# 6080 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                        (((
# 6080 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                        put_dirty_last
# 6080 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                        )>(
# 6080 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                        dirty_last
# 6080 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                        ))?(
# 6080 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                        put_dirty_last
# 6080 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                        ):(
# 6080 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                        dirty_last
# 6080 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                        ))
# 6080 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                       ;
      } else if (grid->throttled) {

        
# 6083 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
       ((void) sizeof ((
# 6083 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
       grid == &msg_grid
# 6083 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
       ) ? 1 : 0), __extension__ ({ if (
# 6083 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
       grid == &msg_grid
# 6083 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
       ) ; else __assert_fail (
# 6083 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
       "grid == &msg_grid"
# 6083 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
       , "/home/toto/.env/encours/neovim/src/nvim/screen.c", 6083, __extension__ __PRETTY_FUNCTION__); }))
# 6083 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                ;
        int dirty = 0;
        if (attr != highlight_attr[(int)(HLF_MSG)] || c2 != ' ') {
          dirty = dirty_last;
        } else if (c1 != ' ') {
          dirty = dirty_first + 1;
        }
        if (grid->dirty_col && dirty > grid->dirty_col[row]) {
          grid->dirty_col[row] = dirty;
        }
      } else {
        int last = c2 != ' ' ? dirty_last : dirty_first + (c1 != ' ');
        ui_line(grid, row, dirty_first, last, dirty_last, attr, 
# 6095 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                                               0
# 6095 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                                    );
      }
    }

    if (end_col == grid->Columns) {
      grid->line_wraps[row] = 
# 6100 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                             0
# 6100 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                  ;
    }
  }
}





void check_for_delay(int check_msg_scroll)
{
  if ((emsg_on_display || (check_msg_scroll && msg_scroll))
      && !did_wait_return
      && emsg_silent == 0) {
    ui_flush();
    os_delay(1000L, 
# 6115 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                   1
# 6115 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                       );
    emsg_on_display = 
# 6116 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                     0
# 6116 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                          ;
    if (check_msg_scroll) {
      msg_scroll = 
# 6118 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                  0
# 6118 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                       ;
    }
  }
}






void win_grid_alloc(win_T *wp)
{
  ScreenGrid *grid = &wp->w_grid;

  int rows = wp->w_height_inner;
  int cols = wp->w_width_inner;

  
# 6135 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
 _Bool 
# 6135 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
      want_allocation = ui_has(kUIMultigrid) || wp->w_floating;
  
# 6136 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
 _Bool 
# 6136 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
      has_allocation = (grid->chars != 
# 6136 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                       ((void *)0)
# 6136 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                           );

  if (grid->Rows != rows) {
    wp->w_lines_valid = 0;
    xfree(wp->w_lines);
    wp->w_lines = xcalloc(rows+1, sizeof(wline_T));
  }

  int was_resized = 
# 6144 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                   0
# 6144 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                        ;
  if ((has_allocation != want_allocation)
      || grid->Rows != rows
      || grid->Columns != cols) {
    if (want_allocation) {
      grid_alloc(grid, rows, cols, wp->w_grid.valid, wp->w_grid.valid);
      grid->valid = 
# 6150 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                   1
# 6150 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                       ;
    } else {


      grid_free(grid);
      grid->Rows = rows;
      grid->Columns = cols;
      grid->valid = 
# 6157 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                   0
# 6157 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                        ;
    }
    was_resized = 
# 6159 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                 1
# 6159 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                     ;
  } else if (want_allocation && has_allocation && !wp->w_grid.valid) {
    grid_invalidate(grid);
    grid->valid = 
# 6162 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                 1
# 6162 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                     ;
  }

  grid->row_offset = wp->w_winrow;
  grid->col_offset = wp->w_wincol;





  if ((send_grid_resize || was_resized) && want_allocation) {
    ui_call_grid_resize(grid->handle, grid->Columns, grid->Rows);
  }
}


void grid_assign_handle(ScreenGrid *grid)
{
  static int last_grid_handle = 1;


  if (grid->handle == 0) {
    grid->handle = ++last_grid_handle;
  }
}
# 6198 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
void screenalloc(void)
{



  if (resizing) {
    return;
  }
  resizing = 
# 6206 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
            1
# 6206 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                ;

  int retry_count = 0;

retry:



  if ((default_grid.chars != 
# 6214 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                            ((void *)0)
       
# 6215 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
      && Rows == default_grid.Rows
       && Columns == default_grid.Columns
       )
      || Rows == 0
      || Columns == 0
      || (!full_screen && default_grid.chars == 
# 6220 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                               ((void *)0)
# 6220 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                   )) {
    resizing = 
# 6221 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
              0
# 6221 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                   ;
    return;
  }





  ++RedrawingDisabled;



  ui_comp_set_screen_valid(
# 6233 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                          0
# 6233 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                               );
  if (msg_grid.chars) {
    msg_grid_invalid = 
# 6235 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                      1
# 6235 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                          ;
  }

  win_new_shellsize();

  comp_col();
# 6252 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
  grid_alloc(&default_grid, Rows, Columns, 
# 6252 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                          1
# 6252 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                              , 
# 6252 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                                1
# 6252 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                    );
  StlClickDefinition *new_tab_page_click_defs = xcalloc(
      (size_t)Columns, sizeof(*new_tab_page_click_defs));

  clear_tab_page_click_defs(tab_page_click_defs, tab_page_click_defs_size);
  xfree(tab_page_click_defs);

  tab_page_click_defs = new_tab_page_click_defs;
  tab_page_click_defs_size = Columns;

  default_grid.row_offset = 0;
  default_grid.col_offset = 0;
  default_grid.handle = 1;

  must_redraw = 50;

  RedrawingDisabled--;





  if (starting == 0 && ++retry_count <= 3) {
    apply_autocmds(EVENT_VIMRESIZED, 
# 6275 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                    ((void *)0)
# 6275 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                        , 
# 6275 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                          ((void *)0)
# 6275 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                              , 0, curbuf);


    goto retry;
  }

  resizing = 
# 6281 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
            0
# 6281 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                 ;
}

void grid_alloc(ScreenGrid *grid, int rows, int columns, 
# 6284 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                                        _Bool 
# 6284 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                             copy, 
# 6284 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                                                   _Bool 
# 6284 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                                        valid)
{
  int new_row;
  ScreenGrid new = *grid;
  
# 6288 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
 ((void) sizeof ((
# 6288 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
 rows >= 0 && columns >= 0
# 6288 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
 ) ? 1 : 0), __extension__ ({ if (
# 6288 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
 rows >= 0 && columns >= 0
# 6288 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
 ) ; else __assert_fail (
# 6288 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
 "rows >= 0 && columns >= 0"
# 6288 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
 , "/home/toto/.env/encours/neovim/src/nvim/screen.c", 6288, __extension__ __PRETTY_FUNCTION__); }))
# 6288 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                  ;
  size_t ncells = (size_t)rows * columns;
  new.chars = xmalloc(ncells * sizeof(schar_T));
  new.attrs = xmalloc(ncells * sizeof(sattr_T));
  new.line_offset = xmalloc((size_t)(rows * sizeof(unsigned)));
  new.line_wraps = xmalloc((size_t)(rows * sizeof(char_u)));

  new.Rows = rows;
  new.Columns = columns;

  for (new_row = 0; new_row < new.Rows; new_row++) {
    new.line_offset[new_row] = new_row * new.Columns;
    new.line_wraps[new_row] = 
# 6300 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                             0
# 6300 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                  ;

    grid_clear_line(&new, new.line_offset[new_row], columns, valid);

    if (copy) {




      if (new_row < grid->Rows && grid->chars != 
# 6309 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                                ((void *)0)
# 6309 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                    ) {
        int len = 
# 6310 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                 (((
# 6310 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                 grid->Columns
# 6310 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                 )<(
# 6310 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                 new.Columns
# 6310 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                 ))?(
# 6310 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                 grid->Columns
# 6310 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                 ):(
# 6310 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                 new.Columns
# 6310 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                 ))
# 6310 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                ;
        memmove(new.chars + new.line_offset[new_row],
                grid->chars + grid->line_offset[new_row],
                (size_t)len * sizeof(schar_T));
        memmove(new.attrs + new.line_offset[new_row],
                grid->attrs + grid->line_offset[new_row],
                (size_t)len * sizeof(sattr_T));
      }
    }
  }
  grid_free(grid);
  *grid = new;



  if (linebuf_size < (size_t)columns) {
    xfree(linebuf_char);
    xfree(linebuf_attr);
    linebuf_char = xmalloc(columns * sizeof(schar_T));
    linebuf_attr = xmalloc(columns * sizeof(sattr_T));
    linebuf_size = columns;
  }
}

void grid_free(ScreenGrid *grid)
{
  xfree(grid->chars);
  xfree(grid->attrs);
  xfree(grid->line_offset);
  xfree(grid->line_wraps);

  grid->chars = 
# 6341 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
               ((void *)0)
# 6341 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                   ;
  grid->attrs = 
# 6342 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
               ((void *)0)
# 6342 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                   ;
  grid->line_offset = 
# 6343 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                     ((void *)0)
# 6343 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                         ;
  grid->line_wraps = 
# 6344 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                    ((void *)0)
# 6344 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                        ;
}


void screen_free_all_mem(void)
{
  grid_free(&default_grid);
  xfree(linebuf_char);
  xfree(linebuf_attr);
}





void clear_tab_page_click_defs(StlClickDefinition *const tpcd,
                               const long tpcd_size)
{
  if (tpcd != 
# 6362 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
             ((void *)0)
# 6362 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                 ) {
    for (long i = 0; i < tpcd_size; i++) {
      if (i == 0 || tpcd[i].func != tpcd[i - 1].func) {
        xfree(tpcd[i].func);
      }
    }
    memset(tpcd, 0, (size_t) tpcd_size * sizeof(tpcd[0]));
  }
}

void screenclear(void)
{
  check_for_delay(
# 6374 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                 0
# 6374 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                      );
  screenalloc();

  int i;

  if (starting == 2 || default_grid.chars == 
# 6379 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                                    ((void *)0)
# 6379 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                        ) {
    return;
  }


  for (i = 0; i < default_grid.Rows; i++) {
    grid_clear_line(&default_grid, default_grid.line_offset[i],
                    (int)default_grid.Columns, 
# 6386 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                              1
# 6386 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                  );
    default_grid.line_wraps[i] = 
# 6387 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                0
# 6387 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                     ;
  }

  ui_call_grid_clear(1);
  ui_comp_set_screen_valid(
# 6391 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                          1
# 6391 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                              );

  clear_cmdline = 
# 6393 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                 0
# 6393 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                      ;
  mode_displayed = 
# 6394 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                  0
# 6394 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                       ;

  redraw_all_later(40);
  redraw_cmdline = 
# 6397 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                  1
# 6397 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                      ;
  redraw_tabline = 
# 6398 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                  1
# 6398 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                      ;
  redraw_popupmenu = 
# 6399 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                    1
# 6399 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                        ;
  pum_invalidate();
  for (win_T *wp = ((curtab) == curtab) ? firstwin : (curtab)->tp_firstwin; wp != 
# 6401 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
 ((void *)0)
# 6401 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
 ; wp = wp->w_next) {
    if (wp->w_floating) {
      wp->w_redr_type = 50;
    }
  }
  if (must_redraw == 50) {
    must_redraw = 40;
  }
  compute_cmdrow();
  msg_row = cmdline_row;
  msg_col = 0;
  msg_scrolled = 0;
  msg_didany = 
# 6413 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
              0
# 6413 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                   ;
  msg_didout = 
# 6414 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
              0
# 6414 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                   ;
  if (highlight_attr[(int)(HLF_MSG)] > 0 && msg_use_grid() && msg_grid.chars) {
    grid_invalidate(&msg_grid);
    msg_grid_validate();
    msg_grid_invalid = 
# 6418 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                      0
# 6418 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                           ;
    clear_cmdline = 
# 6419 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                   1
# 6419 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                       ;
  }
}



void grid_clear_line(ScreenGrid *grid, unsigned off, int width, 
# 6425 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                                               _Bool 
# 6425 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                                    valid)
{
  for (int col = 0; col < width; col++) {
    schar_from_ascii(grid->chars[off + col], ' ');
  }
  int fill = valid ? 0 : -1;
  (void)memset(grid->attrs + off, fill, (size_t)width * sizeof(sattr_T));
}

void grid_invalidate(ScreenGrid *grid)
{
  (void)memset(grid->attrs, -1, grid->Rows * grid->Columns * sizeof(sattr_T));
}


# 6439 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
_Bool 
# 6439 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
    grid_invalid_row(ScreenGrid *grid, int row)
{
  return grid->attrs[grid->line_offset[row]] < 0;
}




static void linecopy(ScreenGrid *grid, int to, int from, int col, int width)
{
  unsigned off_to = grid->line_offset[to] + col;
  unsigned off_from = grid->line_offset[from] + col;

  memmove(grid->chars + off_to, grid->chars + off_from,
          width * sizeof(schar_T));
  memmove(grid->attrs + off_to, grid->attrs + off_from,
          width * sizeof(sattr_T));
}




void setcursor(void)
{
  if (redrawing()) {
    validate_cursor();

    ScreenGrid *grid = &curwin->w_grid;
    int row = curwin->w_wrow;
    int col = curwin->w_wcol;
    if (curwin->w_onebuf_opt.wo_rl) {


      col = curwin->w_width_inner - curwin->w_wcol
                    - ((utf_ptr2cells(get_cursor_pos_ptr()) == 2
                        && vim_isprintc(gchar_cursor())) ? 2 : 1);
    }

    screen_adjust_grid(&grid, &row, &col);
    ui_grid_cursor_goto(grid->handle, row, col);
  }
}





void win_scroll_lines(win_T *wp, int row, int line_count)
{
  if (!redrawing() || line_count == 0) {
    return;
  }


  if (row + abs(line_count) >= wp->w_grid.Rows) {
    return;
  }

  if (line_count < 0) {
    grid_del_lines(&wp->w_grid, row, -line_count,
                   wp->w_grid.Rows, 0, wp->w_grid.Columns);
  } else {
    grid_ins_lines(&wp->w_grid, row, line_count,
                   wp->w_grid.Rows, 0, wp->w_grid.Columns);
  }
}
# 6523 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
void grid_ins_lines(ScreenGrid *grid, int row, int line_count, int end, int col,
                    int width)
{
  int i;
  int j;
  unsigned temp;

  int row_off = 0;
  screen_adjust_grid(&grid, &row_off, &col);
  row += row_off;
  end += row_off;

  if (line_count <= 0) {
    return;
  }



  for (i = 0; i < line_count; i++) {
    if (width != grid->Columns) {

      j = end - 1 - i;
      while ((j -= line_count) >= row) {
        linecopy(grid, j + line_count, j, col, width);
      }
      j += line_count;
      grid_clear_line(grid, grid->line_offset[j] + col, width, 
# 6549 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                                              0
# 6549 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                                   );
      grid->line_wraps[j] = 
# 6550 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                           0
# 6550 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                ;
    } else {
      j = end - 1 - i;
      temp = grid->line_offset[j];
      while ((j -= line_count) >= row) {
        grid->line_offset[j + line_count] = grid->line_offset[j];
        grid->line_wraps[j + line_count] = grid->line_wraps[j];
      }
      grid->line_offset[j + line_count] = temp;
      grid->line_wraps[j + line_count] = 
# 6559 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                        0
# 6559 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                             ;
      grid_clear_line(grid, temp, (int)grid->Columns, 
# 6560 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                                     0
# 6560 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                          );
    }
  }

  if (!grid->throttled) {
    ui_call_grid_scroll(grid->handle, row, end, col, col+width, -line_count, 0);
  }

  return;
}





void grid_del_lines(ScreenGrid *grid, int row, int line_count, int end, int col,
                    int width)
{
  int j;
  int i;
  unsigned temp;

  int row_off = 0;
  screen_adjust_grid(&grid, &row_off, &col);
  row += row_off;
  end += row_off;

  if (line_count <= 0) {
    return;
  }



  for (i = 0; i < line_count; i++) {
    if (width != grid->Columns) {

      j = row + i;
      while ((j += line_count) <= end - 1) {
        linecopy(grid, j - line_count, j, col, width);
      }
      j -= line_count;
      grid_clear_line(grid, grid->line_offset[j] + col, width, 
# 6601 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                                              0
# 6601 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                                   );
      grid->line_wraps[j] = 
# 6602 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                           0
# 6602 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                ;
    } else {

      j = row + i;
      temp = grid->line_offset[j];
      while ((j += line_count) <= end - 1) {
        grid->line_offset[j - line_count] = grid->line_offset[j];
        grid->line_wraps[j - line_count] = grid->line_wraps[j];
      }
      grid->line_offset[j - line_count] = temp;
      grid->line_wraps[j - line_count] = 
# 6612 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                        0
# 6612 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                             ;
      grid_clear_line(grid, temp, (int)grid->Columns, 
# 6613 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                                     0
# 6613 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                          );
    }
  }

  if (!grid->throttled) {
    ui_call_grid_scroll(grid->handle, row, end, col, col+width, line_count, 0);
  }

  return;
}
# 6631 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
int showmode(void)
{
  int need_clear;
  int length = 0;
  int do_mode;
  int attr;
  int nwr_save;
  int sub_attr;

  if (ui_has(kUIMessages) && clear_cmdline) {
    msg_ext_clear(
# 6641 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                 1
# 6641 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                     );
  }


  msg_ext_ui_flush();

  msg_grid_validate();

  do_mode = ((p_smd && msg_silent == 0)
             && ((State & 0x2000)
                 || (State & 0x10)
                 || restart_edit
                 || VIsual_active));
  if (do_mode || reg_recording != 0) {



    if (!redrawing() || (char_avail() && !KeyTyped) || msg_silent != 0) {
      redraw_cmdline = 1;
      return 0;
    }

    nwr_save = need_wait_return;


    check_for_delay(0);


    need_clear = clear_cmdline;
    if (clear_cmdline && cmdline_row < Rows - 1) {
      msg_clr_cmdline();
    }


    msg_pos_mode();
    attr = highlight_attr[(int)(HLF_CM)];



    msg_no_more = 
# 6680 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                 1
# 6680 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                     ;
    int save_lines_left = lines_left;
    lines_left = 0;

    if (do_mode) {
      msg_puts_attr((const char *)("--"), (attr));

      if (edit_submode != 
# 6687 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                         ((void *)0) 
# 6687 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                              && !shortmess(SHM_COMPLETIONMENU)) {



        if (ui_has(kUIMessages)) {
          length = 0x7fffffff;
        } else {
          length = (Rows - msg_row) * Columns - 3;
        }
        if (edit_submode_extra != 
# 6696 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                 ((void *)0)
# 6696 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                     ) {
          length -= vim_strsize(edit_submode_extra);
        }
        if (length > 0) {
          if (edit_submode_pre != 
# 6700 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                 ((void *)0)
# 6700 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                     )
            length -= vim_strsize(edit_submode_pre);
          if (length - vim_strsize(edit_submode) > 0) {
            if (edit_submode_pre != 
# 6703 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                   ((void *)0)
# 6703 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                       ) {
              msg_puts_attr((const char *)edit_submode_pre, attr);
            }
            msg_puts_attr((const char *)edit_submode, attr);
          }
          if (edit_submode_extra != 
# 6708 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                   ((void *)0)
# 6708 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                       ) {
            msg_puts_attr((const char *)(" "), (attr));
            if ((int)edit_submode_highl < (int)HLF_COUNT) {
              sub_attr = win_hl_attr(curwin, edit_submode_highl);
            } else {
              sub_attr = attr;
            }
            msg_puts_attr((const char *)edit_submode_extra, sub_attr);
          }
        }
      } else {
        if (State & 0x2000) {
          msg_puts_attr((const char *)(gettext((char *)(" TERMINAL"))), (attr));
        } else if (State & 0x80)
          msg_puts_attr((const char *)(gettext((char *)(" VREPLACE"))), (attr));
        else if (State & 0x40)
          msg_puts_attr((const char *)(gettext((char *)(" REPLACE"))), (attr));
        else if (State & 0x10) {
          if (p_ri)
            msg_puts_attr((const char *)(gettext((char *)(" REVERSE"))), (attr));
          msg_puts_attr((const char *)(gettext((char *)(" INSERT"))), (attr));
        } else if (restart_edit == 'I' || restart_edit == 'i'
                   || restart_edit == 'a') {
          msg_puts_attr((const char *)(gettext((char *)(" (insert)"))), (attr));
        } else if (restart_edit == 'R') {
          msg_puts_attr((const char *)(gettext((char *)(" (replace)"))), (attr));
        } else if (restart_edit == 'V') {
          msg_puts_attr((const char *)(gettext((char *)(" (vreplace)"))), (attr));
        }
        if (p_hkmap) {
          msg_puts_attr((const char *)(gettext((char *)(" Hebrew"))), (attr));
        }
        if (State & 0x20) {
          if (curwin->w_onebuf_opt.wo_arab) {
            msg_puts_attr((const char *)(gettext((char *)(" Arabic"))), (attr));
          } else if (get_keymap_str(curwin, (char_u *)" (%s)",
                                    NameBuff, 
# 6744 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                             4096
# 6744 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                     )) {
            msg_puts_attr((const char *)(NameBuff), (attr));
          }
        }
        if ((State & 0x10) && p_paste)
          msg_puts_attr((const char *)(gettext((char *)(" (paste)"))), (attr));

        if (VIsual_active) {
          char *p;



          switch ((VIsual_select ? 4 : 0)
                  + (VIsual_mode == 22) * 2
                  + (VIsual_mode == 'V')) {
          case 0: p = " VISUAL"; break;
          case 1: p = " VISUAL LINE"; break;
          case 2: p = " VISUAL BLOCK"; break;
          case 4: p = " SELECT"; break;
          case 5: p = " SELECT LINE"; break;
          default: p = " SELECT BLOCK"; break;
          }
          msg_puts_attr((const char *)(gettext((char *)(p))), (attr));
        }
        msg_puts_attr((const char *)(" --"), (attr));
      }

      need_clear = 1;
    }
    if (reg_recording != 0
        && edit_submode == 
# 6774 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                          ((void *)0)
        
# 6775 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
       ) {
      recording_mode(attr);
      need_clear = 
# 6777 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                  1
# 6777 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                      ;
    }

    mode_displayed = 1;
    if (need_clear || clear_cmdline)
      msg_clr_eos();
    msg_didout = 0;
    length = msg_col;
    msg_col = 0;
    msg_no_more = 
# 6786 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                 0
# 6786 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                      ;
    lines_left = save_lines_left;
    need_wait_return = nwr_save;
  } else if (clear_cmdline && msg_silent == 0) {

    msg_clr_cmdline();
  }


  msg_ext_flush_showmode();


  if (VIsual_active)
    clear_showcmd();



  win_T *last = lastwin_nofloating();
  if (redrawing() && last->w_status_height == 0) {
    win_redr_ruler(last, 
# 6805 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                        1
# 6805 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                            );
  }
  redraw_cmdline = 
# 6807 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                  0
# 6807 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                       ;
  clear_cmdline = 
# 6808 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                 0
# 6808 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                      ;

  return length;
}




static void msg_pos_mode(void)
{
  msg_col = 0;
  msg_row = Rows - 1;
}




void unshowmode(
# 6825 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
               _Bool 
# 6825 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                    force)
{

  if (!redrawing() || (!force && char_avail() && !KeyTyped)) {
    redraw_cmdline = 
# 6829 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                    1
# 6829 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                        ;
  } else {
    clearmode();
  }
}


void clearmode(void)
{
  const int save_msg_row = msg_row;
  const int save_msg_col = msg_col;

  msg_ext_ui_flush();
  msg_pos_mode();
  if (reg_recording != 0) {
    recording_mode(highlight_attr[(int)(HLF_CM)]);
  }
  msg_clr_eos();
  msg_ext_flush_showmode();

  msg_col = save_msg_col;
  msg_row = save_msg_row;
}

static void recording_mode(int attr)
{
  msg_puts_attr((const char *)(gettext((char *)("recording"))), (attr));
  if (!shortmess(SHM_RECORDING)) {
    char_u s[4];
    snprintf((char *)s, ((sizeof(s)/sizeof((s)[0])) / ((size_t)(!(sizeof(s) % sizeof((s)[0]))))), " @%c", reg_recording);
    msg_puts_attr((const char *)(s), (attr));
  }
}




void draw_tabline(void)
{
  int tabcount = 0;
  int tabwidth = 0;
  int col = 0;
  int scol = 0;
  int attr;
  win_T *wp;
  win_T *cwp;
  int wincount;
  int modified;
  int c;
  int len;
  int attr_nosel = highlight_attr[(int)(HLF_TP)];
  int attr_fill = highlight_attr[(int)(HLF_TPF)];
  char_u *p;
  int room;
  int use_sep_chars = (t_colors < 8
                       );

  if (default_grid.chars == 
# 6886 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                           ((void *)0)
# 6886 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                               ) {
    return;
  }
  redraw_tabline = 
# 6889 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                  0
# 6889 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                       ;

  if (ui_has(kUITabline)) {
    ui_ext_tabline_update();
    return;
  }

  if (tabline_height() < 1)
    return;



  
# 6901 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
 ((void) sizeof ((
# 6901 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
 Columns == tab_page_click_defs_size
# 6901 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
 ) ? 1 : 0), __extension__ ({ if (
# 6901 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
 Columns == tab_page_click_defs_size
# 6901 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
 ) ; else __assert_fail (
# 6901 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
 "Columns == tab_page_click_defs_size"
# 6901 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
 , "/home/toto/.env/encours/neovim/src/nvim/screen.c", 6901, __extension__ __PRETTY_FUNCTION__); }))
# 6901 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                            ;
  clear_tab_page_click_defs(tab_page_click_defs, tab_page_click_defs_size);


  if (*p_tal != '\000') {
    int saved_did_emsg = did_emsg;



    did_emsg = 
# 6910 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
              0
# 6910 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                   ;
    win_redr_custom(
# 6911 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                   ((void *)0)
# 6911 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                       , 
# 6911 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                         0
# 6911 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                              );
    if (did_emsg) {
      set_string_option_direct((char_u *)"tabline", -1,
                               (char_u *)"", OPT_FREE, -5);
    }
    did_emsg |= saved_did_emsg;
  } else {
    for (tabpage_T *tp = first_tabpage; tp != 
# 6918 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
   ((void *)0)
# 6918 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
   ; tp = tp->tp_next) {
      ++tabcount;
    }

    if (tabcount > 0) {
      tabwidth = (Columns - 1 + tabcount / 2) / tabcount;
    }

    if (tabwidth < 6) {
      tabwidth = 6;
    }

    attr = attr_nosel;
    tabcount = 0;

    for (tabpage_T *tp = first_tabpage; tp != 
# 6933 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
   ((void *)0)
# 6933 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
   ; tp = tp->tp_next) {
      if (col >= Columns - 4) {
        break;
      }

      scol = col;

      if (tp == curtab) {
        cwp = curwin;
        wp = firstwin;
      } else {
        cwp = tp->tp_curwin;
        wp = tp->tp_firstwin;
      }


      if (tp->tp_topframe == topframe) {
        attr = win_hl_attr(cwp, HLF_TPS);
      }
      if (use_sep_chars && col > 0) {
        grid_putchar(&default_grid, '|', 0, col++, attr);
      }

      if (tp->tp_topframe != topframe) {
        attr = win_hl_attr(cwp, HLF_TP);
      }

      grid_putchar(&default_grid, ' ', 0, col++, attr);

      modified = 
# 6962 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                0
# 6962 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                     ;

      for (wincount = 0; wp != 
# 6964 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                              ((void *)0)
# 6964 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                  ; wp = wp->w_next, ++wincount) {
        if (bufIsChanged(wp->w_buffer)) {
          modified = 
# 6966 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                    1
# 6966 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                        ;
        }
      }


      if (modified || wincount > 1) {
        if (wincount > 1) {
          vim_snprintf((char *)NameBuff, 
# 6973 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                        4096
# 6973 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                , "%d", wincount);
          len = (int)strlen((char *)(NameBuff));
          if (col + len >= Columns - 3) {
            break;
          }
          grid_puts_len(&default_grid, NameBuff, len, 0, col,
                        hl_combine_attr(attr, win_hl_attr(cwp, HLF_T)));
          col += len;
        }
        if (modified) {
          grid_puts_len(&default_grid, (char_u *)"+", 1, 0, col++, attr);
        }
        grid_putchar(&default_grid, ' ', 0, col++, attr);
      }

      room = scol - col + tabwidth - 1;
      if (room > 0) {

        get_trans_bufname(cwp->w_buffer);
        (void)shorten_dir(NameBuff);
        len = vim_strsize(NameBuff);
        p = NameBuff;
        while (len > room) {
          len -= ptr2cells(p);
          (p += utfc_ptr2len((char_u *)p));
        }
        if (len > Columns - col - 1) {
          len = Columns - col - 1;
        }

        grid_puts_len(&default_grid, p, (int)strlen((char *)(p)), 0, col, attr);
        col += len;
      }
      grid_putchar(&default_grid, ' ', 0, col++, attr);



      tabcount++;
      while (scol < col) {
        tab_page_click_defs[scol++] = (StlClickDefinition) {
          .type = kStlClickTabSwitch,
          .tabnr = tabcount,
          .func = 
# 7015 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                 ((void *)0)
# 7015 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                     ,
        };
      }
    }

    if (use_sep_chars)
      c = '_';
    else
      c = ' ';
    grid_fill(&default_grid, 0, 1, col, Columns, c, c, attr_fill);


    if (first_tabpage->tp_next != 
# 7027 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                 ((void *)0)
# 7027 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                     ) {
      grid_putchar(&default_grid, 'X', 0, Columns - 1, attr_nosel);
      tab_page_click_defs[Columns - 1] = (StlClickDefinition) {
        .type = kStlClickTabClose,
        .tabnr = 999,
        .func = 
# 7032 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
               ((void *)0)
# 7032 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                   ,
      };
    }
  }



  redraw_tabline = 0;
}

void ui_ext_tabline_update(void)
{
  Array tabs = {.size = 0, .capacity = 0, .items = 
# 7044 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
              ((void *)0)
# 7044 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
              };
  for (tabpage_T *tp = first_tabpage; tp != 
# 7045 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
 ((void *)0)
# 7045 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
 ; tp = tp->tp_next) {
    Dictionary tab_info = {.size = 0, .capacity = 0, .items = 
# 7046 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                         ((void *)0)
# 7046 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                         };
    (*((((tab_info).size == (tab_info).capacity) ? (((tab_info).capacity = ((tab_info).capacity ? (tab_info).capacity << 1 : 8), (tab_info).items = xrealloc((tab_info).items, sizeof((tab_info).items[0]) * (tab_info).capacity)), 0) : 0), ((tab_info).items + ((tab_info).size++))) = (((KeyValuePair) { .key = cstr_to_string("tab"), .value = ((Object) { .type = kObjectTypeTabpage, .data.integer = tp->handle }) })));

    win_T *cwp = (tp == curtab) ? curwin : tp->tp_curwin;
    get_trans_bufname(cwp->w_buffer);
    (*((((tab_info).size == (tab_info).capacity) ? (((tab_info).capacity = ((tab_info).capacity ? (tab_info).capacity << 1 : 8), (tab_info).items = xrealloc((tab_info).items, sizeof((tab_info).items[0]) * (tab_info).capacity)), 0) : 0), ((tab_info).items + ((tab_info).size++))) = (((KeyValuePair) { .key = cstr_to_string("name"), .value = ((Object) { .type = kObjectTypeString, .data.string = cstr_to_string((char *)NameBuff) }) })));

    (*((((tabs).size == (tabs).capacity) ? (((tabs).capacity = ((tabs).capacity ? (tabs).capacity << 1 : 8), (tabs).items = xrealloc((tabs).items, sizeof((tabs).items[0]) * (tabs).capacity)), 0) : 0), ((tabs).items + ((tabs).size++))) = (((Object) { .type = kObjectTypeDictionary, .data.dictionary = tab_info })));
  }
  ui_call_tabline_update(curtab->handle, tabs);
}





void get_trans_bufname(buf_T *buf)
{
  if (buf_spname(buf) != 
# 7064 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                        ((void *)0)
# 7064 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                            )
    xstrlcpy((char *)(NameBuff), (char *)(buf_spname(buf)), (size_t)(
# 7065 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
   4096
# 7065 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
   ));
  else
    home_replace(buf, buf->b_fname, NameBuff, 
# 7067 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                             4096
# 7067 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                     , 1);
  trans_characters(NameBuff, 
# 7068 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                            4096
# 7068 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                    );
}




static int fillchar_status(int *attr, win_T *wp)
{
  int fill;
  
# 7077 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
 _Bool 
# 7077 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
      is_curwin = (wp == curwin);
  if (is_curwin) {
    *attr = win_hl_attr(wp, HLF_S);
    fill = wp->w_p_fcs_chars.stl;
  } else {
    *attr = win_hl_attr(wp, HLF_SNC);
    fill = wp->w_p_fcs_chars.stlnc;
  }



  if (*attr != 0 && ((win_hl_attr(wp, HLF_S) != win_hl_attr(wp, HLF_SNC)
                      || !is_curwin || (firstwin == lastwin))
                     || (wp->w_p_fcs_chars.stl != wp->w_p_fcs_chars.stlnc))) {
    return fill;
  }
  if (is_curwin) {
    return '^';
  }
  return '=';
}





static int fillchar_vsep(win_T *wp, int *attr)
{
  *attr = win_hl_attr(wp, HLF_C);
  return wp->w_p_fcs_chars.vert;
}




int redrawing(void)
{
  return !RedrawingDisabled
         && !(p_lz && char_avail() && !KeyTyped && !do_redraw);
}




int messaging(void)
{
  return !(p_lz && char_avail() && !KeyTyped);
}





void showruler(int always)
{
  if (!always && !redrawing())
    return;
  if ((*p_stl != '\000' || *curwin->w_onebuf_opt.wo_stl != '\000') && curwin->w_status_height) {
    redraw_custom_statusline(curwin);
  } else {
    win_redr_ruler(curwin, always);
  }

  if (need_maketitle
      || (p_icon && (stl_syntax & 1))
      || (p_title && (stl_syntax & 2))
      )
    maketitle();

  if (redraw_tabline)
    draw_tabline();
}

static void win_redr_ruler(win_T *wp, int always)
{
  static 
# 7152 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
        _Bool 
# 7152 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
             did_show_ext_ruler = 
# 7152 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                  0
# 7152 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                       ;


  if (!p_ru) {
    return;
  }





  if (wp->w_cursor.lnum > wp->w_buffer->b_ml.ml_line_count)
    return;



  if (wp == lastwin && lastwin->w_status_height == 0)
    if (edit_submode != 
# 7169 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                       ((void *)0)
# 7169 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                           )
      return;

  if (*p_ruf) {
    int save_called_emsg = called_emsg;

    called_emsg = 0;
    win_redr_custom(wp, 1);
    if (called_emsg)
      set_string_option_direct((char_u *)"rulerformat", -1,
          (char_u *)"", OPT_FREE, -5);
    called_emsg |= save_called_emsg;
    return;
  }




  int empty_line = 0;
  if (!(State & 0x10)
      && *ml_get_buf(wp->w_buffer, wp->w_cursor.lnum, 0) == '\000')
    empty_line = 1;




  validate_virtcol_win(wp);
  if ( redraw_cmdline
             || always
             || wp->w_cursor.lnum != wp->w_ru_cursor.lnum
             || wp->w_cursor.col != wp->w_ru_cursor.col
             || wp->w_virtcol != wp->w_ru_virtcol
             || wp->w_cursor.coladd != wp->w_ru_cursor.coladd
             || wp->w_topline != wp->w_ru_topline
             || wp->w_buffer->b_ml.ml_line_count != wp->w_ru_line_count
             || wp->w_topfill != wp->w_ru_topfill
             || empty_line != wp->w_ru_empty) {

    int width;
    int row;
    int fillchar;
    int attr;
    int off;
    
# 7212 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
   _Bool 
# 7212 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
        part_of_status = 
# 7212 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                         0
# 7212 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                              ;

    if (wp->w_status_height) {
      row = (wp->w_winrow + wp->w_height);
      fillchar = fillchar_status(&attr, wp);
      off = wp->w_wincol;
      width = wp->w_width;
      part_of_status = 
# 7219 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                      1
# 7219 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                          ;
    } else {
      row = Rows - 1;
      fillchar = ' ';
      attr = highlight_attr[(int)(HLF_MSG)];
      width = Columns;
      off = 0;
    }


    colnr_T virtcol = wp->w_virtcol;
    if (wp->w_onebuf_opt.wo_list && wp->w_p_lcs_chars.tab1 == '\000') {
      wp->w_onebuf_opt.wo_list = 
# 7231 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                    0
# 7231 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                         ;
      getvvcol(wp, &wp->w_cursor, 
# 7232 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                 ((void *)0)
# 7232 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                     , &virtcol, 
# 7232 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                                 ((void *)0)
# 7232 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                     );
      wp->w_onebuf_opt.wo_list = 
# 7233 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                    1
# 7233 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                        ;
    }


    char_u buffer[70];





    vim_snprintf((char *)buffer, 70, "%" 
# 7243 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                                   "l" "d" 
# 7243 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                                          ",",
        (wp->w_buffer->b_ml.ml_flags & 1) ? (int64_t)0L
                                                 : (int64_t)wp->w_cursor.lnum);
    size_t len = strlen((char *)(buffer));
    col_print(buffer + len, 70 - len,
        empty_line ? 0 : (int)wp->w_cursor.col + 1,
        (int)virtcol + 1);






    int i = (int)strlen((char *)(buffer));
    get_rel_pos(wp, buffer + i + 1, 70 - i - 1);
    int o = i + vim_strsize(buffer + i + 1);
    if (wp->w_status_height == 0) {
      o++;
    }
    int this_ru_col = ru_col - (Columns - width);
    if (this_ru_col < 0) {
      this_ru_col = 0;
    }


    if (this_ru_col < (width + 1) / 2) {
      this_ru_col = (width + 1) / 2;
    }
    if (this_ru_col + o < width) {

      while (this_ru_col + o < width && 70 > i + 4) {
        i += utf_char2bytes(fillchar, buffer + i);
        o++;
      }
      get_rel_pos(wp, buffer + i, 70 - i);
    }

    if (ui_has(kUIMessages) && !part_of_status) {
      Array content = {.size = 0, .capacity = 0, .items = 
# 7281 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                     ((void *)0)
# 7281 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                     };
      Array chunk = {.size = 0, .capacity = 0, .items = 
# 7282 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                   ((void *)0)
# 7282 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                   };
      (*((((chunk).size == (chunk).capacity) ? (((chunk).capacity = ((chunk).capacity ? (chunk).capacity << 1 : 8), (chunk).items = xrealloc((chunk).items, sizeof((chunk).items[0]) * (chunk).capacity)), 0) : 0), ((chunk).items + ((chunk).size++))) = (((Object) { .type = kObjectTypeInteger, .data.integer = attr })));
      (*((((chunk).size == (chunk).capacity) ? (((chunk).capacity = ((chunk).capacity ? (chunk).capacity << 1 : 8), (chunk).items = xrealloc((chunk).items, sizeof((chunk).items[0]) * (chunk).capacity)), 0) : 0), ((chunk).items + ((chunk).size++))) = (((Object) { .type = kObjectTypeString, .data.string = cstr_to_string((char *)buffer) })));
      (*((((content).size == (content).capacity) ? (((content).capacity = ((content).capacity ? (content).capacity << 1 : 8), (content).items = xrealloc((content).items, sizeof((content).items[0]) * (content).capacity)), 0) : 0), ((content).items + ((content).size++))) = (((Object) { .type = kObjectTypeArray, .data.array = chunk })));
      ui_call_msg_ruler(content);
      did_show_ext_ruler = 
# 7287 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                          1
# 7287 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                              ;
    } else {
      if (did_show_ext_ruler) {
        ui_call_msg_ruler((Array){.size = 0, .capacity = 0, .items = 
# 7290 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                                ((void *)0)
# 7290 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                });
        did_show_ext_ruler = 
# 7291 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                            0
# 7291 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                 ;
      }

      o = 0;
      for (i = 0; buffer[i] != '\000'; i += utfc_ptr2len(buffer + i)) {
        o += utf_ptr2cells(buffer + i);
        if (this_ru_col + o > width) {
          buffer[i] = '\000';
          break;
        }
      }

      ScreenGrid *grid = part_of_status ? &default_grid : &msg_grid_adj;
      grid_puts(grid, buffer, row, this_ru_col + off, attr);
      grid_fill(grid, row, row + 1,
                this_ru_col + off + (int)strlen((char *)(buffer)), off + width, fillchar,
                fillchar, attr);
    }

    wp->w_ru_cursor = wp->w_cursor;
    wp->w_ru_virtcol = wp->w_virtcol;
    wp->w_ru_empty = empty_line;
    wp->w_ru_topline = wp->w_topline;
    wp->w_ru_line_count = wp->w_buffer->b_ml.ml_line_count;
    wp->w_ru_topfill = wp->w_topfill;
  }
}






int number_width(win_T *wp)
{
  int n;
  linenr_T lnum;

  if (wp->w_onebuf_opt.wo_rnu && !wp->w_onebuf_opt.wo_nu) {

    lnum = wp->w_height_inner;
  } else {

    lnum = wp->w_buffer->b_ml.ml_line_count;
  }

  if (lnum == wp->w_nrwidth_line_count)
    return wp->w_nrwidth_width;
  wp->w_nrwidth_line_count = lnum;

  n = 0;
  do {
    lnum /= 10;
    ++n;
  } while (lnum > 0);


  if (n < wp->w_onebuf_opt.wo_nuw - 1)
    n = wp->w_onebuf_opt.wo_nuw - 1;

  wp->w_nrwidth_width = n;
  return n;
}


void screen_resize(int width, int height)
{
  static int busy = 0;



  if (updating_screen || busy) {
    return;
  }

  if (width < 0 || height < 0)
    return;

  if (State == (0x200 + 0x01) || State == 0x400) {

    State = 0x400;
    return;
  }





  if (curwin->w_buffer == 
# 7379 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                         ((void *)0)
# 7379 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                             )
    return;

  ++busy;

  Rows = height;
  Columns = width;
  check_shellsize();
  height = Rows;
  width = Columns;
  p_lines = Rows;
  p_columns = Columns;
  ui_call_grid_resize(1, width, height);

  send_grid_resize = 
# 7393 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                    1
# 7393 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                        ;





  if (State != 0x300 && State != 0x600 && State != 0x800) {
    screenclear();
  }

  if (starting != 2) {
    maketitle();
    changed_line_abv_curs();
    invalidate_botline();
# 7418 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
    if (State == 0x300 || State == 0x600 || State == 0x800
        || exmode_active) {
      screenalloc();
      if (msg_grid.chars) {
        msg_grid_validate();
      }


      ui_comp_set_screen_valid(
# 7426 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                              1
# 7426 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                  );
      repeat_message();
    } else {
      if (curwin->w_onebuf_opt.wo_scb)
        do_check_scrollbind(1);
      if (State & 0x08) {
        redraw_popupmenu = 
# 7432 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                          0
# 7432 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                               ;
        update_screen(40);
        redrawcmdline();
        if (pum_drawn()) {
          cmdline_pum_display(
# 7436 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                             0
# 7436 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                  );
        }
      } else {
        update_topline();
        if (pum_drawn()) {



          redraw_popupmenu = 
# 7444 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
                            0
# 7444 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
                                 ;
          ins_compl_show_pum();
        }
        update_screen(40);
        if (redrawing()) {
          setcursor();
        }
      }
    }
    ui_flush();
  }
  busy--;
}



void check_shellsize(void)
{
  if (Rows < min_rows()) {

    Rows = min_rows();
  }
  limit_screen_size();
}


void limit_screen_size(void)
{
  if (Columns < 12) {
    Columns = 12;
  } else if (Columns > 10000) {
    Columns = 10000;
  }

  if (Rows > 1000) {
    Rows = 1000;
  }
}

void win_new_shellsize(void)
{
  static long old_Rows = 0;
  static long old_Columns = 0;

  if (old_Rows != Rows) {

    if (p_window == old_Rows - 1 || old_Rows == 0) {
      p_window = Rows - 1;
    }
    old_Rows = Rows;
    shell_new_rows();
  }
  if (old_Columns != Columns) {
    old_Columns = Columns;
    shell_new_columns();
  }
}

win_T *get_win_by_grid_handle(handle_T handle)
{
  for (win_T *wp = ((curtab) == curtab) ? firstwin : (curtab)->tp_firstwin; wp != 
# 7504 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
 ((void *)0)
# 7504 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
 ; wp = wp->w_next) {
    if (wp->w_grid.handle == handle) {
      return wp;
    }
  }
  return 
# 7509 "/home/toto/.env/encours/neovim/src/nvim/screen.c" 3 4
        ((void *)0)
# 7509 "/home/toto/.env/encours/neovim/src/nvim/screen.c"
            ;
}
